Module 9) 
Python DB and Framework
1. HTML in Python
Theory:
 Introduction to embedding HTML within Python using web frameworks like Django or Flask.

Embedding HTML within Python using web frameworks like Django and Flask allows developers to create dynamic web 
applications that can serve HTML content and interact with the backend logic. Both Django and Flask are popular 
Python-based web frameworks that simplify web development by providing tools for routing, templating, and data handling. 
Below is an introduction to how you can embed HTML within Python using these frameworks:

1. Flask:
Flask is a lightweight, flexible, and minimal web framework. It is simple to set up and ideal for small to medium-sized 
applications.

How HTML is Embedded in Flask:
Flask Templates: Flask uses Jinja2 as its templating engine, which allows you to dynamically generate HTML by embedding 
Python variables, logic, and loops within HTML templates.
Steps to embed HTML in Flask:
Install Flask: First, you need to install Flask via pip:

bash
pip install flask
Create a Flask Application: Here's a simple example of how Flask embeds HTML:

python
from flask import Flask, render_template

app = Flask(__name__)

@app.route('/')
def home():
    return render_template('index.html', name="World")

if __name__ == "__main__":
    app.run(debug=True)
Creating HTML Templates: In Flask, the HTML files are placed in the templates folder. For example, create a file named 
index.html in the templates folder:

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flask Template Example</title>
</head>
<body>
    <h1>Hello, {{ name }}!</h1>
</body>
</html>
The {{ name }} is a Jinja2 placeholder that will be replaced with the Python value "World" when rendered.

Running the Flask Application: Run your Flask application using:

bash
python app.py
When you navigate to http://127.0.0.1:5000/, the Flask server will serve the HTML page with the embedded dynamic content.

2. Django:
Django is a high-level, batteries-included web framework that provides more built-in features than Flask, making it 
suitable for larger, more complex web applications.

How HTML is Embedded in Django:
Django Templates: Django uses its own templating engine to render HTML, which allows you to embed Python-like syntax 
(like variables, loops, conditions) into your HTML templates.
Steps to embed HTML in Django:
Install Django: Install Django via pip:

bash
pip install django
Create a Django Project: To create a Django project, run the following commands:

bash
django-admin startproject myproject
cd myproject
python manage.py startapp myapp
Define Views in Django: Views in Django are Python functions that render HTML content.

In the views.py file of your app (myapp/views.py), you can define a view to render a template:

python
from django.shortcuts import render

def home(request):
    context = {
        'name': 'World'
    }
    return render(request, 'home.html', context)
Create HTML Templates: In Django, HTML templates are placed in the templates folder inside your app's directory. 
Create a file called home.html:

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Django Template Example</title>
</head>
<body>
    <h1>Hello, {{ name }}!</h1>
</body>
</html>
Configure URLs: Define a URL path for your view in the urls.py of the app (myapp/urls.py):

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
]
Ensure that the app's URL configuration is included in the project's main URL file (myproject/urls.py).

Run the Django Development Server: Start the Django server with:

bash
python manage.py runserver
Visit http://127.0.0.1:8000/ in your browser to see the dynamically rendered HTML.

Key Differences between Flask and Django:
Flask:

Lightweight, more flexible.
Ideal for small-to-medium applications.
Provides just the core functionality and leaves other decisions (such as database handling) up to the developer.
Easier to start with, but less built-in features compared to Django.
Django:

Heavyweight, includes many built-in features like an ORM (Object-Relational Mapping), authentication, admin panels, 
and more.
Ideal for larger applications where you want to follow a structured approach.
Encourages a more opinionated setup (follows the "Django way").

 Generating dynamic HTML content using Django templates.

Generating dynamic HTML content using Django templates involves creating HTML files with placeholders for dynamic 
content, which is filled in by Django at runtime. Here's a step-by-step guide on how to do this:

1. Set Up a Django Project
Before using templates, ensure you have a Django project set up. If you haven't, you can start a new Django project and 
app.

bash
django-admin startproject myproject
cd myproject
python manage.py startapp myapp
2. Configure Templates in Django Settings
In your settings.py, make sure the templates directory is set up correctly. By default, Django will look for templates 
in a directory called templates within each app.

Add the following in settings.py if it's not already configured:

python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],  # Add this line if you want a global template directory
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
This configuration tells Django to search for templates in the templates directory of your project and apps.

3. Create a Template Directory
You can place HTML templates in the templates directory of your app or project. If you have a specific app, create a 
templates folder inside that app directory.

Example:

markdown
myapp/
    templates/
        myapp/
            index.html
4. Create a Template File (HTML)
Inside the templates/myapp/ directory, create an HTML file. For example, index.html.

html
<!-- templates/myapp/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dynamic Django Template</title>
</head>
<body>
    <h1>Welcome, {{ user_name }}!</h1>
    <p>Current Date and Time: {{ current_datetime }}</p>

    <ul>
        {% for item in item_list %}
            <li>{{ item.name }} - {{ item.description }}</li>
        {% endfor %}
    </ul>
</body>
</html>
In this template, {{ user_name }}, {{ current_datetime }}, and {% for item in item_list %} are placeholders for dynamic 
content that will be provided by the view.

5. Create a View to Render the Template
In the views.py file of your app, create a view that renders the template. The view will pass dynamic data to the 
template.

python
# views.py
from django.shortcuts import render
from django.utils import timezone

def index(request):
    user_name = "John Doe"
    current_datetime = timezone.now()

    # Example item list
    item_list = [
        {"name": "Item 1", "description": "This is the first item."},
        {"name": "Item 2", "description": "This is the second item."},
        {"name": "Item 3", "description": "This is the third item."},
    ]

    # Render the template and pass context data
    return render(request, 'myapp/index.html', {
        'user_name': user_name,
        'current_datetime': current_datetime,
        'item_list': item_list,
    })
6. Create a URL for the View
In the urls.py file of your app, map a URL to the view.

python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
]
7. Running the Server
Ensure your project’s urls.py includes your app’s URLs, then run the server:

bash
python manage.py runserver
When you navigate to http://127.0.0.1:8000/, the view will render the index.html template, and you’ll see dynamic 
content (like the username, current date/time, and the list of items).

8. More Template Features
Template Filters: You can use filters to manipulate data. For example:

html
<p>{{ current_datetime|date:"D d M Y" }}</p>
This will format the datetime in a more readable way.

Template Tags: Django templates provide tags for control flow, loops, and conditions:

html
{% if user_name %}
  <p>Hello, {{ user_name }}</p>
{% else %}
  <p>Hello, Guest</p>
{% endif %}
Static Files: For linking CSS, JS, or images, use the {% static %} tag after adding django.contrib.staticfiles in 
INSTALLED_APPS and configuring STATIC_URL.

Example:

html
<link rel="stylesheet" href="{% static 'css/styles.css' %}">

Lab:
 Write a Python program to render an HTML file using Django’s template system.

To render an HTML file using Django's template system, you'll need to follow these steps. Below is a basic guide for 
creating a Django project that uses templates to render an HTML file.

Steps:
Install Django: If you haven't installed Django yet, you can do so using pip:

bash
pip install django
Create a Django Project: Once Django is installed, create a Django project by running:

bash
django-admin startproject myproject
cd myproject
Create a Django App: Create a Django app where you'll define the view and templates:

bash
python manage.py startapp myapp
Configure settings.py: In the settings.py file of your project (myproject/settings.py), ensure that myapp is added to 
the INSTALLED_APPS list.

python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',  # Add your app here
]
Also, ensure that the TEMPLATES setting is configured to look for templates in the myapp folder.

python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
Create a Template Folder: In the root directory of your project, create a templates folder. Inside it, create another 
folder named myapp to hold the HTML template files.

The directory structure will look like this:

markdown
myproject/
    manage.py
    myproject/
        __init__.py
        settings.py
        urls.py
        wsgi.py
    myapp/
        __init__.py
        views.py
        models.py
        admin.py
        migrations/
    templates/
        myapp/
            index.html
Create an HTML Template: In templates/myapp/index.html, create a simple HTML file. Here's an example:

html
<!-- templates/myapp/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django Template</title>
</head>
<body>
    <h1>{{ message }}</h1>
</body>
</html>
Create a View: In myapp/views.py, create a view that will render the index.html template:

python
# myapp/views.py
from django.shortcuts import render

def index(request):
    context = {
        'message': 'Hello, this is a message rendered via Django template!',
    }
    return render(request, 'myapp/index.html', context)
Configure URLs: In myproject/urls.py, configure the URL routing to include the index view.

python
# myproject/urls.py
from django.contrib import admin
from django.urls import path
from myapp import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', views.index, name='index'),  # Map root URL to index view
]
Run the Server: Now, run the Django development server:

bash
python manage.py runserver
Visit the Page: Open a web browser and go to http://127.0.0.1:8000/. You should see the message "Hello, this is a message 
rendered via Django template!" rendered from the template.

Complete Code Summary
myproject/settings.py:

python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',  # Your app
]

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]
myapp/views.py:

python
from django.shortcuts import render

def index(request):
    context = {
        'message': 'Hello, this is a message rendered via Django template!',
    }
    return render(request, 'myapp/index.html', context)
templates/myapp/index.html:

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django Template</title>
</head>
<body>
    <h1>{{ message }}</h1>
</body>
</html>
myproject/urls.py:

python
from django.contrib import admin
from django.urls import path
from myapp import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', views.index, name='index'),
]
After completing these steps, you will have a Django app that renders an HTML file with dynamic content using Django's 
template system.

Practical Example:
1. Write a Django project that renders an HTML file displaying “Welcome to Doctor Finder” on
the home page.

To create a simple Django project that renders an HTML file displaying "Welcome to Doctor Finder" on the home page, 
follow these steps:

1. Set up a Django project
First, ensure you have Django installed. You can install it via pip if you haven’t already:

bash
pip install django
Now, create a new Django project:

bash
django-admin startproject doctor_finder
cd doctor_finder
2. Create a Django app
In Django, projects consist of one or more apps. Let’s create a home app to render the home page.

bash
python manage.py startapp home
3. Create a Template for the Home Page
In the home app, create a folder called templates inside the home directory to store your HTML files. 
Inside this templates folder, create another folder named home, and then create an index.html file:

bash
mkdir home/templates
mkdir home/templates/home
touch home/templates/home/index.html
Now, edit index.html to display "Welcome to Doctor Finder":

html
<!-- home/templates/home/index.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Finder</title>
</head>
<body>
    <h1>Welcome to Doctor Finder</h1>
</body>
</html>
4. Update views.py to Render the Template
In your home app’s views.py, import the render function and create a view to render the index.html template.

python
# home/views.py
from django.shortcuts import render

def home(request):
    return render(request, 'home/index.html')
5. Configure URL Patterns
To make this view accessible, you need to configure a URL. First, create a urls.py file inside the home app 
(if it doesn't already exist) and add the following code:

python
# home/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
]
Now, include the home app’s URLs in the project’s urls.py:

python
# doctor_finder/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('home.urls')),  # Include the home app's URLs
]
6. Configure settings.py
Make sure your home app is included in the INSTALLED_APPS list in the settings.py file:

python
# doctor_finder/settings.py
INSTALLED_APPS = [
    # other apps
    'home',  # Add the home app here
]
7. Run the Django Development Server
Now you’re ready to run the development server. In the terminal, run the following command:

bash
python manage.py runserver
8. Visit the Home Page
Open your browser and go to http://127.0.0.1:8000/. You should see:

css
Welcome to Doctor Finder
Summary of File Structure:
arduino
doctor_finder/
│
├── doctor_finder/
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
│
└── home/
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── migrations/
    ├── models.py
    ├── tests.py
    ├── views.py
    └── urls.py
    └── templates/
        └── home/
            └── index.html
This is a basic Django setup that renders an HTML file displaying "Welcome to Doctor Finder" on the home page. You can 
now extend the project by adding more functionality like a doctor search or profile page as needed.

2. CSS in Python
Theory:
 Integrating CSS with Django templates.

Integrating CSS with Django templates is a crucial step in ensuring that your web application has an appealing and structured design. Here's how to do it:

1. Organize Static Files
In Django, static files (CSS, JavaScript, images) are stored in the static directory. The directory structure typically 
looks like this:

arduino
myproject/
    myapp/
        static/
            myapp/
                css/
                    style.css
                js/
                    script.js
                images/
                    logo.png
        templates/
            myapp/
                index.html
    manage.py
2. Ensure STATICFILES_DIRS is Set Up
In your Django settings file (settings.py), ensure that you have the following configurations for static files:

python
# settings.py

STATIC_URL = '/static/'

# For development purposes, this can be left empty or filled with additional paths.
STATICFILES_DIRS = [
    BASE_DIR / "static",  # If you're storing static files at the project level
]
The STATIC_URL is the base URL for serving static files, and STATICFILES_DIRS includes directories where Django should 
look for static files.

3. Load Static Files in Templates
In the Django template where you want to link to the CSS file, you need to load the static template tag first. 
This allows Django to reference the static files correctly.

Example: Linking a CSS file in a template:
Load Static Tag: First, load the {% static %} tag at the top of the HTML file.

Link the CSS file: Use the {% static %} tag to specify the path to your CSS file.

Here’s how it looks in an HTML template (index.html):

html
{% load static %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django Site</title>
    <!-- Link to CSS -->
    <link rel="stylesheet" type="text/css" href="{% static 'myapp/css/style.css' %}">
</head>
<body>
    <h1>Welcome to My Django Site</h1>
    <p>This is a sample page using CSS from a Django static folder.</p>
</body>
</html>
In the above code:

{% load static %} loads the static file handling functionality.
{% static 'myapp/css/style.css' %} generates the correct URL to the CSS file, which will be served from the static 
directory.
4. Serving Static Files in Development
While developing, Django can automatically serve static files for you. Ensure you have django.contrib.staticfiles in 
the INSTALLED_APPS section of your settings.py. For production, you typically use a web server like Nginx or Apache to 
serve static files, but in development, Django can handle it.

If you haven't already, add this to your urls.py:

python
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    # your other URLs
] + static(settings.STATIC_URL, document_root=settings.STATIC_ROOT)
This configuration allows Django to serve static files when DEBUG = True.

5. Collect Static Files for Production
In a production environment, you usually run the collectstatic command to gather all static files into a single location:

bash
python manage.py collectstatic
This command collects all static files from each app and places them into the STATIC_ROOT directory, where your web 
server can then serve them.

Summary
Organize static files (CSS, JS, images) in the static directory inside your app.
Use {% static 'path/to/file' %} in your templates to link to CSS files.
Load the static files properly in settings.py and urls.py.
Run collectstatic for production environments.

 How to serve static files (like CSS, JavaScript) in Django.

In Django, static files such as CSS, JavaScript, images, etc., are typically served during development using Django's 
built-in staticfiles app. Here's a step-by-step guide to properly serve static files in Django:

1. Set Up Static Files in Your Project Settings
In your Django project's settings (settings.py), ensure you have the following configurations:

STATIC_URL: This setting specifies the URL prefix for accessing static files in the browser.
python
STATIC_URL = '/static/'
STATICFILES_DIRS (optional): If you have additional directories where you store static files (besides the default static 
directory in each app), you can include them here.
python
import os
STATICFILES_DIRS = [
    os.path.join(BASE_DIR, 'static'),
]
STATIC_ROOT: When you are preparing your project for production, you need to specify a directory where Django will 
collect all the static files using the collectstatic command.
python
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
2. Create Static Directories in Your App
For each app in your project, you can create a static directory to store app-specific static files (e.g., CSS, JavaScript).

Example structure:

arduino
Copy code
my_project/
    my_app/
        static/
            my_app/
                css/
                    style.css
                js/
                    app.js
    manage.py
    settings.py
Static files should be placed inside a static folder within each app. In this example, style.css and app.js are inside 
the static/my_app/ folder.
3. Include Static Files in Templates
To use static files in your HTML templates, first load the {% static %} template tag at the top of your template. Then, 
link the static resources like CSS and JavaScript.

Example:

html
{% load static %}

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django Site</title>
    <!-- Link to static CSS file -->
    <link rel="stylesheet" type="text/css" href="{% static 'my_app/css/style.css' %}">
</head>
<body>

    <h1>Welcome to My Django Site</h1>

    <!-- Link to static JavaScript file -->
    <script src="{% static 'my_app/js/app.js' %}"></script>
</body>
</html>
In this example, the {% static 'my_app/css/style.css' %} tag will be replaced by the actual path to the static file, 
like /static/my_app/css/style.css.

4. Serving Static Files in Development
During development, Django will automatically serve static files for you if the django.contrib.staticfiles app is 
installed and DEBUG is set to True.

Make sure you add 'django.contrib.staticfiles' to the INSTALLED_APPS in your settings.py.

5. Serving Static Files in Production
In production, Django does not serve static files by default. You should set up a proper web server like Nginx or 
Apache to serve static files. Here's a typical flow:

Run python manage.py collectstatic to gather all your static files in the STATIC_ROOT directory.
Configure your web server to serve files from the STATIC_ROOT directory.
For example, if you're using Nginx, you might add a configuration like this:

nginx
location /static/ {
    alias /path/to/your/staticfiles/;
}
Make sure to replace /path/to/your/staticfiles/ with the actual path to your STATIC_ROOT directory.

6. Important Commands
collectstatic: This command collects all static files from your apps and places them in the directory defined by 
STATIC_ROOT. This is required when deploying to production.
bash
python manage.py collectstatic
7. Additional Notes
For large-scale production setups, you might want to use a CDN (Content Delivery Network) to serve static files more 
efficiently.
If you're using Django 4.0+, the static files app is built-in and there’s minimal configuration needed beyond what's 
listed above.

Lab:
 Create a CSS file to style a basic HTML template in Django.

1. Set Up Your Django Project
If you haven't already set up a Django project, you can create a new one using the following commands:

bash
django-admin startproject myproject
cd myproject
python manage.py startapp myapp
2. Organize Static Files
In Django, static files (like CSS, JavaScript, and images) are usually placed inside a directory called static.

Inside your Django app (myapp), create a folder named static and then create a subfolder with the name of your app, 
like this:

arduino
myapp/
    static/
        myapp/
            css/
                styles.css
In the styles.css file, you can write your CSS.

3. Set Up settings.py
Ensure that Django is configured to serve static files. In settings.py, make sure the STATIC_URL and STATICFILES_DIRS 
are set up correctly:

python
# settings.py
STATIC_URL = '/static/'

# Add this to tell Django where to find static files if they are outside the app directories
STATICFILES_DIRS = [
    BASE_DIR / "static",
]
4. Link CSS File in HTML Template
In your HTML template, you need to link the CSS file. Django provides the {% static %} template tag to link to static 
files.

First, ensure that {% load static %} is at the top of your HTML file.
Then, use the {% static %} tag to link to the CSS file.
Example HTML Template (let’s assume base.html is your main template):

html
<!-- myapp/templates/myapp/base.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django App</title>
    {% load static %}
    <link rel="stylesheet" href="{% static 'myapp/css/styles.css' %}">
</head>
<body>
    <header>
        <h1>Welcome to My Django App</h1>
    </header>
    <main>
        <p>This is a basic Django page styled with CSS.</p>
    </main>
</body>
</html>
5. Create the CSS File
Here is an example of how the styles.css file can look:

css
/* myapp/static/myapp/css/styles.css */
body {
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
    background-color: #f4f4f4;
}

header {
    background-color: #4CAF50;
    color: white;
    text-align: center;
    padding: 20px 0;
}

h1 {
    margin: 0;
}

main {
    padding: 20px;
    font-size: 16px;
}
6. Ensure Static Files are Served in Development
If you are in development mode, Django will automatically serve static files when DEBUG=True in settings.py. To check if 
it works, run the following commands:

bash
python manage.py runserver
Open your browser and navigate to http://127.0.0.1:8000/. Your CSS file should be applied to the HTML template, and 
you'll see your styled page.

7. Optional: Template Inheritance
If you have other templates that need the same styling, you can use template inheritance. For example, you can extend 
base.html in other templates:

html
<!-- myapp/templates/myapp/child_template.html -->
{% extends 'myapp/base.html' %}

{% block content %}
    <h2>Content specific to this page</h2>
    <p>This page uses the base template and styles.</p>
{% endblock %}

Practical Example: 2) Write a Django project to display a webpage with custom CSS styling for a doctor profile page.

To create a Django project that displays a webpage with custom CSS styling for a doctor profile page, you need to 
follow these steps:

Step 1: Set Up the Django Project
Install Django if you haven’t already by running:

bash
pip install django
Create a new Django project:

bash
django-admin startproject doctor_profile
cd doctor_profile
Create a new app (for example, profile):

bash
python manage.py startapp profile
Add the app to the INSTALLED_APPS list in doctor_profile/settings.py:

python
INSTALLED_APPS = [
    ...
    'profile',
    'django.contrib.staticfiles',  # Ensure static files are included
]
Step 2: Define the Doctor Model
Inside your app (profile), open the models.py file and create a model for the doctor’s profile. For simplicity, 
we'll include fields like name, specialty, biography, and a profile picture.

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=200)
    biography = models.TextField()
    profile_picture = models.ImageField(upload_to='doctors/', blank=True, null=True)

    def __str__(self):
        return f"Dr. {self.first_name} {self.last_name}"
Step 3: Set Up the Admin Panel
To manage doctor profiles via the Django admin, register the model in profile/admin.py:

python
from django.contrib import admin
from .models import Doctor

admin.site.register(Doctor)
Step 4: Create Views and Templates
Create a view for displaying the doctor’s profile. In profile/views.py, add:
python
from django.shortcuts import render
from .models import Doctor

def doctor_profile(request, doctor_id):
    doctor = Doctor.objects.get(id=doctor_id)
    return render(request, 'profile/doctor_profile.html', {'doctor': doctor})
Create the URL pattern for this view. In profile/urls.py, add:
python
from django.urls import path
from . import views

urlpatterns = [
    path('doctor/<int:doctor_id>/', views.doctor_profile, name='doctor_profile'),
]
Include this URL in the main project’s urls.py (doctor_profile/urls.py):
python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('profile/', include('profile.urls')),
]
Create the HTML template (profile/templates/profile/doctor_profile.html):
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Profile</title>
    <link rel="stylesheet" type="text/css" href="{% static 'css/style.css' %}">
</head>
<body>
    <div class="doctor-profile">
        <div class="profile-header">
            <h1>Dr. {{ doctor.first_name }} {{ doctor.last_name }}</h1>
            <p><strong>Specialty:</strong> {{ doctor.specialty }}</p>
        </div>
        
        <div class="profile-details">
            <div class="profile-picture">
                {% if doctor.profile_picture %}
                    <img src="{{ doctor.profile_picture.url }}" alt="Profile Picture">
                {% else %}
                    <p>No profile picture available</p>
                {% endif %}
            </div>

            <div class="biography">
                <h3>Biography:</h3>
                <p>{{ doctor.biography }}</p>
            </div>
        </div>
    </div>
</body>
</html>
Step 5: Create Static Files (CSS)
Create a static directory in your profile app:

Create a folder profile/static/css/.
Create a CSS file (profile/static/css/style.css) with custom styles for the doctor profile:

css
/* style.css */
body {
    font-family: Arial, sans-serif;
    background-color: #f9f9f9;
    margin: 0;
    padding: 0;
}

.doctor-profile {
    width: 80%;
    margin: auto;
    background-color: #fff;
    padding: 20px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
    border-radius: 8px;
}

.profile-header {
    text-align: center;
    margin-bottom: 20px;
}

.profile-header h1 {
    font-size: 2.5em;
    color: #333;
}

.profile-header p {
    font-size: 1.2em;
    color: #555;
}

.profile-details {
    display: flex;
    justify-content: space-between;
    margin-top: 20px;
}

.profile-picture img {
    border-radius: 50%;
    width: 150px;
    height: 150px;
    object-fit: cover;
}

.profile-picture {
    text-align: center;
}

.biography {
    flex: 1;
    padding-left: 20px;
}

.biography h3 {
    color: #333;
    font-size: 1.5em;
}

.biography p {
    color: #666;
    font-size: 1.1em;
}
Step 6: Configure Static and Media Files
Make sure your project can serve static and media files. In doctor_profile/settings.py:

Add static and media settings:

python
STATIC_URL = '/static/'

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'
Update urls.py to serve media files during development:

python
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('profile/', include('profile.urls')),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
Step 7: Migrate Database
Run migrations to apply the model:

bash
python manage.py makemigrations
python manage.py migrate
Step 8: Run the Development Server
Create a superuser to access the Django admin:

bash
python manage.py createsuperuser
Run the server:

bash
python manage.py runserver
Now, visit http://127.0.0.1:8000/admin/ to log into the admin panel, and add a Doctor object. You can then visit 
http://127.0.0.1:8000/profile/doctor/1/ (replace 1 with the doctor's ID) to see the profile page.

Step 9: Final Adjustments
You can modify and enhance the template and CSS styles as per your requirements, including adding more fields to the 
profile, improving the layout, and adding interactive features like a contact form.

3. JavaScript with Python
Theory:
 Using JavaScript for client-side interactivity in Django templates.

Using JavaScript for client-side interactivity in Django templates is a powerful way to create dynamic, interactive 
web pages. Here's how you can integrate JavaScript into your Django templates for various interactive features.

1. Including JavaScript in Django Templates
You can include JavaScript in Django templates in several ways:

a) Inline JavaScript within Template
You can place JavaScript directly in your template within <script> tags.

Example:

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django Page</title>
</head>
<body>
    <button id="myButton">Click Me</button>
    <p id="message"></p>

    <script>
        document.getElementById("myButton").addEventListener("click", function() {
            document.getElementById("message").innerText = "Button Clicked!";
        });
    </script>
</body>
</html>
In this example, the JavaScript code is included in the <script> block at the bottom of the template, and it interacts 
with the button on the page.

b) External JavaScript Files
If your JavaScript code is too long or complex, you can place it in an external .js file and link to it from your 
template.

Create a static directory if you don’t have one yet:

myapp/static/js/ (create a js folder under your static directory).
Add the JavaScript file in that folder, e.g., scripts.js.

javascript
// scripts.js
document.getElementById("myButton").addEventListener("click", function() {
    document.getElementById("message").innerText = "Button Clicked!";
});
Link the JavaScript file in your Django template:

html
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django Page</title>
    <script src="{% static 'js/scripts.js' %}"></script>
</head>
<body>
    <button id="myButton">Click Me</button>
    <p id="message"></p>
</body>
</html>
In this setup, the JavaScript file is loaded from the static folder using Django’s {% static %} template tag.

2. Using JavaScript with Django Context Data
You can pass data from Django views to JavaScript using the Django template language. For instance, you might want to 
pass a list of items from your Django view to be rendered in JavaScript.

Example: Passing Data to JavaScript
In your Django view, you might pass a list or dictionary to the template:

python
# views.py
from django.shortcuts import render

def my_view(request):
    data = {'items': ['Item 1', 'Item 2', 'Item 3']}
    return render(request, 'my_template.html', data)
In your template, you can access this data and use it in JavaScript:

html
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django Page</title>
    <script src="{% static 'js/scripts.js' %}"></script>
</head>
<body>
    <button id="myButton">Show Items</button>
    <ul id="itemList"></ul>

    <script>
        var items = {{ items|safe }};
        
        document.getElementById("myButton").addEventListener("click", function() {
            var list = document.getElementById("itemList");
            list.innerHTML = ''; // Clear previous items

            items.forEach(function(item) {
                var listItem = document.createElement("li");
                listItem.textContent = item;
                list.appendChild(listItem);
            });
        });
    </script>
</body>
</html>
3. AJAX Requests for Dynamic Data
JavaScript can make AJAX (Asynchronous JavaScript and XML) requests to fetch data dynamically from Django without 
refreshing the page. Django can return JSON data, which JavaScript can then use to update the DOM.

Example: Fetching Data via AJAX
Django view that returns JSON:
python
# views.py
from django.http import JsonResponse

def get_items(request):
    items = ['Item 1', 'Item 2', 'Item 3']
    return JsonResponse({'items': items})
JavaScript making an AJAX request:
html
{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django Page</title>
    <script src="{% static 'js/scripts.js' %}"></script>
</head>
<body>
    <button id="myButton">Get Items</button>
    <ul id="itemList"></ul>

    <script>
        document.getElementById("myButton").addEventListener("click", function() {
            fetch("{% url 'get_items' %}")
                .then(response => response.json())
                .then(data => {
                    var list = document.getElementById("itemList");
                    list.innerHTML = ''; // Clear previous items

                    data.items.forEach(function(item) {
                        var listItem = document.createElement("li");
                        listItem.textContent = item;
                        list.appendChild(listItem);
                    });
                })
                .catch(error => console.error("Error:", error));
        });
    </script>
</body>
</html>
4. Using JavaScript Libraries (e.g., jQuery)
You can also use JavaScript libraries like jQuery in Django templates to simplify DOM manipulation and AJAX requests.

Include jQuery in your template:
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Django Page</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <button id="myButton">Show Message</button>
    <p id="message"></p>

    <script>
        $(document).ready(function() {
            $("#myButton").click(function() {
                $("#message").text("Button Clicked!");
            });
        });
    </script>
</body>
</html>
Conclusion
By embedding JavaScript into your Django templates, you can create dynamic and interactive web pages. You can:

Include JavaScript directly in templates or link to external files.
Pass data from Django views to JavaScript.
Use AJAX to fetch data asynchronously and update parts of your page without reloading.
Utilize JavaScript libraries (like jQuery) for simpler code.

 Linking external or internal JavaScript files in Django.

In Django, you can link external or internal JavaScript files to your web pages by including them in your HTML templates. 
Django uses its template system to render HTML, and JavaScript files are included like any other static assets. 
Here's how you can link both external and internal JavaScript files in Django.

1. Linking External JavaScript Files
To link external JavaScript files (such as from a CDN or an external URL), you use the <script> tag in your HTML 
template. You can place this tag inside the <head> or before the closing </body> tag of your HTML page.

Example (External JavaScript File):
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My Django Page</title>
    <!-- Link to an external JavaScript file -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
</head>
<body>
    <h1>Welcome to My Django Page</h1>

    <!-- Optionally, you can include your custom JavaScript here -->
    <script src="{% static 'js/custom.js' %}"></script>
</body>
</html>
In this example, the jQuery library is linked from a CDN, and a custom JavaScript file (custom.js) is linked using 
Django's {% static %} template tag (explained in the next section).

2. Linking Internal JavaScript Files (Stored Locally)
Django serves static files (such as JavaScript, CSS, and images) using the static tag. To link an internal JavaScript file,
you need to ensure that:

You have a static directory where your JavaScript file is stored (e.g., static/js/custom.js).
You use the {% static %} template tag to reference the static files.
Steps:
Create a static directory in your Django app or in the root directory. For example: myproject/static/js/custom.js

In your HTML template, use the {% load static %} tag at the beginning and the {% static 'path/to/js/file.js' %} to link 
the JavaScript file.

Example (Internal JavaScript File):
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>My Django Page</title>
    <!-- Load the static files -->
    {% load static %}
</head>
<body>
    <h1>Welcome to My Django Page</h1>

    <!-- Link to your internal JavaScript file -->
    <script src="{% static 'js/custom.js' %}"></script>
</body>
</html>
In this example:

The {% load static %} tag loads Django's static files system.
The {% static 'js/custom.js' %} tag generates the correct URL for your static file.
3. Ensure Static Files Are Properly Configured in Django
For Django to correctly serve static files (including JavaScript, CSS, and images), you need to have proper static file 
settings in your settings.py.

Example of settings.py configuration:
python
# settings.py

# Define the path to the static files
STATIC_URL = '/static/'

# In production, you should collect all static files into the directory specified by STATIC_ROOT
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
Additionally, in your development environment, make sure to use django.contrib.staticfiles in your INSTALLED_APPS:

python
INSTALLED_APPS = [
    # Other apps...
    'django.contrib.staticfiles',
]
For production, run the following command to collect static files into the STATIC_ROOT directory:

bash
python manage.py collectstatic
4. Serving Static Files in Development
During development, Django will automatically serve static files (including JavaScript) when DEBUG=True. If DEBUG=False 
(in production), you will need to configure your web server (e.g., Nginx or Apache) to serve static files.

Summary
External JavaScript: Use the <script> tag with a src attribute pointing to the external URL.
Internal JavaScript: Store the JavaScript file in your static directory and link it in the template using Django's 
{% static %} tag.

Lab:
 Create a Django project with JavaScript-enabled form validation.

Creating a Django project with JavaScript-enabled form validation involves several steps, including setting up the 
Django project, creating a form, enabling JavaScript for client-side validation, and connecting everything.

Step 1: Install Django
First, install Django if you don't already have it:

bash
pip install django
Step 2: Create a Django Project
Create a new Django project:

bash
django-admin startproject myproject
cd myproject
Step 3: Create a Django App
Create a new app for handling forms:

bash
python manage.py startapp myapp
Add myapp to the INSTALLED_APPS list in settings.py:

python
# myproject/settings.py

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'myapp',  # add your app here
]
Step 4: Create the Form
In myapp/forms.py, create a form for your application. For example, a simple contact form:

python
# myapp/forms.py

from django import forms

class ContactForm(forms.Form):
    name = forms.CharField(max_length=100, required=True)
    email = forms.EmailField(required=True)
    message = forms.CharField(widget=forms.Textarea, required=True)
Step 5: Create a View for the Form
Create a view that will display the form and handle the form submission.

python
# myapp/views.py

from django.shortcuts import render
from .forms import ContactForm

def contact_view(request):
    form = ContactForm()
    if request.method == 'POST':
        form = ContactForm(request.POST)
        if form.is_valid():
            # handle form submission (e.g., send email or save to database)
            return render(request, 'myapp/thank_you.html')  # Show a thank you page
    return render(request, 'myapp/contact_form.html', {'form': form})
Step 6: Create URLs for the View
In myapp/urls.py, create a URL pattern for the form view.

python
# myapp/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('contact/', views.contact_view, name='contact'),
]
Make sure to include the app's URLs in the main project's urls.py:

python
# myproject/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('myapp.urls')),  # include the app's URLs
]
Step 7: Create Templates for the Form and Thank You Page
Now create the templates to display the form and a thank-you message.

contact_form.html (form template)
html
<!-- myapp/templates/myapp/contact_form.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Contact Us</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>  <!-- Include jQuery for JS -->
</head>
<body>
    <h2>Contact Us</h2>
    <form id="contactForm" method="POST" action="{% url 'contact' %}">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Submit</button>
    </form>

    <script>
        $(document).ready(function() {
            // JavaScript validation
            $('#contactForm').on('submit', function(event) {
                var isValid = true;

                // Check if the name is empty
                if ($('#id_name').val() === '') {
                    alert('Name is required.');
                    isValid = false;
                }

                // Check if the email is empty or invalid
                var email = $('#id_email').val();
                var emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
                if (email === '' || !emailPattern.test(email)) {
                    alert('Please enter a valid email.');
                    isValid = false;
                }

                // Check if the message is empty
                if ($('#id_message').val() === '') {
                    alert('Message is required.');
                    isValid = false;
                }

                if (!isValid) {
                    event.preventDefault();  // Prevent form submission if invalid
                }
            });
        });
    </script>
</body>
</html>
thank_you.html (thank you page)
html
<!-- myapp/templates/myapp/thank_you.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Thank You</title>
</head>
<body>
    <h2>Thank You for Contacting Us!</h2>
    <p>We will get back to you soon.</p>
</body>
</html>
Step 8: Run the Server
Now run the Django development server to see the result:

bash
python manage.py runserver
Step 9: Test the Form Validation
Go to http://127.0.0.1:8000/contact/ in your browser and try to submit the form. JavaScript validation should alert you 
if the fields are empty or invalid before the form is submitted.

Practical Example: 3) Write a Django project where JavaScript is used to validate a patient registration form on the 
client side.

Creating a Django project that includes client-side JavaScript validation for a patient registration form involves 
several steps. Below is a step-by-step guide to building the project, including the necessary Django settings and 
JavaScript code.

Step 1: Setup the Django Project
Install Django if you don't already have it:

bash
pip install django
Create a new Django project:

bash
django-admin startproject patient_registration
Create a new Django app called patients:

bash
cd patient_registration
python manage.py startapp patients
Add the patients app to the INSTALLED_APPS list in patient_registration/settings.py:

python
INSTALLED_APPS = [
    # other apps...
    'patients',
]
Step 2: Define the Patient Registration Model
In the patients app, define a model for the Patient in patients/models.py:

python
from django.db import models

class Patient(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    date_of_birth = models.DateField()
    email = models.EmailField()
    phone_number = models.CharField(max_length=15)
    address = models.TextField()

    def __str__(self):
        return f"{self.first_name} {self.last_name}"
After that, run the migrations to create the table for Patient:

bash
python manage.py makemigrations
python manage.py migrate
Step 3: Create the Patient Registration Form
Create a form for the patient registration in patients/forms.py:

python
from django import forms
from .models import Patient

class PatientRegistrationForm(forms.ModelForm):
    class Meta:
        model = Patient
        fields = ['first_name', 'last_name', 'date_of_birth', 'email', 'phone_number', 'address']
Step 4: Create the View for Patient Registration
In patients/views.py, create a view to render the registration form:

python
from django.shortcuts import render
from .forms import PatientRegistrationForm

def register_patient(request):
    if request.method == 'POST':
        form = PatientRegistrationForm(request.POST)
        if form.is_valid():
            form.save()
            return render(request, 'patients/success.html')  # A success page after submission
    else:
        form = PatientRegistrationForm()
    
    return render(request, 'patients/register.html', {'form': form})
Step 5: Set Up URLs
In patients/urls.py, create the URL patterns for registration:

python
from django.urls import path
from . import views

urlpatterns = [
    path('register/', views.register_patient, name='register_patient'),
]
Make sure to include patients.urls in the main urls.py of your project (patient_registration/urls.py):

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('patients/', include('patients.urls')),
]
Step 6: Create the HTML Templates
In the patients/templates/patients directory, create the following HTML templates.

1. register.html (Patient Registration Form)
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Register Patient</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="{% static 'patients/js/form_validation.js' %}"></script>
</head>
<body>
    <h1>Patient Registration</h1>
    <form id="patient-form" method="POST">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Register</button>
    </form>
</body>
</html>
2. success.html (Confirmation page after successful submission)
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Registration Successful</title>
</head>
<body>
    <h1>Patient Registration Successful</h1>
    <p>Thank you for registering!</p>
</body>
</html>
Step 7: Create the JavaScript Validation (Client-side)
Create a JavaScript file form_validation.js in the patients/static/patients/js directory. This file will validate the 
form fields on the client side.

form_validation.js
javascript
$(document).ready(function() {
    $('#patient-form').on('submit', function(event) {
        var isValid = true;
        var errorMessage = '';

        // Validate First Name
        var firstName = $('#id_first_name').val();
        if (firstName === '') {
            isValid = false;
            errorMessage += 'First Name is required.\n';
        }

        // Validate Last Name
        var lastName = $('#id_last_name').val();
        if (lastName === '') {
            isValid = false;
            errorMessage += 'Last Name is required.\n';
        }

        // Validate Date of Birth
        var dob = $('#id_date_of_birth').val();
        if (dob === '') {
            isValid = false;
            errorMessage += 'Date of Birth is required.\n';
        }

        // Validate Email
        var email = $('#id_email').val();
        var emailPattern = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
        if (!email.match(emailPattern)) {
            isValid = false;
            errorMessage += 'Please enter a valid email.\n';
        }

        // Validate Phone Number
        var phoneNumber = $('#id_phone_number').val();
        var phonePattern = /^[0-9]{10}$/;
        if (!phoneNumber.match(phonePattern)) {
            isValid = false;
            errorMessage += 'Phone number must be 10 digits.\n';
        }

        // If the form is not valid, prevent submission and show error messages
        if (!isValid) {
            alert(errorMessage);
            event.preventDefault();
        }
    });
});
This script checks:

First Name and Last Name cannot be empty.
Date of Birth is required.
Email is validated with a regex.
Phone number should have exactly 10 digits.
Step 8: Test the Application
Run the Django development server:

bash
python manage.py runserver
Visit http://127.0.0.1:8000/patients/register/ in your browser.

You should now have a fully functional patient registration form with both server-side validation and client-side 
validation using JavaScript.

4. Django Introduction
Theory:
 Overview of Django: Web development framework.

Overview of Django: Web Development Framework
Django is a high-level, open-source web development framework for building robust and scalable web applications using 
the Python programming language. It was designed to make web development faster and easier by promoting rapid development, 
clean design, and reusability.

Here’s an overview of Django's key features and components:

1. MTV Architecture
Django follows the MTV (Model-Template-View) architectural pattern, which is similar to the more widely known MVC 
(Model-View-Controller) pattern.
Model: Represents the data and database structure (i.e., the database tables).
Template: Defines the presentation logic (HTML, CSS, etc.) and is responsible for rendering the final page.
View: Handles user requests, retrieves data from the models, and sends it to the appropriate template.
2. Batteries Included
Django is often described as a "batteries-included" framework because it comes with a rich set of built-in features 
that save developers from writing common tasks from scratch. These include:
Authentication system (user login, registration, password management).
Admin interface (an auto-generated, customizable web-based interface for managing application data).
URL routing (mapping URLs to views).
Form handling and validation.
Database ORM (Object-Relational Mapping) for interacting with relational databases (e.g., PostgreSQL, MySQL, SQLite).
Security features (protection against cross-site scripting, cross-site request forgery, SQL injection, etc.).
Internationalization and localization (support for multiple languages and time zones).
3. Scalability and Flexibility
Django is scalable, making it suitable for both small applications and large-scale projects. It encourages modularity 
and reusability, meaning that different parts of the application can be reused and scaled independently.
Django’s flexibility enables it to be used for different types of applications, from simple content management systems 
(CMS) to complex e-commerce platforms or social networks.
4. Security
Django includes built-in security features, such as:
Cross-Site Request Forgery (CSRF) protection.
SQL injection protection via ORM.
Cross-Site Scripting (XSS) protection.
Clickjacking protection.
Password hashing and secure cookie handling.
5. Database Abstraction Layer
Django comes with an Object-Relational Mapping (ORM) system, which allows developers to interact with the database using 
Python objects rather than SQL. This simplifies database operations and supports multiple database backends (PostgreSQL, 
MySQL, SQLite, etc.).
6. Admin Interface
Django automatically generates an admin interface for models that can be customized for the management of application 
data. This is a powerful feature that allows developers to quickly manage content without having to build a custom admin 
panel from scratch.
7. URL Routing
Django’s URL routing system is flexible and uses a URL dispatcher to map URLs to views. It allows developers to define 
clear, user-friendly URLs that are easy to navigate and maintain.
8. Development Speed
One of Django's main selling points is its ability to significantly speed up the development process. With the built-in 
tools, pre-configured components, and high-level abstractions, developers can focus on business logic rather than 
repetitive tasks.
9. Testing Framework
Django comes with a built-in testing framework that helps developers ensure the reliability of their code. The testing 
tools support unit tests, integration tests, and functional tests.
10. Community and Documentation
Django has a large, active community of developers, which makes it easy to find help, tutorials, and third-party packages. The official documentation is thorough, well-organized, and constantly updated, making it an excellent resource for developers.
Common Use Cases for Django:
Content Management Systems (CMS): Django is often used to build powerful CMS platforms.
E-commerce Websites: With its built-in admin and user management systems, Django is ideal for developing e-commerce sites.
Social Networks and Forums: Django’s scalability and built-in features make it a good choice for social media platforms.
Data-Driven Websites: Django is often used to develop applications that rely on complex database interactions, such as 
data analytics and reporting tools.
Key Advantages of Django:
Rapid development: Tools and features that speed up the development process.
Security: Built-in features protect against common security threats.
Scalability: Suitable for both small and large-scale applications.
Reusability: Encourages reusable components and modular design.
Key Disadvantages:
Monolithic structure: Django's large set of features can make it feel heavy for smaller, simpler applications.
Learning curve: Django can be difficult for beginners, especially those who are new to web development or Python.
Opinionated: While Django is highly configurable, its approach to certain tasks (e.g., templating and ORM) may not be 
suitable for all types of applications or development styles.

 Advantages of Django (e.g., scalability, security).

Django is a high-level Python web framework that is widely used for building web applications. It offers several 
advantages, which make it an attractive choice for developers:

1. Scalability
Efficient Handling of High Traffic: Django is designed to be scalable, meaning it can handle a large number of users and 
requests without significant performance loss. This is achieved through its support for caching, load balancing, and 
the use of a database-agnostic ORM.
Modular Design: Django’s modular nature allows developers to break down the application into smaller, reusable components, 
which can be scaled independently as demand grows.
2. Security
Built-in Protection: Django comes with several built-in security features to help developers protect applications against 
common security threats. These include:
SQL Injection Protection: Django ORM automatically escapes queries to prevent SQL injection attacks.
Cross-Site Scripting (XSS) Protection: It ensures that templates automatically escape data to prevent malicious scripts 
from being injected into the webpage.
Cross-Site Request Forgery (CSRF) Protection: Django has CSRF tokens built into forms to prevent unauthorized commands 
from being executed.
Clickjacking Protection: It comes with middleware to prevent clickjacking attacks.
User Authentication: Django provides a built-in authentication system, including user login, registration, and session 
management.
3. Rapid Development
Batteries-Included: Django follows the "batteries-included" philosophy, providing a wide range of built-in features, 
such as an admin interface, authentication system, forms, URL routing, and templating engine. This reduces development 
time significantly.
Admin Interface: Django automatically generates an admin panel for managing application data, which is customizable 
and easy to use.
Predefined Tools: It comes with built-in tools like Django Rest Framework (for API development), which accelerates 
development for web and mobile applications.
4. Maintainability
Clean and Readable Code: Django enforces a clean and readable code structure using the Model-View-Template (MVT) 
architecture, making it easier to maintain and extend over time.
Reusability: Django promotes the reuse of components, reducing duplication of code and promoting modular development 
practices.
5. Extensive Documentation and Community Support
Comprehensive Documentation: Django has detailed, up-to-date documentation, making it easier for developers to get started and solve issues.
Active Community: With a large community of developers, there are plenty of resources, tutorials, plugins, and third-party libraries available. This active community ensures quick resolution of issues and continuous improvement of the framework.
6. Flexibility
Database Flexibility: Django supports multiple relational databases (like PostgreSQL, MySQL, SQLite, and Oracle), and it 
allows easy switching between databases.
Customizability: Although Django follows conventions, it is also highly customizable. Developers can extend or override 
its components to suit their specific needs.
7. Reusability and DRY Principle
Don’t Repeat Yourself (DRY): Django emphasizes reusability of components and avoiding duplication of code. This leads to 
cleaner, more maintainable code and faster development cycles.
8. Versatile Use Cases
Django is suitable for a wide range of applications, including content management systems (CMS), social networking sites, 
e-commerce platforms, and scientific applications. It is versatile enough to handle simple websites to complex 
data-driven applications.
9. Testing Support
Automated Testing: Django includes a testing framework that supports unit testing, making it easier to write and run tests. This helps ensure that applications remain bug-free and meet requirements as they evolve.
10. Internationalization and Localization
Multilingual Support: Django has built-in support for internationalization (i18n) and localization (l10n), making it easy 
to develop applications that support multiple languages and time zones.
11. Performance
Efficient ORM: Django’s Object-Relational Mapping (ORM) system allows developers to work with databases without writing 
raw SQL, while still offering highly optimized queries and performance.
12. Compatibility with Front-End Frameworks
Django can be easily integrated with modern front-end JavaScript frameworks like React, Vue.js, or Angular, allowing 
developers to create dynamic, single-page applications (SPAs) in conjunction with Django's powerful back-end capabilities.

 Django vs. Flask comparison: Which to choose and why.

Django and Flask are two of the most popular web frameworks for Python, each with its own strengths and use cases. 
Choosing between them depends on the specific requirements of your project, the scale of the application, and your 
development preferences. Below is a detailed comparison of Django vs. Flask to help guide your decision:

1. Overview:
Django:

A high-level, full-stack web framework.
Comes with a lot of built-in functionality like authentication, form handling, and ORM (Object-Relational Mapping) out 
of the box.
Follows the "batteries-included" philosophy, meaning it provides everything you need to build a web application, 
including an admin interface, templating engine, and security features.
Flask:

A lightweight, minimalistic web framework.
Provides the core functionality needed to build a web application, but leaves the rest (like form handling, ORM, and 
authentication) up to the developer.
Known for being flexible and allowing developers to add only the components they need, making it a good option for 
smaller, simpler applications or for microservices.
2. Ease of Use:
Django:
Learning Curve: Slightly steeper, due to the vast array of built-in features and its opinionated structure.
Documentation: Excellent documentation with many tutorials, as it's one of the most established Python frameworks.
Ideal for developers who prefer a "convention over configuration" approach, where many decisions are made for you.
Flask:
Learning Curve: Easier for beginners, thanks to its simplicity and small codebase.
Documentation: Also well-documented, though it leaves more to the developer in terms of choices for building components.
Ideal for developers who prefer to have complete control over the app structure and decide which tools or libraries to use.
3. Project Type:
Django:

Best for larger applications that require built-in features like an admin panel, user authentication, and a 
database layer.
Great for projects that need scalability, robust security, and quick development.
Examples: Social media platforms, content management systems, e-commerce platforms, and large-scale enterprise 
applications.
Flask:

Best for smaller applications or when you need a lightweight framework with fewer restrictions.
Ideal for microservices or applications where you need complete control over which components to use.
Examples: APIs, small web apps, prototypes, and single-page applications (SPAs).
4. Performance:
Django:
Has more built-in features, so it can be slightly slower due to its larger footprint.
Suitable for most web applications, though its performance may degrade as the project grows very large unless carefully 
optimized.
Flask:
Lightweight and more performant for small to medium-sized applications, as it does not include unnecessary features.
Can handle high loads in specific use cases where you can optimize and scale efficiently.
5. Features:
Django:

Built-in admin interface for managing app content.
ORM (Object-Relational Mapping) for working with databases.
Built-in authentication, user management, and security features (e.g., protection against SQL injection, cross-site 
scripting, and CSRF).
Scalable architecture with support for different databases (MySQL, PostgreSQL, SQLite, etc.).
Great for rapid development due to built-in features and conventions.
Flask:

Minimalistic, so it does not include ORM, authentication, or an admin interface by default.
Highly extensible with many available plugins, allowing you to choose libraries like SQLAlchemy (ORM), Flask-Login 
(authentication), and Flask-Admin (admin interface).
Flexibility allows for a custom architecture, but you need to integrate these components yourself.
6. Community and Ecosystem:
Django:
Django has been around longer and has a larger community with a wealth of third-party libraries and resources.
Popular in enterprise-level applications, so it’s well-tested and proven in production environments.
Flask:
Flask has a growing community, though it’s smaller than Django’s.
More popular for smaller, innovative projects or microservices.
Its extensibility makes it highly customizable, but it may require more effort to integrate various components.
7. Flexibility:
Django:

Opinionated framework, meaning it has a preferred way to do things.
Great for developers who want to follow best practices and stick to conventions.
Less flexible when it comes to altering core components, which can be a benefit or a limitation depending on your project.
Flask:

Highly flexible, giving you control over how the application is structured and which components to use.
Ideal for developers who want to experiment with different libraries or build custom solutions from the ground up.
8. Scalability:
Django:
Highly scalable, especially for large-scale applications that require modularity and easy maintenance.
Well-suited for teams working on large projects because it has built-in patterns for scaling.
Flask:
Scalable, but may require more custom architecture design for larger applications.
Often used for smaller apps or microservices, which can be scaled horizontally as needed (e.g., by splitting up the app 
into smaller services).
9. When to Choose Django:
You need to quickly build a large, feature-rich web application.
Your app requires built-in authentication, an admin panel, or complex database interactions.
You prefer a full-stack framework that handles most tasks for you.
Your project needs long-term scalability and maintainability with standard patterns.
10. When to Choose Flask:
You are building a small, simple web application or API.
You want complete control over the tools and components you use.
You are working on a microservice or need flexibility in how you structure your app.
You prefer a lightweight, minimalist approach.
Conclusion:
Choose Django if you're building a large-scale application with many built-in requirements (like an admin panel, 
user authentication, or complex data models) and prefer an "all-in-one" solution.
Choose Flask if you're working on a small, simple app or need flexibility to customize the app from the ground up. 
It's also ideal for microservices or cases where you want to handpick components.

Lab:
 Write a short project using Django’s built-in tools to render a simple webpage.

Here's a simple project using Django's built-in tools to render a webpage. This example will show how to create a basic 
Django project that renders a webpage with a greeting message.

Step 1: Install Django
First, ensure that Django is installed. If you haven't already, you can install it via pip:

bash
pip install django
Step 2: Create a Django Project
Create a new directory for your project and navigate into it:

bash
mkdir simple_django_project
cd simple_django_project
Create the Django project using the django-admin command:

bash
django-admin startproject myproject
cd myproject
Step 3: Create a Django App
Now, create a Django app where we will define the view to render the webpage.

bash
python manage.py startapp myapp
Step 4: Define a View
In the myapp folder, open views.py and define a simple view that renders an HTML template.

python
# myapp/views.py

from django.shortcuts import render

def home(request):
    return render(request, 'home.html', {'message': 'Hello, Welcome to my simple Django website!'})
Step 5: Set Up the Template
Create a new folder called templates inside the myapp folder, and then create the home.html template inside it.

bash
mkdir myapp/templates
touch myapp/templates/home.html
Edit the home.html template with basic HTML:

html
<!-- myapp/templates/home.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Welcome</title>
</head>
<body>
    <h1>{{ message }}</h1>
</body>
</html>
Step 6: Set Up URLs
You need to create a URL pattern for the home view. In the myapp folder, create a urls.py file if it doesn’t exist 
already, and define the URL pattern:

python
# myapp/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
]
Then, in the myproject/urls.py, include myapp.urls:

python
# myproject/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('myapp.urls')),
]
Step 7: Run the Development Server
Now that everything is set up, you can run the Django development server:

bash
python manage.py runserver
Step 8: View the Webpage
Open your browser and navigate to http://127.0.0.1:8000/. You should see a simple webpage displaying the greeting 
message:

css
Hello, Welcome to my simple Django website!

Practical Example: 4) Write a Python program to create a Django project and understand its directory structure.

To create a Django project and understand its directory structure, follow the steps below. I'll guide you through setting 
up a Django project and explain the directory structure as we go.

Step 1: Install Django
Before starting a Django project, you need to have Python and Django installed. If you haven't already, install Django 
using pip:

bash
pip install django
Step 2: Create a New Django Project
Once Django is installed, create a new Django project by running the following command in your terminal:

bash
django-admin startproject myproject
This command creates a new directory called myproject containing the default Django project structure.

Step 3: Explore the Django Project Directory Structure
After running the command, your project directory will look like this:

bash
myproject/
├── manage.py
└── myproject/
    ├── __init__.py
    ├── settings.py
    ├── urls.py
    ├── asgi.py
    └── wsgi.py
Explanation of the Directory Structure:
Outer myproject/ (project directory):

manage.py: This is a command-line utility that helps you interact with your Django project. It allows you to run 
the server, migrate the database, and perform other management tasks.
Inner myproject/ (project settings directory):

__init__.py: This is an empty file that tells Python that this directory should be considered a package.
settings.py: Contains the settings/configuration for the Django project. Here, you configure databases, static files, 
installed apps, middleware, etc.
urls.py: Defines the URL patterns for the project. This file maps URLs to views.
asgi.py: The entry point for ASGI-compatible web servers to serve your project. ASGI is used for handling WebSockets and 
asynchronous operations.
wsgi.py: The entry point for WSGI-compatible web servers to serve your project. It’s the traditional method for 
deploying Django in a synchronous environment.
Step 4: Running the Django Development Server
To verify your Django project is working, navigate to the outer myproject directory (where manage.py is located) and run 
the following command:

bash
python manage.py runserver
This will start a development server. If you open your browser and visit http://127.0.0.1:8000/, you should see the 
Django welcome page confirming that the server is running.

Step 5: Creating a Django App
A Django project can contain multiple apps. To create an app inside the project, run the following command:

bash
python manage.py startapp myapp
This will create a new directory called myapp with the following structure:

bash
myapp/
├── __init__.py
├── admin.py
├── apps.py
├── models.py
├── tests.py
└── views.py
Explanation of the App Directory:
__init__.py: Marks the directory as a Python package.
admin.py: Register models to be accessible through the Django admin interface.
apps.py: Contains configuration for the app. It includes the app's name and any settings related to it.
models.py: Define database models (tables) here.
tests.py: Write unit tests for your app here.
views.py: Define functions or classes that handle HTTP requests and return HTTP responses.
Step 6: Connecting the App to the Project
After creating an app, you need to include it in your project. To do this, follow these steps:

Open the settings.py file inside the myproject/ directory.
Find the INSTALLED_APPS list.
Add 'myapp' to the list of installed apps like this:
python
INSTALLED_APPS = [
    'myapp',  # Add this line
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
Step 7: Running the Development Server Again
Now that you've created an app and included it in your settings, you can continue developing your Django project. 
Start the server again with:

bash
python manage.py runserver
Step 8: Additional Features
You can continue building out your Django project by creating models, views, templates, and handling URL routing. 
For example:

Create a model: Define models in myapp/models.py.
Create views: Define views in myapp/views.py.
Add URL patterns: Define routes in myproject/urls.py or in the app’s own urls.py.

5. Virtual Environment
Theory:
 Understanding the importance of a virtual environment in Python projects.

A virtual environment in Python is crucial for managing dependencies and ensuring that projects are isolated and 
reproducible. Here’s why it’s important:

1. Dependency Management:
Isolation: Each Python project may have different versions of libraries or packages that could potentially conflict 
with one another. A virtual environment creates an isolated space where the dependencies of one project won’t affect 
others. This ensures that different projects can use different versions of libraries without causing compatibility issues.
Consistency: When you create a virtual environment, it contains its own set of libraries and dependencies. 
This helps in ensuring that the environment is consistent across different development setups and machines. Other 
developers working on the project can recreate the exact environment by using the requirements.txt file, which lists 
all the dependencies.
2. Preventing Global Installation Issues:
Without a virtual environment, installing libraries globally might lead to version conflicts or even overwriting 
important system-wide packages, especially when multiple projects depend on different versions of the same library.
Virtual environments avoid this risk by keeping the packages specific to the project.
3. Ease of Reproducibility:
If you need to share your code with other developers or deploy it, using a virtual environment ensures that everyone 
works with the exact same set of dependencies. By freezing the environment (pip freeze > requirements.txt), you can 
recreate the exact setup by installing those packages later on another machine (pip install -r requirements.txt).
4. Simplified Project Management:
Virtual environments allow you to manage dependencies per project, ensuring that you're not mixing the libraries of one 
project with another. For example, a machine learning project might need numpy and pandas, while a web development 
project might require flask or django. By using virtual environments, each project can have its own set of requirements.
5. Security:
By isolating the project dependencies, you can more easily control the specific versions and patches you are using. 
This reduces the risk of using outdated or vulnerable versions of libraries across different projects.
6. Avoiding Permission Issues:
Installing packages globally might require administrative privileges on some systems. Virtual environments allow you to 
install and manage libraries without needing root or admin access.
7. Cleaner Codebase:
By keeping all dependencies in the virtual environment folder (often located inside the project directory), it’s easy to 
track and update project dependencies. This also keeps the global Python environment clean and uncluttered.
How to Use a Virtual Environment in Python:
Create a Virtual Environment:

bash
python3 -m venv myenv
Activate the Virtual Environment:

On Windows:
bash
myenv\Scripts\activate
On macOS/Linux:
bash
source myenv/bin/activate
Install Dependencies: After activating the virtual environment, you can install required libraries:

bash
pip install <library-name>
Freeze Dependencies: To capture the dependencies in a requirements.txt file:

bash
pip freeze > requirements.txt
Deactivate the Virtual Environment: When you're done working, you can deactivate the virtual environment:

bash
deactivate

 Using venv or virtualenv to create isolated environments.

Using venv or virtualenv to create isolated Python environments is a great way to manage project dependencies without 
affecting system-wide Python packages. Here’s how to use both tools:

1. Using venv (built-in Python tool)
The venv module is included by default with Python 3.3 and newer versions. It allows you to create isolated environments.

Steps:
Create a Virtual Environment: In your project directory, open the terminal or command prompt and run:

bash
python -m venv myenv
This creates a directory named myenv with an isolated Python environment.

Activate the Virtual Environment:

On Windows:
bash
myenv\Scripts\activate
On macOS/Linux:
bash
source myenv/bin/activate
Once activated, your prompt will change, showing the name of the environment (e.g., (myenv)).

Install Packages: Now you can install packages inside the virtual environment using pip:

bash
pip install <package-name>
Deactivate the Virtual Environment: To deactivate the environment and return to your system’s Python, run:

bash
deactivate
Delete the Virtual Environment: You can safely remove the virtual environment by deleting the myenv directory:

bash
rm -rf myenv
2. Using virtualenv (third-party tool)
virtualenv is an external tool that works similarly to venv but has been around longer and offers additional features. 
It can be installed with pip.

Steps:
Install virtualenv: First, install the virtualenv tool globally using pip:

bash
pip install virtualenv
Create a Virtual Environment: In your project directory, run:

bash
virtualenv myenv
This will create a directory named myenv containing the isolated environment.

Activate the Virtual Environment: The activation steps are the same as with venv:

On Windows:
bash
myenv\Scripts\activate
On macOS/Linux:
bash
source myenv/bin/activate
Install Packages: Use pip to install packages as usual:

bash
pip install <package-name>
Deactivate the Virtual Environment: To deactivate the virtual environment, run:

bash
deactivate
Delete the Virtual Environment: You can delete the virtual environment by removing the myenv directory:

bash
rm -rf myenv
Comparison of venv and virtualenv:
venv: Built into Python 3.3+ and provides basic isolation features.
virtualenv: An older, third-party tool that works on both Python 2 and Python 3 and can be used for more advanced 
virtual environment management.
Advantages of Using Virtual Environments:
Dependency Management: You can install specific package versions per project, avoiding conflicts with other projects.
Clean Environment: Keeps global Python installations free from extra packages.
Reproducibility: With requirements.txt, you can recreate the environment easily across systems.
Additional Tip:
You can generate a requirements.txt file that lists all installed packages:

bash
pip freeze > requirements.txt
To install dependencies from the requirements.txt file:

bash
pip install -r requirements.txt
Both venv and virtualenv are great choices for maintaining isolated environments, and the choice between them depends 
on your specific needs. If you're using Python 3.3 or higher, venv is a good built-in option. If you need features 
beyond what venv offers, or if you’re working with Python 2, virtualenv is a powerful alternative.

Lab:
 Set up a virtual environment for a Django project.

To set up a virtual environment for a Django project, follow these steps:

Step 1: Install Python
Make sure you have Python installed on your machine. You can check if Python is installed and verify the version with:

bash
python --version
If Python isn't installed, download it from the official Python website.

Step 2: Install pip (if not installed)
pip is the package manager for Python. You can check if pip is installed by running:

bash
pip --version
If pip is not installed, follow the instructions from the official pip installation guide.

Step 3: Install virtualenv
virtualenv is a tool to create isolated Python environments. Install it using pip:

bash
pip install virtualenv
Step 4: Create a Project Directory
Create a folder for your Django project and navigate to it:

bash
mkdir my_django_project
cd my_django_project
Step 5: Set Up a Virtual Environment
Create a virtual environment inside the project folder:

bash
virtualenv venv
This will create a new folder named venv in your project directory that contains the virtual environment.

Step 6: Activate the Virtual Environment
On Windows:

bash
venv\Scripts\activate
On macOS/Linux:

bash
source venv/bin/activate
After activation, your terminal prompt should change to show the virtual environment name (e.g., (venv)).

Step 7: Install Django
With the virtual environment active, install Django using pip:

bash
pip install django
Step 8: Verify Django Installation
To verify that Django was installed correctly, run:

bash
django-admin --version
Step 9: Create a Django Project
Once Django is installed, you can create a new Django project:

bash
django-admin startproject mysite
This will create a new directory mysite with the default Django project structure.

Step 10: Run the Development Server
Navigate into your new Django project directory:

bash
cd mysite
Run the development server to check if everything is working:

bash
python manage.py runserver
You should see output indicating the server is running at http://127.0.0.1:8000/. Open this URL in your browser to see 
the Django welcome page.

Step 11: Deactivate the Virtual Environment
When you're done working, deactivate the virtual environment by typing:

bash
deactivate

Practical Example: 5) Write a Python program to create and activate a virtual environment, then install Django in it.

To create and activate a virtual environment, and then install Django within it, you can follow these steps in Python:

1. Install virtualenv (if not already installed)
First, ensure you have the virtualenv package installed on your system. 
You can install it using pip (Python's package manager):

bash
pip install virtualenv
2. Create a Virtual Environment
Now, let's create a virtual environment in the desired directory. Replace myenv with the name you want for your 
environment.

bash
virtualenv myenv
3. Activate the Virtual Environment
On Windows:
bash
myenv\Scripts\activate
On macOS/Linux:
bash
source myenv/bin/activate
After activation, you should see the environment name (myenv) in the terminal prompt, indicating that the virtual 
environment is active.

4. Install Django
With the virtual environment activated, use pip to install Django.

bash
pip install django
This will install the latest version of Django in your virtual environment.

Full Example in a Python Script:
If you want a Python script to automate these steps (though note that activating a virtual environment typically needs 
to be done in a terminal or shell):

python
import os
import subprocess
import sys

# Step 1: Check if virtualenv is installed, if not, install it
def install_virtualenv():
    subprocess.check_call([sys.executable, "-m", "pip", "install", "virtualenv"])

# Step 2: Create a virtual environment
def create_virtualenv(env_name="myenv"):
    subprocess.check_call([sys.executable, "-m", "virtualenv", env_name])

# Step 3: Activate the virtual environment (requires manual activation in shell)
def activate_virtualenv(env_name="myenv"):
    if os.name == 'nt':  # For Windows
        activate_script = os.path.join(env_name, 'Scripts', 'activate')
    else:  # For macOS/Linux
        activate_script = os.path.join(env_name, 'bin', 'activate')
    
    # Printing out the command to activate manually (since this can't be done in Python)
    print(f"To activate the virtual environment, run the following command in your terminal:")
    print(f"source {activate_script}" if os.name != 'nt' else f"{activate_script}")

# Step 4: Install Django in the virtual environment
def install_django():
    subprocess.check_call([sys.executable, "-m", "pip", "install", "django"])

# Main function to run the steps
def main():
    install_virtualenv()
    create_virtualenv("myenv")
    install_django()
    activate_virtualenv("myenv")

if __name__ == "__main__":
    main()
Important Notes:
Activating the Environment: The Python script can't directly activate the virtual environment in the current shell, 
since activate modifies the shell's environment. You need to manually activate it by running the printed command in your 
terminal.
Using subprocess: The script uses subprocess.check_call to run terminal commands from Python.
After Activation:
Once activated, you can confirm Django is installed by running:

bash
django-admin --version
This will display the installed version of Django, confirming it's set up correctly.

6. Project and App Creation
Theory:
 Steps to create a Django project and individual apps within the project.

To create a Django project and individual apps within the project, follow these steps:

1. Install Django
First, ensure that Django is installed on your system. You can install it using pip (Python's package manager).

bash
pip install django
2. Create a Django Project
A Django project is a collection of settings, configurations, and apps.

To create a new Django project, run the following command in your terminal or command prompt:
bash
django-admin startproject projectname
Replace projectname with the desired name for your project.
After running the above command, you’ll see the following directory structure:

markdown
projectname/
    manage.py
    projectname/
        __init__.py
        settings.py
        urls.py
        wsgi.py
manage.py: A command-line utility that helps with various tasks (starting the server, making migrations, etc.).
projectname/: The inner directory contains configuration files for your Django project (settings, URLs, etc.).
3. Run the Development Server
To check if everything is set up correctly, run the Django development server.

bash
cd projectname
python manage.py runserver
This will start the development server, and you can visit http://127.0.0.1:8000/ in your browser to see the Django 
welcome page.

4. Create Django Apps
In Django, an app is a module that handles a specific functionality, like a blog, a forum, etc.

To create an app within your project, run:

bash
python manage.py startapp appname
Replace appname with the name of your app (e.g., blog, users, etc.).
This creates a new directory called appname/ with the following structure:

markdown
appname/
    __init__.py
    admin.py
    apps.py
    models.py
    tests.py
    views.py
Each file serves a specific purpose:

models.py: Defines the database models.
views.py: Contains the views for handling user requests.
admin.py: Configures how models appear in the admin interface.
tests.py: Contains unit tests for your app.
apps.py: Configuration for the app itself.
5. Register the App in the Project Settings
Once an app is created, you need to tell Django about it by adding the app to the INSTALLED_APPS setting in your 
settings.py file.

Open the projectname/settings.py file and find the INSTALLED_APPS list. Add your app to this list:

python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'appname',  # Add this line with your app's name
]
6. Create Models (Optional)
In models.py of your app, you can define database models. For example:

python
# appname/models.py
from django.db import models

class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    published_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return self.title
7. Create Database Migrations
If you added models to your app, you need to create and apply database migrations to create the corresponding tables in 
the database.

Run the following commands:

bash
python manage.py makemigrations
python manage.py migrate
8. Create Views
In views.py, you can create views to handle HTTP requests. For example:

python
# appname/views.py
from django.shortcuts import render
from .models import Post

def post_list(request):
    posts = Post.objects.all()
    return render(request, 'post_list.html', {'posts': posts})
9. Create URLs for the App
Create a file called urls.py inside your app directory (appname/urls.py). Here you’ll define the URL patterns for your 
app.

python
# appname/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.post_list, name='post_list'),
]
10. Include App URLs in Project's URL Configuration
In the project's main urls.py (projectname/urls.py), include the URLs of your app:

python
# projectname/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('posts/', include('appname.urls')),  # Include app URLs
]
11. Create Templates (Optional)
Django uses templates to render HTML pages. You can create a templates folder inside your app directory and add HTML 
files there.

For example:

markdown
appname/
    templates/
        post_list.html
In post_list.html, you can define your HTML structure:

html
<!-- appname/templates/post_list.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Post List</title>
</head>
<body>
    <h1>Post List</h1>
    <ul>
        {% for post in posts %}
            <li>{{ post.title }} - {{ post.published_at }}</li>
        {% endfor %}
    </ul>
</body>
</html>
12. Run the Server Again
Once everything is set up, start the server again:

bash
python manage.py runserver
You can now visit http://127.0.0.1:8000/posts/ to see your app in action.

Summary of the Commands:
Install Django: pip install django
Create a project: django-admin startproject projectname
Create an app: python manage.py startapp appname
Run server: python manage.py runserver
Create and apply migrations: python manage.py makemigrations and python manage.py migrate
Create views, URLs, templates, and models as needed.

 Understanding the role of manage.py, urls.py, and views.py.

In a Django web application, the manage.py, urls.py, and views.py files play crucial roles in organizing and managing 
the application's functionality. Here's an overview of each:

1. manage.py:
Purpose: This file is a command-line utility that helps manage your Django project. It's used to interact with the 
Django framework, perform tasks, and manage the development server, migrations, and more.
Key Functions:
Running the development server: You can use python manage.py runserver to start the server and test your project.
Database migrations: With python manage.py migrate, it applies any changes made to the database models.
Creating apps: python manage.py startapp <app_name> creates a new Django app within your project.
Creating models, views, and more: Django provides other commands like makemigrations, createsuperuser, test, and others 
through this file.
2. urls.py:
Purpose: The urls.py file is used to define the URL routing for your Django project. It maps a given URL to a specific 
view that should be executed when the URL is requested by a user.
Key Functions:
URL patterns: You define URL patterns (routes) that map URLs to views. For example, you might have a route like 
path('home/', views.home) to map the URL /home/ to the home view in the views.py file.
URL configuration: This file defines the URL structure for the entire project. It can also include other urls.py files 
from individual apps if you structure the project into multiple apps.
Example:
python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.index, name='index'),
    path('about/', views.about, name='about'),
]
3. views.py:
Purpose: The views.py file defines the logic for handling requests from the user and returning responses. A view is a 
Python function or class that receives web requests and returns web responses, typically as HTML or other content.
Key Functions:
Request handling: Each view function receives a request object (like a GET or POST request), processes it 
(e.g., querying a database), and returns a response (usually rendered HTML).
Rendering templates: Views often render HTML templates, passing data to them and generating dynamic content for the user.
Example:
python
from django.shortcuts import render

def index(request):
    return render(request, 'index.html', {'message': 'Hello, World!'})

def about(request):
    return render(request, 'about.html')
How they work together:
The process begins with a request: When a user visits a URL in the browser, Django looks up the corresponding URL 
pattern in the urls.py.

The URL is routed to a view: Based on the URL pattern, Django calls the corresponding function in views.py.

The view handles the request: The view processes the request, possibly interacting with the database, and then renders a 
response, often using HTML templates.

The response is returned to the user: Django sends the response (e.g., HTML, JSON, etc.) back to the user's browser.

manage.py: While it isn't directly involved in handling requests, manage.py is the entry point for managing the project 
as a whole, such as running the server or applying migrations.

Lab:
 Create a Django project with an app to manage doctor profiles.

To create a Django project with an app to manage doctor profiles, follow these steps:

Step 1: Install Django
If you haven't already, install Django using pip:

bash
pip install django
Step 2: Create a Django Project
Once Django is installed, create a new project. In your terminal or command prompt, run the following:

bash
django-admin startproject doctor_profiles_project
cd doctor_profiles_project
Step 3: Create a Django App for Managing Doctor Profiles
Create an app inside the project where doctor profiles will be managed. Run:

bash
python manage.py startapp doctor_profiles
This will create a folder called doctor_profiles with the basic app structure.

Step 4: Configure the App in Settings
Now, open the doctor_profiles_project/settings.py file and add the doctor_profiles app to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    ...
    'doctor_profiles',
]
Step 5: Create the Doctor Model
Now, define a model to store doctor profile information in the doctor_profiles/models.py file. Here’s an example of 
how you can define the model:

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()
    years_of_experience = models.IntegerField()
    biography = models.TextField()
    profile_picture = models.ImageField(upload_to='doctor_profiles/', null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.first_name} {self.last_name} - {self.specialty}"
Step 6: Make Migrations
To apply the model to the database, run the following commands:

bash
python manage.py makemigrations
python manage.py migrate
Step 7: Create Forms for the Doctor Profile
Next, create a form to handle doctor profile creation and editing. In doctor_profiles/forms.py, define a form like this:

python
from django import forms
from .models import Doctor

class DoctorForm(forms.ModelForm):
    class Meta:
        model = Doctor
        fields = ['first_name', 'last_name', 'specialty', 'phone_number', 'email', 
                  'years_of_experience', 'biography', 'profile_picture']
Step 8: Create Views for Managing Profiles
In doctor_profiles/views.py, create views to handle displaying and adding doctor profiles:

python
from django.shortcuts import render, redirect
from .models import Doctor
from .forms import DoctorForm

# View to list all doctors
def doctor_list(request):
    doctors = Doctor.objects.all()
    return render(request, 'doctor_profiles/doctor_list.html', {'doctors': doctors})

# View to create a new doctor profile
def doctor_create(request):
    if request.method == 'POST':
        form = DoctorForm(request.POST, request.FILES)
        if form.is_valid():
            form.save()
            return redirect('doctor_list')
    else:
        form = DoctorForm()
    return render(request, 'doctor_profiles/doctor_form.html', {'form': form})

# View to edit an existing doctor profile
def doctor_edit(request, pk):
    doctor = Doctor.objects.get(pk=pk)
    if request.method == 'POST':
        form = DoctorForm(request.POST, request.FILES, instance=doctor)
        if form.is_valid():
            form.save()
            return redirect('doctor_list')
    else:
        form = DoctorForm(instance=doctor)
    return render(request, 'doctor_profiles/doctor_form.html', {'form': form})
Step 9: Create URLs for the Views
In doctor_profiles/urls.py, set up the URLs to map to your views:

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.doctor_list, name='doctor_list'),
    path('create/', views.doctor_create, name='doctor_create'),
    path('edit/<int:pk>/', views.doctor_edit, name='doctor_edit'),
]
Then, include these URLs in the main project's urls.py:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('doctors/', include('doctor_profiles.urls')),
]
Step 10: Create Templates for Views
Create the following templates in the doctor_profiles/templates/doctor_profiles/ directory:

doctor_list.html to list all doctors:
html
<!DOCTYPE html>
<html>
<head>
    <title>Doctor Profiles</title>
</head>
<body>
    <h1>Doctor Profiles</h1>
    <a href="{% url 'doctor_create' %}">Create New Profile</a>
    <ul>
        {% for doctor in doctors %}
            <li>
                {{ doctor.first_name }} {{ doctor.last_name }} - {{ doctor.specialty }}
                <a href="{% url 'doctor_edit' doctor.pk %}">Edit</a>
            </li>
        {% endfor %}
    </ul>
</body>
</html>
doctor_form.html to create/edit a doctor profile:
html
<!DOCTYPE html>
<html>
<head>
    <title>Doctor Form</title>
</head>
<body>
    <h1>{% if form.instance.pk %}Edit{% else %}Create{% endif %} Doctor Profile</h1>
    <form method="POST" enctype="multipart/form-data">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Submit</button>
    </form>
</body>
</html>
Step 11: Configure Media Files (Optional)
If you are handling image uploads for the doctor profiles, ensure that you configure your settings to handle media files. 
In settings.py, add the following lines:

python
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'
Then, modify the urls.py file to serve media files in development:

python
from django.conf import settings
from django.conf.urls.static import static

urlpatterns = [
    path('admin/', admin.site.urls),
    path('doctors/', include('doctor_profiles.urls')),
] + static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
Step 12: Run the Development Server
Finally, run the development server to test your project:

bash
python manage.py runserver
Visit http://127.0.0.1:8000/doctors/ to see the list of doctor profiles and manage them.

Practical Example: 6) Write a Python program to create a Django project and a new app within the project called doctor.

To create a Django project and a new app called doctor, follow these steps. I will also provide you with the Python 
program to automate this process.

Steps to Follow:
Install Django (if you don't have it already).
Create a new Django project.
Create a new app called doctor within the project.
Python Program:
The following Python program automates the process of creating a Django project and a new app within it called doctor.

python
import os
import subprocess

def create_django_project(project_name, app_name):
    # Step 1: Install Django (if it's not already installed)
    try:
        import django
        print("Django is already installed.")
    except ImportError:
        print("Django not found, installing...")
        subprocess.check_call([os.sys.executable, "-m", "pip", "install", "django"])
    
    # Step 2: Create the Django project
    print(f"Creating Django project: {project_name}")
    subprocess.run(['django-admin', 'startproject', project_name])

    # Step 3: Create the Django app within the project
    os.chdir(project_name)  # Navigate into the project directory
    print(f"Creating Django app: {app_name}")
    subprocess.run(['python', 'manage.py', 'startapp', app_name])

    # Step 4: Verify that the project and app have been created
    print(f"Project '{project_name}' and app '{app_name}' created successfully!")

# Specify the project and app names
project_name = 'myproject'
app_name = 'doctor'

# Call the function to create the Django project and app
create_django_project(project_name, app_name)
Explanation:
Install Django: The program checks if Django is installed. If it is not installed, it installs Django using pip.
Create Django Project: Using django-admin startproject, it creates a new Django project.
Create Django App: Using python manage.py startapp, it creates a new app called doctor within the project.
Directory Change: The program changes the working directory to the created project folder (myproject) before creating 
the app.
Usage:
Save this script in a file (e.g., create_django_project.py).
Run the script using Python:
bash
python create_django_project.py
This will automatically create a project named myproject and an app named doctor.
Result:
After running the script, you will see:

A myproject folder (the Django project).
A doctor folder inside the myproject directory (the Django app).
You can now navigate into the project directory and start working with Django:

bash
cd myproject
python manage.py runserver
This will start the development server, and you can visit http://127.0.0.1:8000/ to see your new Django project in action.

7. MVT Pattern Architecture
Theory:
 Django’s MVT (Model-View-Template) architecture and how it handles request-response cycles.

Django follows the MVT (Model-View-Template) architecture, which is a variation of the more commonly known MVC 
(Model-View-Controller) pattern. Here's how the MVT architecture works in Django and how it handles the request-response 
cycle:

1. Model:
Definition: The model represents the data layer and is responsible for interacting with the database. It defines the 
structure of the data (tables) and the logic to manipulate it.
Responsibilities:
Define the data schema (tables, fields).
Interact with the database (CRUD operations).
Handle data validation, and business logic.
Example: A Book model could represent a book in a library, with fields like title, author, published_date, etc.
2. View:
Definition: The view is responsible for processing user requests and returning an appropriate response. It acts as the 
controller in the MVC pattern. It takes the data from the model and passes it to the template for rendering.
Responsibilities:
Handle HTTP requests.
Fetch the data from the model based on the request.
Process the data (e.g., apply business logic, data manipulation).
Return the final response (usually rendered HTML) to the user, often by using a template.
Example: A view might handle a request to display a list of books in the library by querying the Book model and passing 
the result to the template.
3. Template:
Definition: The template is responsible for the presentation layer, rendering the HTML that the user sees in their browser.
Responsibilities:
Define the HTML structure of the page.
Embed Django template tags to dynamically insert data passed by the view.
Example: A template for displaying a list of books could loop through the list of books passed by the view and display 
each book’s title and author.
Request-Response Cycle in Django (How MVT Works Together)
User Sends a Request:

The user (client) sends an HTTP request to the Django server (e.g., by typing a URL in the browser).
URL Routing:

Django uses the urls.py file to match the incoming URL with a specific view function. This is Django's URL dispatcher, 
which maps the URL patterns to views.
View Logic:

Once a URL pattern is matched, the corresponding view is executed. The view may perform actions such as querying the model for data (e.g., getting records from the database).
The view then prepares the necessary context data (usually a dictionary) that will be passed to the template for rendering.
Template Rendering:

The view calls a template (HTML file), passing the context data. This template contains dynamic placeholders, written in 
Django's template language, that are filled with actual data.
The template engine processes this and generates an HTML response with the dynamic content.
Response:

The rendered HTML page is sent back to the user's browser as the HTTP response.
Browser Displays the Response:

The browser receives the HTML content and displays it to the user.
Summary of Request-Response Cycle in MVT:
Request: The user makes an HTTP request (e.g., visiting a URL).
View: The view processes the request, potentially interacting with the model and passing context data.
Template: The template is rendered with dynamic data, producing HTML output.
Response: The response is sent back to the browser.
In essence, Django’s MVT pattern separates concerns clearly between the data (model), user interface (template), and 
business logic (view), promoting maintainability and scalability of web applications.

Lab:
 Build a simple Django app showcasing how the MVT architecture works.

To create a simple Django app showcasing how the MVT (Model-View-Template) architecture works, let's break it down 
step by step. We will build a minimal app that displays a list of books.

Step 1: Install Django
First, ensure you have Python installed on your machine. Then, install Django using pip:

bash
pip install django
Step 2: Create a New Django Project
Create a new Django project by running the following command:

bash
django-admin startproject bookproject
cd bookproject
Step 3: Create a New Django App
Now, let's create an app where we can define our models, views, and templates. We'll call the app books.

bash
python manage.py startapp books
Step 4: Define the Model (Model - M)
In the books app, define a model in models.py to represent a book:

python
# books/models.py
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=100)
    published_date = models.DateField()

    def __str__(self):
        return self.title
Step 5: Register the Model in Admin (Optional)
For easy interaction with the model, register it in the admin interface by modifying books/admin.py:

python
# books/admin.py
from django.contrib import admin
from .models import Book

admin.site.register(Book)
Step 6: Configure the App in the Project
In the bookproject/settings.py, add 'books' to the INSTALLED_APPS list:

python
# bookproject/settings.py
INSTALLED_APPS = [
    # Other apps
    'books',
]
Step 7: Run Migrations
Now, we need to create the database tables for our model. Run the following commands:

bash
python manage.py makemigrations
python manage.py migrate
Step 8: Create a View (View - V)
In the books/views.py, create a view that fetches and displays all books from the database:

python
# books/views.py
from django.shortcuts import render
from .models import Book

def book_list(request):
    books = Book.objects.all()
    return render(request, 'books/book_list.html', {'books': books})
Step 9: Create a Template (Template - T)
Create a folder called templates inside the books directory. Inside the templates folder, create another folder called 
books. Inside this folder, create a file called book_list.html.

html
<!-- books/templates/books/book_list.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Book List</title>
</head>
<body>
    <h1>Book List</h1>
    <ul>
        {% for book in books %}
            <li><strong>{{ book.title }}</strong> by {{ book.author }} (Published on {{ book.published_date }})</li>
        {% endfor %}
    </ul>
</body>
</html>
Step 10: Configure URL Patterns
Now, define the URL for the view. In the books app, create a urls.py file:

python
Copy code
# books/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.book_list, name='book_list'),
]
Next, include the books app's URLs in the main urls.py of the project:

python
# bookproject/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('books/', include('books.urls')),
]
Step 11: Create Some Sample Data
To view some books in the admin interface, create a superuser:

bash
python manage.py createsuperuser
Then, start the development server:

bash
python manage.py runserver
Go to http://127.0.0.1:8000/admin/, log in with the superuser credentials, and add a few books through the 
admin interface.

Step 12: View the Book List
Now, visit http://127.0.0.1:8000/books/ to see the list of books displayed using the MVT architecture.

Recap of the MVT Flow:
Model (M): Book model represents the structure of the database.
View (V): book_list view fetches the books and passes them to the template.
Template (T): book_list.html is the HTML template that renders the book data.

Practical Example: 7) Write a Django project with models, views, and templates to display doctor information.

Below is a simple example of a Django project to display doctor information. The project will consist of models, views, 
and templates to show doctor data. The steps include setting up the Django project, defining the model, creating views 
to handle the data, and rendering it in templates.

1. Setup Django Project
First, create a new Django project and an app for doctors.

bash
django-admin startproject doctor_info
cd doctor_info
python manage.py startapp doctors
2. Define the Model (in doctors/models.py)
This model will store the information about doctors like name, specialty, contact number, and availability.

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()
    available = models.BooleanField(default=True)

    def __str__(self):
        return f'{self.first_name} {self.last_name} - {self.specialty}'
3. Register the Model (in doctors/admin.py)
To manage doctors through Django's admin interface, register the Doctor model.

python
from django.contrib import admin
from .models import Doctor

admin.site.register(Doctor)
4. Create Views (in doctors/views.py)
We will create a view to list all doctors and another view to show details of a specific doctor.

python
from django.shortcuts import render, get_object_or_404
from .models import Doctor

# List view of all doctors
def doctor_list(request):
    doctors = Doctor.objects.all()
    return render(request, 'doctors/doctor_list.html', {'doctors': doctors})

# Detail view of a specific doctor
def doctor_detail(request, doctor_id):
    doctor = get_object_or_404(Doctor, pk=doctor_id)
    return render(request, 'doctors/doctor_detail.html', {'doctor': doctor})
5. Create URLs (in doctors/urls.py)
Define URLs to access the views created above.

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.doctor_list, name='doctor_list'),
    path('<int:doctor_id>/', views.doctor_detail, name='doctor_detail'),
]
6. Include doctors URLs in the Project's urls.py
In doctor_info/urls.py, include the URLs for the doctors app.

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('doctors/', include('doctors.urls')),
]
7. Create Templates
Template for Doctor List (doctors/templates/doctors/doctor_list.html)
This template will display a list of all doctors.

html
<!DOCTYPE html>
<html>
<head>
    <title>Doctors List</title>
</head>
<body>
    <h1>Doctors List</h1>
    <ul>
        {% for doctor in doctors %}
            <li>
                <a href="{% url 'doctor_detail' doctor.id %}">{{ doctor.first_name }} {{ doctor.last_name }}</a> - 
                {{ doctor.specialty }}
            </li>
        {% endfor %}
    </ul>
</body>
</html>
Template for Doctor Detail (doctors/templates/doctors/doctor_detail.html)
This template will display details of a specific doctor.

html
<!DOCTYPE html>
<html>
<head>
    <title>{{ doctor.first_name }} {{ doctor.last_name }}</title>
</head>
<body>
    <h1>{{ doctor.first_name }} {{ doctor.last_name }}</h1>
    <p><strong>Specialty:</strong> {{ doctor.specialty }}</p>
    <p><strong>Phone Number:</strong> {{ doctor.phone_number }}</p>
    <p><strong>Email:</strong> {{ doctor.email }}</p>
    <p><strong>Available:</strong> {% if doctor.available %} Yes {% else %} No {% endif %}</p>
    <a href="{% url 'doctor_list' %}">Back to list</a>
</body>
</html>
8. Migrate the Database
Run the following commands to apply the migrations and create the database table for the Doctor model.

bash
python manage.py makemigrations
python manage.py migrate
9. Create Superuser for Admin (optional)
If you want to add doctors via the Django admin interface, create a superuser.

bash
python manage.py createsuperuser
10. Run the Development Server
Finally, run the Django development server to see your project in action.

bash
python manage.py runserver
Accessing the App
Go to /doctors/ to see the list of doctors.
Click on a doctor's name to see more details about them.
You can also access the admin interface at /admin/ if you have a superuser set up.
This is a basic example of a Django project to manage and display doctor information. You can enhance it by adding 
additional fields (like office hours), validation, or features such as doctor appointment scheduling or search 
functionality.

8. Django Admin Panel
Theory:
 Introduction to Django’s built-in admin panel.

Django's built-in Admin Panel is one of the most powerful features of the Django web framework. It provides an intuitive 
interface for administrators and developers to manage the database, create, edit, delete, and view records in the 
application's database. It is designed to be easy to use and is automatically generated based on the models defined in 
the Django application.

Key Features of Django Admin Panel
Automatic Interface Generation:

When you define models (database tables) in Django, the framework automatically generates a powerful, customizable admin 
interface for those models.
This eliminates the need to create a user interface for administrative tasks manually.
CRUD Operations:

The Django admin panel supports basic Create, Read, Update, and Delete (CRUD) operations for the models in your 
application.
It provides forms for adding and editing records and a table view for displaying the data.
User Management:

Django admin allows you to manage users, assign them permissions (e.g., read, write, delete), and define roles.
You can control which users have access to the admin panel and which parts of the data they can modify.
Customizable Interface:

The admin interface is highly customizable, allowing developers to change the way models are displayed, how data is 
presented, and how users interact with the data.
You can also create custom admin views, actions, filters, and search fields.
Search and Filtering:

You can add search fields to your models in the admin panel, making it easy to search for records.
Django provides built-in filtering and sorting options to make navigation easier for large datasets.
Inline Models:

If your application has relationships between models (e.g., ForeignKey, ManyToMany), you can display related models 
inline in the admin interface.
This allows admins to manage related data from a single page.
Steps to Enable Django Admin Panel
Install Django: First, you need to install Django if you haven't already done so:

bash
pip install django
Create a Django Project: Create a Django project if you don’t have one:

bash
django-admin startproject myproject
cd myproject
Create an App: Create an app within your project (e.g., myapp):

bash
python manage.py startapp myapp
Define Models: Define the models in your app's models.py file. For example:

python
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=100)
    published_date = models.DateField()

    def __str__(self):
        return self.title
Register Models with Admin Panel: To make the model available in the Django admin interface, register it in your 
app’s admin.py file:

python
from django.contrib import admin
from .models import Book

admin.site.register(Book)
Create Superuser: To access the admin panel, you need to create a superuser:

bash
python manage.py createsuperuser
Migrate Database: Run migrations to create the necessary database tables for your models:

bash
python manage.py migrate
Run the Server: Start the Django development server:

bash
python manage.py runserver
Access Admin Panel: Open your browser and go to http://127.0.0.1:8000/admin/. Log in with the superuser credentials 
you created earlier. You'll now see your registered models in the admin interface.

Customizing the Admin Interface
Django’s admin interface can be customized by creating a custom admin class. For example, to change the way the 
Book model is displayed in the admin panel, you can customize the ModelAdmin class:

python
from django.contrib import admin
from .models import Book

class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'published_date')  # Display these fields in the list view
    search_fields = ('title', 'author')  # Add search functionality

admin.site.register(Book, BookAdmin)

 Customizing the Django admin interface to manage database records.

Customizing the Django admin interface is a powerful way to make managing your database records more efficient and 
tailored to your needs. The Django admin provides a default interface, but you can customize it to improve functionality,
add more features, and make it more user-friendly.

Here are steps to customize the Django admin interface for managing database records:

1. Register Your Models with the Admin
First, you need to register your models in the admin.py file of your app. Here's how to register a model with the 
Django admin:

python
from django.contrib import admin
from .models import YourModel

admin.site.register(YourModel)
This will display a basic interface for managing YourModel in the admin.

2. Customizing the Admin Interface for a Model
To customize how a model is displayed and managed in the admin interface, you can create a custom admin class by 
subclassing admin.ModelAdmin.

For example, if you have a Book model and want to customize the admin interface, you could do something like this:

python
from django.contrib import admin
from .models import Book

class BookAdmin(admin.ModelAdmin):
    # Define which fields should be displayed in the list view
    list_display = ('title', 'author', 'publish_date')
    
    # Add search functionality to the admin
    search_fields = ('title', 'author')
    
    # Filter the list view by specific fields
    list_filter = ('publish_date',)
    
    # Specify which fields should be used in the form when adding/editing records
    fields = ('title', 'author', 'publish_date', 'price')
    
    # Enable or disable certain options, such as making the field read-only
    readonly_fields = ('publish_date',)

    # Ordering of records in the list view
    ordering = ('-publish_date',)

    # Enable inline editing of related models
    # This example assumes you have a related model called BookCategory
    inlines = [BookCategoryInline]

# Register the customized admin class with the model
admin.site.register(Book, BookAdmin)
3. Common Customizations
Here are some common customizations you can make:

list_display: Specifies which fields to display in the list view of the admin interface.
search_fields: Adds a search box in the admin interface to filter records based on specific fields.
list_filter: Adds filter options in the sidebar to filter records based on certain fields.
ordering: Specifies the default ordering of records in the admin.
readonly_fields: Makes certain fields read-only when adding or editing records.
fieldsets: Allows you to organize fields into sections when displaying them in the form view.
python
fieldsets = (
    (None, {'fields': ('title', 'author')}),
    ('Publishing Information', {'fields': ('publish_date', 'price')}),
)
4. Customizing the Admin Form with ModelForm
If you need to customize the form used to add or edit model instances in the admin interface, you can use ModelForm to 
create a custom form. Here's an example:

python
from django import forms
from .models import Book

class BookForm(forms.ModelForm):
    class Meta:
        model = Book
        fields = ['title', 'author', 'publish_date', 'price']

    def clean_title(self):
        title = self.cleaned_data.get('title')
        if 'Django' not in title:
            raise forms.ValidationError("Title must contain 'Django'")
        return title

class BookAdmin(admin.ModelAdmin):
    form = BookForm

admin.site.register(Book, BookAdmin)
In this example, the clean_title method adds a validation rule to the title field.

5. Inline Admin for Related Models
If you have related models (e.g., a foreign key relationship), you can use inline models to allow for editing related 
objects directly within the parent model's form. Here's how you can use inlines:

python
Copy code
class BookCategoryInline(admin.TabularInline):
    model = BookCategory
    extra = 1  # Specifies how many empty forms to display by default

class BookAdmin(admin.ModelAdmin):
    inlines = [BookCategoryInline]

admin.site.register(Book, BookAdmin)
6. Customizing the Admin Template
Sometimes, you might want to customize the look of the Django admin interface, like adding custom buttons or modifying 
templates. You can override the default admin templates by creating custom templates in your project.

For example, create a folder called templates/admin in your app directory and place custom admin templates there. 
You can customize things like:

base_site.html: Modify the entire admin site's base structure.
change_form.html: Customize the form for adding/editing objects.
7. Custom Actions
Django allows you to create custom admin actions that can be performed on selected objects. For example:

python
def mark_as_published(modeladmin, request, queryset):
    queryset.update(status='published')

mark_as_published.short_description = 'Mark selected as published'

class BookAdmin(admin.ModelAdmin):
    actions = [mark_as_published]

admin.site.register(Book, BookAdmin)
This action will allow you to mark selected books as "published" with a custom action in the admin interface.

8. Permissions and Access Control
You can customize the access control for different users or groups. For example:

python
class BookAdmin(admin.ModelAdmin):
    def has_add_permission(self, request):
        return request.user.is_superuser  # Only superusers can add books

    def has_delete_permission(self, request, obj=None):
        return False  # Disable delete permission for all users

admin.site.register(Book, BookAdmin)

Lab:
 Set up and customize the Django admin panel to manage a "Doctor Finder" project.

To set up and customize the Django admin panel for a "Doctor Finder" project, you will need to follow several steps to 
ensure that your admin interface is both functional and tailored to your needs. This includes configuring models, 
registering them in the admin, and optionally customizing the appearance and functionality of the admin panel for better 
usability.

Step-by-Step Guide to Set Up and Customize the Django Admin Panel
Step 1: Install and Set Up Django
First, ensure you have Django installed. If you haven't done so, you can install it via pip:

bash
pip install django
Then, create a new Django project and app:

bash
django-admin startproject doctor_finder
cd doctor_finder
python manage.py startapp doctors
Step 2: Create the Doctor Finder Models
In the doctors app, define models for the "Doctor Finder" project. These could include models for doctors, specialties, 
and appointments.

Example: doctors/models.py

python
from django.db import models

# Model for Doctor
class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    email = models.EmailField()
    phone_number = models.CharField(max_length=15)
    specialty = models.ForeignKey('Specialty', on_delete=models.CASCADE)
    location = models.CharField(max_length=255)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

# Model for Specialty
class Specialty(models.Model):
    name = models.CharField(max_length=100)

    def __str__(self):
        return self.name

# Model for Appointment
class Appointment(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient_name = models.CharField(max_length=100)
    appointment_date = models.DateTimeField()
    symptoms = models.TextField()

    def __str__(self):
        return f"{self.patient_name} with {self.doctor} on {self.appointment_date}"
Step 3: Register Models in the Django Admin
To manage these models through the Django admin interface, you need to register them in the admin panel. This is done 
in the doctors/admin.py file.

Example: doctors/admin.py

python
from django.contrib import admin
from .models import Doctor, Specialty, Appointment

# Register the models with the admin site
admin.site.register(Specialty)

# Customize the admin interface for Doctor model
@admin.register(Doctor)
class DoctorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email', 'specialty', 'location')
    search_fields = ('first_name', 'last_name', 'email', 'specialty__name')
    list_filter = ('specialty', 'location')

# Customize the admin interface for Appointment model
@admin.register(Appointment)
class AppointmentAdmin(admin.ModelAdmin):
    list_display = ('doctor', 'patient_name', 'appointment_date', 'symptoms')
    list_filter = ('doctor', 'appointment_date')
    search_fields = ('patient_name', 'doctor__first_name', 'doctor__last_name')
Step 4: Customize the Admin Interface (Optional)
To further customize the appearance or functionality of the admin interface, you can add specific features such as inlines for related models, custom forms, and more.

4.1. Adding Inlines
If you want to allow the addition of related models directly from the Doctor form, you can use TabularInline or 
StackedInline.

Example for adding appointments inline with the doctor:

python
from django.contrib import admin
from .models import Doctor, Specialty, Appointment

class AppointmentInline(admin.TabularInline):
    model = Appointment
    extra = 1  # Number of empty forms to display by default

@admin.register(Doctor)
class DoctorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email', 'specialty', 'location')
    search_fields = ('first_name', 'last_name', 'email', 'specialty__name')
    list_filter = ('specialty', 'location')
    inlines = [AppointmentInline]  # Add appointments inline
4.2. Adding Custom Actions
You can define custom actions in the admin interface to perform bulk operations on selected records. For instance, 
you might want to send a reminder email for upcoming appointments.

python
from django.contrib import admin
from django.core.mail import send_mail
from django.conf import settings
from .models import Doctor, Appointment

@admin.action(description='Send appointment reminder')
def send_appointment_reminder(modeladmin, request, queryset):
    for appointment in queryset:
        send_mail(
            'Appointment Reminder',
            f'Reminder for your appointment with Dr. {appointment.doctor} on {appointment.appointment_date}.',
            settings.DEFAULT_FROM_EMAIL,
            [appointment.patient_email],
        )

@admin.register(Appointment)
class AppointmentAdmin(admin.ModelAdmin):
    list_display = ('doctor', 'patient_name', 'appointment_date', 'symptoms')
    list_filter = ('doctor', 'appointment_date')
    search_fields = ('patient_name', 'doctor__first_name', 'doctor__last_name')
    actions = [send_appointment_reminder]  # Add custom action
Step 5: Update the Settings
Make sure your app is included in the INSTALLED_APPS list in doctor_finder/settings.py:

python
INSTALLED_APPS = [
    ...
    'doctors',  # Add your app here
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    ...
]
Step 6: Run Migrations
Create and apply the migrations to create the necessary database tables for your models:

bash
python manage.py makemigrations doctors
python manage.py migrate
Step 7: Create a Superuser
To access the Django admin panel, create a superuser:

bash
python manage.py createsuperuser
Step 8: Run the Development Server
Start the development server to access the admin panel:

bash
python manage.py runserver
Now, you can go to http://127.0.0.1:8000/admin in your web browser and log in with your superuser credentials.

Optional Customizations:
Custom Forms: You can create custom forms using Django’s ModelForm for more control over input fields.
Admin Site Customization: For deeper customization of the admin interface (e.g., adding custom templates or styles), 
you can create custom admin templates by overriding the default 
ones in the templates/admin directory.
JavaScript Integration: For advanced UI changes like auto-completing inputs or interactive filtering, you can integrate 
JavaScript into your admin.

Practical Example: 8) Write a Django project to create an admin panel and add custom fields for managing doctor information.

Creating a Django project with a custom admin panel to manage doctor information requires a few steps. The general 
steps would include setting up the Django project, creating a model for the doctor information, and then customizing 
the Django admin interface to manage that information.

Here’s a step-by-step guide to accomplish this.

1. Set Up Django Project
First, make sure you have Django installed. If not, you can install it using:

bash
pip install django
Then, create a new Django project and an app:

bash
django-admin startproject healthcare
cd healthcare
django-admin startapp doctors
2. Define the Doctor Model
In the doctors app, define the model that will hold doctor information. Open the doctors/models.py file and define 
the model:

python
from django.db import models

class Doctor(models.Model):
    # Basic fields for doctor information
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialization = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()
    address = models.TextField()
    date_of_birth = models.DateField()
    gender_choices = [
        ('M', 'Male'),
        ('F', 'Female'),
        ('O', 'Other'),
    ]
    gender = models.CharField(max_length=1, choices=gender_choices)

    # Custom fields
    experience = models.PositiveIntegerField(help_text="Years of experience")
    qualifications = models.TextField(help_text="List of qualifications")
    hospital_name = models.CharField(max_length=255)
    
    # Add any other relevant fields as needed

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

    class Meta:
        verbose_name = "Doctor"
        verbose_name_plural = "Doctors"
This model holds basic and custom information about the doctor, such as their name, specialization, phone number, 
experience, and qualifications.

3. Register the Doctor Model with Django Admin
Now, you need to register this model in the Django admin panel to allow easy management of doctor information.

Open doctors/admin.py and add the following code:

python
from django.contrib import admin
from .models import Doctor

class DoctorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'specialization', 'phone_number', 'hospital_name', 'experience')
    search_fields = ('first_name', 'last_name', 'specialization', 'email')
    list_filter = ('specialization', 'gender')
    ordering = ('last_name',)

    # You can customize the form fields here
    fieldsets = (
        (None, {
            'fields': ('first_name', 'last_name', 'specialization', 'phone_number', 'email', 'gender', 'date_of_birth')
        }),
        ('Additional Information', {
            'fields': ('experience', 'qualifications', 'hospital_name', 'address')
        }),
    )

    # Optional: Customize how fields are displayed in the form
    formfield_overrides = {
        models.TextField: {'widget': admin.widgets.TextInput(attrs={'size': '60'})},
    }

# Register the model with the custom admin
admin.site.register(Doctor, DoctorAdmin)
4. Migrate the Database
After defining your model, you need to create the database tables and apply migrations:

bash
python manage.py makemigrations
python manage.py migrate
5. Create Superuser to Access Admin Panel
To access the Django admin panel, you'll need to create a superuser account. Run the following command:

bash
python manage.py createsuperuser
Follow the prompts to set the username, email, and password.

6. Start the Development Server
Now, you can run the development server:

bash
python manage.py runserver
7. Access the Admin Panel
Once the server is running, go to http://127.0.0.1:8000/admin/ in your web browser. Log in with the superuser 
credentials you created earlier, and you should see the "Doctors" model listed in the admin panel.

8. Customization (Optional)
Customizing List View:
If you want to further enhance the way doctors are displayed in the admin list view, you can modify the DoctorAdmin class. For instance, adding a custom method that displays age based on the date of birth:

python
from datetime import date

class DoctorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'specialization', 'phone_number', 'hospital_name', 'experience', 'age')
    
    def age(self, obj):
        return date.today().year - obj.date_of_birth.year
    age.short_description = 'Age'
This will calculate and display the doctor’s age in the admin list.

Adding Inline Forms (Optional):
If you need to handle related models (e.g., patients or appointments associated with a doctor), you can add an inline 
form to the doctor model. You would need to create another model, such as an Appointment, and then use InlineModelAdmin.

python
class Appointment(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient_name = models.CharField(max_length=100)
    appointment_date = models.DateTimeField()

class AppointmentInline(admin.TabularInline):
    model = Appointment
    extra = 1

class DoctorAdmin(admin.ModelAdmin):
    inlines = [AppointmentInline,]

9. URL Patterns and Template Integration
Theory:
 Setting up URL patterns in urls.py for routing requests to views.

In Django, URL routing is done through the urls.py file. This file maps URLs to specific views in your application. 
The urls.py file contains a set of URL patterns that associate a URL string with a view function.

Here’s how you can set up URL patterns in urls.py for routing requests to views:

1. Import Necessary Modules
First, you need to import the path() or re_path() function and the views from your application. path() is generally 
used for straightforward, non-regular-expression-based URLs, while re_path() is used when regular expressions are needed.

python
from django.urls import path
from . import views  # Assuming your views are in the same directory
2. Define URL Patterns
The URL patterns are defined using the path() function, which takes a URL route, a view function, and an optional 
name for the URL. Here is a simple example:

python
urlpatterns = [
    path('', views.home, name='home'),  # Root URL routes to the home view
    path('about/', views.about, name='about'),  # URL '/about/' routes to the about view
    path('contact/', views.contact, name='contact'),  # URL '/contact/' routes to the contact view
]
In this example:

The first argument is the URL string pattern (relative to the domain).
The second argument is the view function that should handle the request for that URL.
The third argument is an optional name that you can use for reversing the URL in templates.
3. Create View Functions in views.py
In your views.py file, you need to define the corresponding view functions. For example:

python
from django.http import HttpResponse

def home(request):
    return HttpResponse("Welcome to the homepage!")

def about(request):
    return HttpResponse("This is the about page.")

def contact(request):
    return HttpResponse("This is the contact page.")
In this case, the home, about, and contact functions simply return an HttpResponse with a string, but in a real project, 
you would likely render a template instead.

4. Using URL Parameters
You can also use dynamic URL patterns that include parameters. For example, if you want to pass a parameter like an 
ID to a view, you can use the following pattern:

python
path('article/<int:id>/', views.article_detail, name='article_detail')
Here, <int:id> means that Django will capture an integer from the URL and pass it to the article_detail view as 
the id parameter.

In your views.py, the article_detail view would look like this:

python
def article_detail(request, id):
    return HttpResponse(f"Displaying article with ID: {id}")
5. Including Other URL Configurations
If your application has multiple apps and you want to include URL patterns from different apps, you can use the 
include() function. This helps in keeping the URL configuration modular.

For example, in your main urls.py (usually located in the project folder), you might have:

python
from django.urls import include, path

urlpatterns = [
    path('blog/', include('blog.urls')),  # Including blog app's URLs
    path('shop/', include('shop.urls')),  # Including shop app's URLs
]
Then in each app’s urls.py file, you would define the specific routes for that app.

Example Final urls.py
python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
    path('about/', views.about, name='about'),
    path('contact/', views.contact, name='contact'),
    path('article/<int:id>/', views.article_detail, name='article_detail'),
]
Summary of URL Patterns:
Static Routes: Simple, direct paths like 'home/', 'about/', etc.
Dynamic Routes: Using parameters in URLs like '<int:id>/' to capture data.
Include URLs from Other Apps: Modular routing by including other apps' URLs.
By defining URL patterns and associating them with views, you allow users to access various pages of your Django 
application based on the URL they visit.

 Integrating templates with views to render dynamic HTML content.

Integrating templates with views to render dynamic HTML content is a common task in web development frameworks, 
especially in Python frameworks like Django or Flask. Below is a step-by-step breakdown of how this is done in Django, 
as it is one of the most popular web frameworks:

1. Set Up Django Project
To get started, you must have a Django project. If you don't have one, create it using:

bash
django-admin startproject myproject
cd myproject
python manage.py startapp myapp
2. Create a Template
Templates in Django allow you to render dynamic content. Django uses the Django template language (DTL) for this. 
Templates typically reside in a templates folder within your application.

Example: Create a template in myapp/templates/myapp/hello.html
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{ title }}</title>
</head>
<body>
    <h1>{{ greeting }}</h1>
    <p>Welcome, {{ name }}!</p>
</body>
</html>
Here:

{{ title }}, {{ greeting }}, and {{ name }} are placeholders that will be filled with dynamic values passed from the view.
3. Configure Views to Render the Template
In Django, views handle HTTP requests and responses. The render() function is used to render a template.

Example: Create a view in myapp/views.py
python
from django.shortcuts import render

def hello_view(request):
    context = {
        'title': 'Hello Page',
        'greeting': 'Hello, World!',
        'name': 'Alice',
    }
    return render(request, 'myapp/hello.html', context)
Here:

render() takes the request, the path to the template ('myapp/hello.html'), and a dictionary (context) which contains 
the dynamic data that will be passed to the template.
4. Set Up URL Routing
For the view to be accessible via a URL, you need to add a URL pattern in the urls.py file of your app.

Example: Update myapp/urls.py
python
from django.urls import path
from . import views

urlpatterns = [
    path('hello/', views.hello_view, name='hello'),
]
5. Include the App URLs in the Project’s URL Configuration
Make sure that the URLs of your app are included in the project’s main urls.py.

Example: Update myproject/urls.py
python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('myapp.urls')),
]
6. Run the Development Server
Run the Django development server to see the result.

bash
python manage.py runserver
Visit http://127.0.0.1:8000/hello/ in your browser, and you should see a page with a dynamic greeting.

Key Concepts:
Views: Handle HTTP requests and return responses. Views can render templates with dynamic content.
Templates: Files containing HTML mixed with Django template language (DTL) to display dynamic content.
Context: A dictionary of dynamic values passed from the view to the template, which are then rendered in the HTML.
URLs: A mechanism to map URLs to views.
Additional Considerations:
Template Inheritance: Templates can inherit from other templates (base templates) to reuse common structures.
Static files: CSS, JavaScript, and images can be served with Django by setting up a static directory.
Forms and User Input: Django views can also handle user input through forms, further dynamic content can be rendered 
based on that input.

Lab:
 Create a Django project with URL patterns and corresponding views and templates.

To create a simple Django project with URL patterns, views, and templates, follow these steps:

Step 1: Install Django
First, make sure you have Python installed, and then install Django via pip.

bash
pip install django
Step 2: Create a New Django Project
Create a new project using the following command:

bash
django-admin startproject myproject
cd myproject
This creates the main project folder myproject containing the necessary files and settings.

Step 3: Create a New Django App
Inside the myproject folder, create a new app. Let's call it myapp.

bash
python manage.py startapp myapp
This creates the myapp folder that will contain views, models, and other app-specific files.

Step 4: Configure the App in settings.py
Open the settings.py file located inside the myproject folder, and add 'myapp' to the INSTALLED_APPS list to register 
the app.

python
INSTALLED_APPS = [
    # Other installed apps
    'myapp',
]
Step 5: Create Views
Inside myapp/views.py, create some simple views that will render HTML templates.

python
# myapp/views.py
from django.shortcuts import render
from django.http import HttpResponse

# View for the homepage
def home(request):
    return render(request, 'home.html')

# View for an about page
def about(request):
    return render(request, 'about.html')
Step 6: Define URL Patterns
Create a new file called urls.py inside the myapp folder. In this file, you will define URL patterns that map to your 
views.

python
# myapp/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),  # Homepage
    path('about/', views.about, name='about'),  # About page
]
Now, open the main urls.py file located inside the myproject folder and include the myapp.urls to connect the app's 
URLs to the project.

python
# myproject/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('myapp.urls')),  # Include the myapp URLs
]
Step 7: Create Templates
Inside the myapp folder, create a folder called templates. Inside templates, create the HTML files home.html and 
about.html.

home.html:
html
<!-- myapp/templates/home.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Home</title>
</head>
<body>
    <h1>Welcome to the Home Page</h1>
    <p><a href="{% url 'about' %}">Go to About Page</a></p>
</body>
</html>
about.html:
html
<!-- myapp/templates/about.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>About</title>
</head>
<body>
    <h1>About Page</h1>
    <p>This is the About page of the Django project.</p>
    <p><a href="{% url 'home' %}">Go to Home Page</a></p>
</body>
</html>
Step 8: Run the Development Server
Now, run the Django development server to see your project in action:

bash
python manage.py runserver
The server should start, and you can visit the following URLs in your browser:

http://127.0.0.1:8000/ for the Home Page
http://127.0.0.1:8000/about/ for the About Page
Summary of the Files:
views.py: Contains view functions for rendering templates.
urls.py (inside the myapp folder): Defines URL patterns and maps them to views.
templates folder: Stores the HTML templates for rendering content.
main urls.py (inside the project folder): Includes the app’s URLs.
That's it! You’ve now created a basic Django project with URL patterns, views, and templates. You can expand this by 
adding more views and templates as needed.

Practical Example: 9) Write a Django project where URL routing is used to navigate between different pages of a “Doctor 
Finder” site (home, profile, contact).

Here's an outline of a simple Django project for a "Doctor Finder" site, where URL routing is used to navigate between different pages such as "Home", "Profile", and "Contact".

Steps:
Create a Django Project:

First, create a Django project and app.

bash
Copy code
django-admin startproject doctor_finder
cd doctor_finder
python manage.py startapp core
Set Up URL Routing:

Django's URL routing allows you to connect specific views with URLs. In this case, you'll define URLs for the "Home", "Profile", and "Contact" pages.

Define Views:

Each page will have a view that returns the respective content.

Set Up Templates:

You'll use Django templates to create HTML files for each page.

Project Structure:
arduino
Copy code
doctor_finder/
    ├── doctor_finder/
    │   ├── __init__.py
    │   ├── settings.py
    │   ├── urls.py
    │   ├── wsgi.py
    │   └── asgi.py
    ├── core/
    │   ├── __init__.py
    │   ├── admin.py
    │   ├── apps.py
    │   ├── models.py
    │   ├── views.py
    │   ├── urls.py
    │   └── templates/
    │       └── core/
    │           ├── home.html
    │           ├── profile.html
    │           └── contact.html
    ├── manage.py
1. Define Views in core/views.py
In core/views.py, create views for each page:

python
Copy code
from django.shortcuts import render

# Home page view
def home(request):
    return render(request, 'core/home.html')

# Profile page view
def profile(request):
    return render(request, 'core/profile.html')

# Contact page view
def contact(request):
    return render(request, 'core/contact.html')
2. Define URLs in core/urls.py
In core/urls.py, define URL patterns that connect to the views you just created.

python
Copy code
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
    path('profile/', views.profile, name='profile'),
    path('contact/', views.contact, name='contact'),
]
3. Set Up Project URLs in doctor_finder/urls.py
Now, you need to include the core app's URLs in the main project URL configuration.

In doctor_finder/urls.py:

python
Copy code
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('core.urls')),  # Include the core app URLs
]
4. Create Templates for the Pages
In the core/templates/core/ directory, create the HTML files for each page.

home.html:
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Finder - Home</title>
</head>
<body>
    <h1>Welcome to Doctor Finder</h1>
    <p>Find the best doctors in your area.</p>
    <nav>
        <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/profile/">Profile</a></li>
            <li><a href="/contact/">Contact</a></li>
        </ul>
    </nav>
</body>
</html>
profile.html:
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Finder - Profile</title>
</head>
<body>
    <h1>Doctor Profile</h1>
    <p>Details about the doctor.</p>
    <nav>
        <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/profile/">Profile</a></li>
            <li><a href="/contact/">Contact</a></li>
        </ul>
    </nav>
</body>
</html>
contact.html:
html
Copy code
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Finder - Contact</title>
</head>
<body>
    <h1>Contact Us</h1>
    <p>Feel free to reach out to us.</p>
    <nav>
        <ul>
            <li><a href="/">Home</a></li>
            <li><a href="/profile/">Profile</a></li>
            <li><a href="/contact/">Contact</a></li>
        </ul>
    </nav>
</body>
</html>
5. Update Settings in doctor_finder/settings.py
Make sure core is included in the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'core',  # Add the core app
]
6. Run the Development Server
Finally, run the development server to check your work:

bash
python manage.py runserver
Now, you can navigate between the pages:

Home: http://127.0.0.1:8000/
Profile: http://127.0.0.1:8000/profile/
Contact: http://127.0.0.1:8000/contact/
This simple Django project uses URL routing to navigate between the home, profile, and contact pages, allowing users 
to explore different sections of the "Doctor Finder" website.

10. Form Validation using JavaScript
Theory:
 Using JavaScript for front-end form validation.

Front-end form validation using JavaScript helps ensure that the data entered by the user is in the correct format before 
it is sent to the server. This improves the user experience by providing immediate feedback and reduces the chances of 
errors.

Here's a simple example of how you can perform front-end form validation using JavaScript:

HTML Form
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form Validation</title>
    <style>
        .error { color: red; }
    </style>
</head>
<body>

    <h2>Registration Form</h2>
    <form id="registrationForm" action="" method="POST" onsubmit="return validateForm()">
        <label for="username">Username:</label>
        <input type="text" id="username" name="username"><br><br>
        <div id="usernameError" class="error"></div>

        <label for="email">Email:</label>
        <input type="email" id="email" name="email"><br><br>
        <div id="emailError" class="error"></div>

        <label for="password">Password:</label>
        <input type="password" id="password" name="password"><br><br>
        <div id="passwordError" class="error"></div>

        <label for="confirmPassword">Confirm Password:</label>
        <input type="password" id="confirmPassword" name="confirmPassword"><br><br>
        <div id="confirmPasswordError" class="error"></div>

        <button type="submit">Register</button>
    </form>

    <script src="formValidation.js"></script>
</body>
</html>
JavaScript (formValidation.js)
javascript
function validateForm() {
    let valid = true;

    // Clear previous error messages
    clearErrors();

    // Validate username
    let username = document.getElementById('username').value;
    if (username === "") {
        displayError("usernameError", "Username is required.");
        valid = false;
    } else if (username.length < 3) {
        displayError("usernameError", "Username must be at least 3 characters long.");
        valid = false;
    }

    // Validate email
    let email = document.getElementById('email').value;
    let emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}$/;
    if (email === "") {
        displayError("emailError", "Email is required.");
        valid = false;
    } else if (!emailPattern.test(email)) {
        displayError("emailError", "Please enter a valid email address.");
        valid = false;
    }

    // Validate password
    let password = document.getElementById('password').value;
    if (password === "") {
        displayError("passwordError", "Password is required.");
        valid = false;
    } else if (password.length < 6) {
        displayError("passwordError", "Password must be at least 6 characters long.");
        valid = false;
    }

    // Validate confirm password
    let confirmPassword = document.getElementById('confirmPassword').value;
    if (confirmPassword === "") {
        displayError("confirmPasswordError", "Please confirm your password.");
        valid = false;
    } else if (confirmPassword !== password) {
        displayError("confirmPasswordError", "Passwords do not match.");
        valid = false;
    }

    // If any validation failed, prevent form submission
    return valid;
}

// Helper functions to display and clear errors
function displayError(elementId, message) {
    document.getElementById(elementId).textContent = message;
}

function clearErrors() {
    document.getElementById("usernameError").textContent = "";
    document.getElementById("emailError").textContent = "";
    document.getElementById("passwordError").textContent = "";
    document.getElementById("confirmPasswordError").textContent = "";
}
Explanation:
HTML Form:

The form includes fields for username, email, password, and confirmPassword.
Each input field has an associated div element to display error messages (usernameError, emailError, etc.).
The form uses the onsubmit event to trigger the validateForm() function before submitting the form.
JavaScript Validation:

The validateForm() function is triggered when the user attempts to submit the form.
It checks whether each field meets specific criteria:
Username: Required and at least 3 characters long.
Email: Required and must follow a valid email format (using a regular expression).
Password: Required and at least 6 characters long.
Confirm Password: Required and must match the password field.
If any validation fails, the corresponding error message is displayed, and the form submission is prevented by returning 
false from validateForm().
Error Display:

The displayError() function shows the error message for the relevant field.
The clearErrors() function clears any previous error messages before validating the form.
Notes:
This validation is client-side, meaning it only checks data before sending it to the server. However, you should always 
validate the data again on the server side, as JavaScript validation can be bypassed by users who disable JavaScript or 
manipulate the form.
You can enhance the form with more sophisticated validation (e.g., regex for password strength, phone number validation, 
etc.) based on your needs.
This setup provides a basic approach to validating a form before submission using JavaScript.

Lab:
 Write a Django project to implement JavaScript form validation for a user registration form.

To implement JavaScript form validation for a user registration form within a Django project, we'll follow these steps:

Create a Django Project and App: Set up the Django environment and create a new app for user registration.
Create the Registration Form: In the Django app, create a user registration form using Django's forms.Form.
Create the HTML Template: In this template, embed JavaScript to handle client-side validation.
Write the JavaScript Code: Add JavaScript for form validation (e.g., checking for empty fields, valid email format, 
password confirmation).
Configure the URL Routing: Set up the URL for the registration page.
Write Views: Create the view to handle form submission.
Step 1: Create a Django Project and App
First, make sure you have Django installed. If not, install it via pip:

bash
pip install django
Now, create a new Django project:

bash
django-admin startproject user_registration
cd user_registration
Create a new app inside your project:

bash
python manage.py startapp accounts
Step 2: Create the Registration Form
In your accounts app, create a forms.py file for the user registration form.

python
# accounts/forms.py
from django import forms

class RegistrationForm(forms.Form):
    username = forms.CharField(max_length=100, widget=forms.TextInput(attrs={'placeholder': 'Username'}))
    email = forms.EmailField(widget=forms.EmailInput(attrs={'placeholder': 'Email Address'}))
    password = forms.CharField(widget=forms.PasswordInput(attrs={'placeholder': 'Password'}))
    confirm_password = forms.CharField(widget=forms.PasswordInput(attrs={'placeholder': 'Confirm Password'}))
Step 3: Create the HTML Template
In the accounts app, create a template folder structure:

bash
mkdir -p accounts/templates/accounts
Now, create an HTML file (register.html) in the accounts/templates/accounts folder.

html
<!-- accounts/templates/accounts/register.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Registration</title>
    <script>
        // JavaScript function for form validation
        function validateForm() {
            var username = document.getElementById("id_username").value;
            var email = document.getElementById("id_email").value;
            var password = document.getElementById("id_password").value;
            var confirmPassword = document.getElementById("id_confirm_password").value;
            var errorMessage = "";

            // Username validation
            if (username == "") {
                errorMessage += "Username is required.\n";
            }

            // Email validation
            var emailPattern = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
            if (email == "") {
                errorMessage += "Email is required.\n";
            } else if (!emailPattern.test(email)) {
                errorMessage += "Please enter a valid email address.\n";
            }

            // Password validation
            if (password == "") {
                errorMessage += "Password is required.\n";
            }

            // Confirm password validation
            if (confirmPassword == "") {
                errorMessage += "Confirm password is required.\n";
            } else if (password !== confirmPassword) {
                errorMessage += "Passwords do not match.\n";
            }

            // Show error messages if there are any
            if (errorMessage) {
                alert(errorMessage);
                return false;
            }

            return true;
        }
    </script>
</head>
<body>
    <h2>User Registration</h2>
    <form method="POST" onsubmit="return validateForm()">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Register</button>
    </form>
</body>
</html>
Step 4: Write Views
In accounts/views.py, create a view to handle the registration form.

python
# accounts/views.py
from django.shortcuts import render
from .forms import RegistrationForm

def register(request):
    if request.method == "POST":
        form = RegistrationForm(request.POST)
        if form.is_valid():
            # You would typically save the user here
            # user = User.objects.create_user(username=form.cleaned_data['username'], password=form.cleaned_data
['password'])
            return render(request, 'accounts/success.html')  # Success page after registration
    else:
        form = RegistrationForm()

    return render(request, 'accounts/register.html', {'form': form})
Step 5: Configure URL Routing
In user_registration/urls.py, include the accounts app's URLs.

python
# user_registration/urls.py
from django.contrib import admin
from django.urls import path
from accounts import views

urlpatterns = [
    path('admin/', admin.site.urls),
    path('register/', views.register, name='register'),
]
Step 6: Create a Success Page
Create a simple success page to be shown after registration.

html
<!-- accounts/templates/accounts/success.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Registration Successful</title>
</head>
<body>
    <h2>Registration Successful!</h2>
    <p>Thank you for registering. You can now log in.</p>
</body>
</html>
Step 7: Run the Django Server
Finally, apply migrations and start the Django server:

bash
python manage.py migrate
python manage.py runserver
Step 8: Test the Form
Navigate to http://127.0.0.1:8000/register/ in your browser. You should be able to see the registration form with 
JavaScript validation. When you try to submit the form with invalid inputs (e.g., empty fields, invalid email, passwords 
not matching), an alert will pop up with the relevant error messages.

Optional Enhancements:
Backend Validation: Although we have JavaScript validation, Django's backend should still handle validation for security 
purposes.
Styling: You can use CSS or a CSS framework (e.g., Bootstrap) to style the form and the page.
This setup gives you a Django project with a user registration form that includes JavaScript validation for a better user 
experience.

Practical Example: 10) Write a Django project that uses JavaScript to validate fields like email and phone number in a 
registration form.

To create a Django project with JavaScript-based form validation for email and phone number, follow these steps:

Step 1: Set up your Django project
Install Django:

If you don't have Django installed, you can install it via pip:

bash
pip install django
Create a Django project:

Run the following command to create a Django project:

bash
django-admin startproject user_registration
cd user_registration
Create an app for the registration form:

Inside the project directory, create a new app:

bash
python manage.py startapp registration
Add the app to INSTALLED_APPS:

Open user_registration/settings.py and add 'registration' to INSTALLED_APPS:

python
INSTALLED_APPS = [
    # Other installed apps
    'registration',
]
Step 2: Create a Registration Model (Optional)
For the sake of this example, we are focusing on the form, but you may want to create a model to store user data.

Open registration/models.py and add:

python
from django.db import models

class User(models.Model):
    username = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    phone = models.CharField(max_length=15, unique=True)

    def __str__(self):
        return self.username
Run the following commands to create and apply migrations:

bash
python manage.py makemigrations
python manage.py migrate
Step 3: Create a Registration Form
In the registration/forms.py file, create a form for user registration:

python
from django import forms
from .models import User

class RegistrationForm(forms.ModelForm):
    class Meta:
        model = User
        fields = ['username', 'email', 'phone']
Step 4: Create the View
Open registration/views.py and create a view to render the registration form:

python
from django.shortcuts import render, redirect
from .forms import RegistrationForm

def register(request):
    if request.method == 'POST':
        form = RegistrationForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('success')  # Redirect to a success page or home page
    else:
        form = RegistrationForm()
    
    return render(request, 'registration/register.html', {'form': form})
Step 5: Create URLs for the Registration Page
In registration/urls.py, set up the URL path for registration:

python
from django.urls import path
from . import views

urlpatterns = [
    path('register/', views.register, name='register'),
]
Then, include the registration URLs in the main urls.py of the project:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('user/', include('registration.urls')),
]
Step 6: Create the HTML Template with JavaScript Validation
Create the registration/templates/registration/register.html file and include the form and JavaScript for validation:

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>User Registration</title>
    <script>
        // Function to validate email
        function validateEmail() {
            const email = document.getElementById("id_email").value;
            const emailPattern = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
            const emailError = document.getElementById("email-error");
            if (!emailPattern.test(email)) {
                emailError.textContent = "Please enter a valid email address.";
                return false;
            } else {
                emailError.textContent = "";
                return true;
            }
        }

        // Function to validate phone number
        function validatePhone() {
            const phone = document.getElementById("id_phone").value;
            const phonePattern = /^[0-9]{10}$/;
            const phoneError = document.getElementById("phone-error");
            if (!phonePattern.test(phone)) {
                phoneError.textContent = "Please enter a valid 10-digit phone number.";
                return false;
            } else {
                phoneError.textContent = "";
                return true;
            }
        }

        // Submit validation
        function validateForm(event) {
            if (!validateEmail() || !validatePhone()) {
                event.preventDefault();
                return false;
            }
            return true;
        }
    </script>
</head>
<body>

    <h1>Register</h1>

    <form method="POST" onsubmit="return validateForm(event)">
        {% csrf_token %}
        {{ form.as_p }}
        
        <div id="email-error" style="color: red;"></div>
        <div id="phone-error" style="color: red;"></div>

        <button type="submit">Submit</button>
    </form>

</body>
</html>
Step 7: Add a Success Page (Optional)
You can create a simple success page for when the form is submitted successfully.

Add a new view in registration/views.py:

python
def success(request):
    return render(request, 'registration/success.html')
Create the registration/templates/registration/success.html file:

html
<h1>Registration Successful!</h1>
<p>Thank you for registering.</p>
Add a URL for the success page in registration/urls.py:

python
urlpatterns = [
    path('register/', views.register, name='register'),
    path('success/', views.success, name='success'),
]
Step 8: Run the Project
Finally, run the Django development server:

bash
python manage.py runserver
Visit http://127.0.0.1:8000/user/register/ in your browser to see the registration form with JavaScript validation for 
the email and phone number fields.

Summary:
You created a Django project with an app for user registration.
You implemented a form for user data submission.
You added JavaScript to validate the email and phone number fields before submission.
This is a simple approach to front-end validation with JavaScript in a Django project. You can always enhance it further 
by adding more validations or utilizing Django’s form validation methods as well.

11. Django Database Connectivity (MySQL or SQLite)
Theory:
 Connecting Django to a database (SQLite or MySQL).

To connect Django to a database, you typically configure the database settings in the settings.py file of your Django project. You can connect Django to SQLite (which is the default option) or MySQL, depending on your requirements.

1. Connecting Django to SQLite (Default Database)
Django comes with SQLite as the default database backend, so you don’t need to do anything extra to use it. SQLite is 
lightweight and good for development and small projects.

Steps to connect Django to SQLite:
Ensure that your Django project is set up and that you are in your project’s root directory.
Open the settings.py file located in the project_name/project_name folder.
Find the DATABASES configuration and it will look like this by default:
python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
This configuration tells Django to use SQLite and stores the database file (db.sqlite3) in your project’s base directory.

No further configuration is needed to use SQLite. Just run the following commands to initialize the database:

bash
python manage.py migrate  # Apply database migrations
2. Connecting Django to MySQL
To connect Django to a MySQL database, you’ll need to install the MySQL database driver (e.g., mysqlclient or PyMySQL).

Prerequisites:
Install the MySQL driver using pip:

For mysqlclient (recommended for performance):

bash
pip install mysqlclient
Alternatively, for PyMySQL:

bash
pip install PyMySQL
If you're using PyMySQL, you'll need to tell Django to use it by adding the following to your __init__.py file (in your 
project folder):

python
import pymysql
pymysql.install_as_MySQLdb()
Steps to connect Django to MySQL:
Open the settings.py file.
Modify the DATABASES setting to use MySQL by changing the 'ENGINE', 'NAME', 'USER', 'PASSWORD', 'HOST', and 'PORT' fields. Example:
python
Copy code
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'your_database_name',
        'USER': 'your_database_user',
        'PASSWORD': 'your_database_password',
        'HOST': 'localhost',  # Or IP address of your MySQL server
        'PORT': '3306',  # Default MySQL port
    }
}
Ensure you have a MySQL database created on your server. You can create one using MySQL CLI or a database management 
tool like phpMyAdmin.

Example of creating a database from MySQL CLI:

bash
mysql -u root -p
CREATE DATABASE your_database_name;
After configuring the database connection, run the following commands to migrate your database schema:

bash
python manage.py migrate
If you encounter any issues with the database connection (e.g., permission issues or missing packages), verify the 
MySQL connection details and ensure that the mysqlclient or PyMySQL driver is properly installed.
Additional Configuration for MySQL:
Make sure your MySQL user has proper permissions to access and modify the database.
You may need to adjust the DATABASES settings for advanced configurations like using a remote database or tweaking 
performance.
3. Switching Between SQLite and MySQL
You can easily switch between SQLite and MySQL in Django by changing the DATABASES settings in the settings.py file. 
Just switch the ENGINE and database credentials as required, then run migrate to set up the schema for the new database.

Summary:
SQLite: No additional setup, just use the default configuration in settings.py.
MySQL: Install the MySQL driver (mysqlclient or PyMySQL), configure the DATABASES setting in settings.py, and make sure 
your MySQL database is created and accessible.
Let me know if you need help with any specific step!

 Using the Django ORM for database queries.

The Django ORM (Object-Relational Mapping) allows you to interact with your database using Python objects and provides a 
high-level, abstracted way to query, manipulate, and manage your database without writing raw SQL. Below are some examples of how to use the Django ORM for common database queries.

1. Defining a Model
Before querying the database, you need to define a model. A model represents a table in the database.

python
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=100)
    published_date = models.DateField()
    price = models.DecimalField(max_digits=5, decimal_places=2)

    def __str__(self):
        return self.title
2. Basic Querying
Once the model is created, Django provides a manager (objects) that can be used to query the database.

a. Creating Objects (Insert Data)
To create a new record in the Book table:

python
# Creating a single record
book = Book.objects.create(
    title='The Great Gatsby',
    author='F. Scott Fitzgerald',
    published_date='1925-04-10',
    price=10.99
)
Alternatively:

python
book = Book(title='1984', author='George Orwell', published_date='1949-06-08', price=9.99)
book.save()
b. Reading Objects (Select Data)
To retrieve records from the database, you can use different query methods.

Get a single object:
python
book = Book.objects.get(id=1)
Note: get() will raise a DoesNotExist exception if no record matches the query.

Filter records (returns a QuerySet):
python
books = Book.objects.filter(author='George Orwell')
Get all records:
python
all_books = Book.objects.all()
Get the first record:
python
first_book = Book.objects.first()
Get the last record:
python
last_book = Book.objects.last()
c. Advanced Filtering
Filter by multiple fields:
python
books = Book.objects.filter(author='George Orwell', price__lt=15)
Filtering with OR conditions:
python
from django.db.models import Q
books = Book.objects.filter(Q(author='George Orwell') | Q(author='Aldous Huxley'))
Using exclude() to exclude certain records:
python
books = Book.objects.exclude(author='George Orwell')
Using order_by() to sort records:
python
books = Book.objects.all().order_by('price')  # Ascending order
books = Book.objects.all().order_by('-price')  # Descending order
d. Limiting Results
You can limit the number of records returned using [:n].

python
# Get the first 5 books
books = Book.objects.all()[:5]
e. Aggregating Data
Django provides several aggregation functions to calculate data like sum, average, count, etc.

python
from django.db.models import Avg, Max, Min, Count, Sum

# Calculate the average price of all books
avg_price = Book.objects.aggregate(Avg('price'))

# Calculate the total number of books
total_books = Book.objects.aggregate(Count('id'))

# Get the maximum price of books
max_price = Book.objects.aggregate(Max('price'))
f. Updating Objects
To update records, you can use the update() method:

python
# Update all books by a specific author
Book.objects.filter(author='George Orwell').update(price=12.99)
g. Deleting Objects
To delete records, you can use the delete() method:

python
# Delete a specific book
book = Book.objects.get(id=1)
book.delete()

# Delete all books by a specific author
Book.objects.filter(author='George Orwell').delete()
3. Other Useful ORM Methods
Exists check:
python
# Check if any book by George Orwell exists
exists = Book.objects.filter(author='George Orwell').exists()
Chaining queries:
python
books = Book.objects.filter(price__gt=10).order_by('-published_date')[:5]
Using select_related (for ForeignKey relationships) to optimize queries:
python
# Assuming a ForeignKey to an Author model
books = Book.objects.select_related('author').filter(author__name='George Orwell')
Using prefetch_related (for ManyToMany relationships) to optimize queries:
python
# Assuming a ManyToMany relationship with Categories
books = Book.objects.prefetch_related('categories').all()
4. Model Methods for Custom Queries
You can define custom model methods to encapsulate complex queries:

python
class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=100)
    published_date = models.DateField()
    price = models.DecimalField(max_digits=5, decimal_places=2)

    def is_expensive(self):
        return self.price > 20
You can call this method on any Book object:

python
book = Book.objects.get(id=1)
print(book.is_expensive())  # True or False
5. Custom Managers
Django allows you to define custom managers for more complex queries that are used frequently.

python
class BookManager(models.Manager):
    def expensive_books(self):
        return self.filter(price__gt=20)

class Book(models.Model):
    title = models.CharField(max_length=100)
    price = models.DecimalField(max_digits=5, decimal_places=2)

    objects = BookManager()  # Custom Manager

# Using the custom manager
expensive_books = Book.objects.expensive_books()
6. Transaction Management
Sometimes, you need to ensure multiple database operations occur atomically. You can use Django’s transaction to manage 
this.

python
from django.db import transaction

with transaction.atomic():
    book1 = Book.objects.create(title='Book 1', price=15.00)
    book2 = Book.objects.create(title='Book 2', price=20.00)
    # If any exception occurs, both will be rolled back

Lab:
 Set up database connectivity for a Django project.

Setting up database connectivity in a Django project involves configuring the DATABASES setting in the Django settings 
file to connect your project to the desired database.

1. Install the Database Driver
First, ensure that you have installed the appropriate database driver for your chosen database (e.g., PostgreSQL, 
MySQL, SQLite, etc.). For common databases, here are the installation commands:

For PostgreSQL:
bash
pip install psycopg2
For MySQL:
bash
pip install mysqlclient
For SQLite (no installation required as it’s bundled with Django):
SQLite is the default database in Django, so you don't need to install any additional driver.

2. Update settings.py for Database Configuration
In your Django project’s settings.py, locate the DATABASES setting and configure it with the database details. 
Below are examples for various databases:

For PostgreSQL:
python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'your_db_name',
        'USER': 'your_db_user',
        'PASSWORD': 'your_db_password',
        'HOST': 'localhost',  # Or the IP address of your DB server
        'PORT': '5432',  # Default PostgreSQL port
    }
}
For MySQL:
python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'your_db_name',
        'USER': 'your_db_user',
        'PASSWORD': 'your_db_password',
        'HOST': 'localhost',  # Or the IP address of your DB server
        'PORT': '3306',  # Default MySQL port
    }
}
For SQLite (default setup in Django):
python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',  # Path to SQLite database file
    }
}
Replace your_db_name, your_db_user, and your_db_password with your actual database credentials. The HOST is typically 
localhost for local development or can be an IP address/hostname for remote servers.

3. Migrate the Database
Once the database configuration is done, you need to create the necessary database tables using Django’s migration system.

Run the following commands to apply migrations:

bash
# Make migrations for any changes in models
python manage.py makemigrations

# Apply migrations to the database
python manage.py migrate
4. Verify Database Connectivity
To verify that the database is connected correctly:

Start the Django development server:
bash
python manage.py runserver
You can now check if everything works by visiting the admin panel at http://127.0.0.1:8000/admin/ (if you’ve set up 
Django's admin) or interact with the database through Django’s ORM in the shell.
bash
python manage.py shell
Inside the shell, you can try to query a model (make sure you've created one) to confirm the connection.

python
from myapp.models import MyModel
MyModel.objects.all()
If everything is set up correctly, Django should be able to connect to the database, and you can interact with it using 
Django’s ORM.

Optional: Database Configuration for Production
For production environments, you should:

Use a secure database user with limited privileges.
Set up proper database backups and performance optimizations.
Ensure that the database connection is secure (e.g., by using SSL for remote database connections).
This setup will provide basic connectivity for your Django project’s database.

Practical Example: 11) Write a Django project to connect to an SQLite/MySQL database and manage doctor records.

To create a Django project that connects to an SQLite or MySQL database and manages doctor records, follow these steps:

Step 1: Install Django
First, ensure you have Python installed on your machine, then install Django via pip:

bash
pip install django
Step 2: Create a New Django Project
Create a new Django project called doctor_management.

bash
django-admin startproject doctor_management
cd doctor_management
Step 3: Create a New App for Managing Doctor Records
Now, create a new Django app where the logic for managing doctor records will be implemented:

bash
python manage.py startapp doctors
Step 4: Configure Database Settings
Django uses SQLite by default, but if you want to connect to MySQL, you need to update the DATABASES setting in the 
doctor_management/settings.py file.

For SQLite (default setting):
The default configuration for SQLite is already set in the DATABASES dictionary. It should look like this:

python
Copy code
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
For MySQL:
If you want to use MySQL, update your DATABASES setting like this:

Install the MySQL client:
bash
pip install mysqlclient
Update the DATABASES setting in doctor_management/settings.py:
python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'doctor_db',  # Your MySQL database name
        'USER': 'your_mysql_user',
        'PASSWORD': 'your_mysql_password',
        'HOST': 'localhost',
        'PORT': '3306',
    }
}
Step 5: Define the Doctor Model
In the doctors app, define a Doctor model in doctors/models.py. This model will represent the doctor records in the 
database.

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialization = models.CharField(max_length=100)
    contact_number = models.CharField(max_length=15)
    email = models.EmailField()
    license_number = models.CharField(max_length=50, unique=True)
    years_of_experience = models.PositiveIntegerField()

    def __str__(self):
        return f"Dr. {self.first_name} {self.last_name} ({self.specialization})"
Step 6: Register the Model in Admin
To manage doctor records via Django's admin interface, register the Doctor model in doctors/admin.py.

python
from django.contrib import admin
from .models import Doctor

admin.site.register(Doctor)
Step 7: Create Database Migrations
Run the following commands to create the necessary database tables for the Doctor model.

bash
python manage.py makemigrations
python manage.py migrate
Step 8: Create Views for Managing Doctor Records
Now, create views in doctors/views.py to display and manage doctor records.

python
from django.shortcuts import render
from django.http import HttpResponse
from .models import Doctor

# View to display all doctors
def doctor_list(request):
    doctors = Doctor.objects.all()
    return render(request, 'doctors/doctor_list.html', {'doctors': doctors})

# View to add a new doctor
def add_doctor(request):
    if request.method == "POST":
        first_name = request.POST['first_name']
        last_name = request.POST['last_name']
        specialization = request.POST['specialization']
        contact_number = request.POST['contact_number']
        email = request.POST['email']
        license_number = request.POST['license_number']
        years_of_experience = request.POST['years_of_experience']

        Doctor.objects.create(
            first_name=first_name,
            last_name=last_name,
            specialization=specialization,
            contact_number=contact_number,
            email=email,
            license_number=license_number,
            years_of_experience=years_of_experience
        )
        return HttpResponse("Doctor added successfully!")
    return render(request, 'doctors/add_doctor.html')
Step 9: Create URLs for Views
Now, create a urls.py file in the doctors app to define URL paths for the views.

Create the file doctors/urls.py:

python
from django.urls import path
from . import views

urlpatterns = [
    path('doctors/', views.doctor_list, name='doctor_list'),
    path('add-doctor/', views.add_doctor, name='add_doctor'),
]
Also, include these URLs in the main urls.py file (doctor_management/urls.py):

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('doctors.urls')),
]
Step 10: Create HTML Templates
Now, create templates to display and add doctor records.

Create a folder called templates in the doctors app and inside it create doctor_list.html and add_doctor.html.
doctor_list.html:
html
<!DOCTYPE html>
<html>
<head>
    <title>Doctor List</title>
</head>
<body>
    <h1>Doctor List</h1>
    <ul>
        {% for doctor in doctors %}
            <li>{{ doctor.first_name }} {{ doctor.last_name }} - {{ doctor.specialization }}</li>
        {% endfor %}
    </ul>
</body>
</html>
add_doctor.html:
html
<!DOCTYPE html>
<html>
<head>
    <title>Add Doctor</title>
</head>
<body>
    <h1>Add a new doctor</h1>
    <form method="POST">
        {% csrf_token %}
        <label>First Name:</label>
        <input type="text" name="first_name" required><br>

        <label>Last Name:</label>
        <input type="text" name="last_name" required><br>

        <label>Specialization:</label>
        <input type="text" name="specialization" required><br>

        <label>Contact Number:</label>
        <input type="text" name="contact_number" required><br>

        <label>Email:</label>
        <input type="email" name="email" required><br>

        <label>License Number:</label>
        <input type="text" name="license_number" required><br>

        <label>Years of Experience:</label>
        <input type="number" name="years_of_experience" required><br>

        <button type="submit">Add Doctor</button>
    </form>
</body>
</html>
Step 11: Run the Development Server
Finally, run the development server to test your Django project:

bash
python manage.py runserver
You can now access the following URLs:

/doctors/: Displays a list of all doctors.
/add-doctor/: Allows you to add a new doctor.
Step 12: Admin Panel (Optional)
If you want to manage doctors through the Django admin panel, you can use the default Django admin interface.

To enable it, create a superuser:

bash
python manage.py createsuperuser
After creating the superuser, go to http://127.0.0.1:8000/admin/, log in, and manage doctor records.

12. ORM and QuerySets
Theory:
 Understanding Django’s ORM and how QuerySets are used to interact with the database.

Django's ORM (Object-Relational Mapping) allows developers to interact with a database using Python objects rather than 
writing raw SQL queries. This provides a higher-level abstraction, making database operations simpler and more Pythonic. 
One of the core components of Django’s ORM is the QuerySet, which is an abstraction over database queries. Let's break 
down key concepts to understand how QuerySets work and how they are used to interact with the database.

What is a QuerySet?
A QuerySet is a collection of database queries that can be filtered, ordered, and modified before execution. 
Essentially, a QuerySet represents a list of objects in your database that match the conditions you specify. 
Django automatically translates the QuerySet operations into SQL statements.

Basic Operations with QuerySets
Retrieving Data: QuerySets can be used to fetch data from the database, representing database rows as model instances. 
For example, if you have a Book model and want to retrieve all the books in the database:

python
from myapp.models import Book
books = Book.objects.all()
This will return a QuerySet containing all the books in the Book table.

Filtering Data: You can filter QuerySets by applying conditions, using methods like .filter(), .exclude(), and .get().

.filter(): Returns a new QuerySet containing only the objects that match the given conditions.

python
books_by_author = Book.objects.filter(author="J.K. Rowling")
.exclude(): Returns a QuerySet with all the objects except the ones matching the given conditions.

python
books_not_by_author = Book.objects.exclude(author="J.K. Rowling")
.get(): Returns a single object, and raises an exception if more than one object matches the query.

python
book = Book.objects.get(id=1)  # Raises Book.DoesNotExist if no such object is found
Chaining QuerySets: QuerySets are lazy, meaning that no database query is executed until the data is actually needed. You can chain multiple QuerySet methods together to refine your query:

python
books = Book.objects.filter(author="J.K. Rowling").exclude(title__contains="First").order_by("publication_date")
This would:

Filter books by the author "J.K. Rowling".
Exclude books whose titles contain "First".
Order the remaining books by their publication date.
Ordering Data: You can use the .order_by() method to order the results of a QuerySet:

python
books = Book.objects.all().order_by('publication_date')  # Ascending order by publication date
You can reverse the order by adding a minus sign:

python
books = Book.objects.all().order_by('-publication_date')  # Descending order by publication date
Limiting Results: Django provides a .limit() function to limit the number of rows returned in the QuerySet:

python
books = Book.objects.all()[:10]  # Returns the first 10 books
QuerySet Methods for Aggregation and Calculation
Django's ORM also supports aggregation and annotation on QuerySets.

Aggregation: You can use aggregate() to compute aggregate values like sums, averages, counts, etc.

python
from django.db.models import Avg
average_price = Book.objects.aggregate(Avg('price'))
Annotation: You can use annotate() to add computed values to each item in the QuerySet, useful for per-object computations.

python
from django.db.models import Count
books_with_reviews = Book.objects.annotate(num_reviews=Count('reviews'))
QuerySet Execution
As mentioned, QuerySets are lazy, meaning they don’t hit the database until they are actually evaluated. You can force 
evaluation in different ways:

Iterating over the QuerySet:

python
for book in books:
    print(book.title)
Converting to a list:

python
books_list = list(Book.objects.all())
Using methods that return a single result:

python
first_book = Book.objects.first()  # Returns the first result or None if no results
Modifying Data: Creating, Updating, and Deleting Records
You can also use QuerySets to create, update, and delete records.

Creating Records:

python
book = Book.objects.create(title="New Book", author="Author Name")
Updating Records: Use .update() to modify existing records. This affects all records in the QuerySet:

python
Book.objects.filter(author="Author Name").update(price=19.99)
Deleting Records: You can delete records from the database using .delete():

python
Book.objects.filter(author="Author Name").delete()
QuerySet Caching
Django caches QuerySets to optimize performance. Once a QuerySet is evaluated, its result is cached. For instance:

python
books = Book.objects.filter(author="J.K. Rowling")
books_list = list(books)  # Query executed here and results are cached
books_list_again = list(books)  # No query to the database, results are fetched from cache

Lab:
 Perform CRUD operations using Django ORM.

Performing CRUD (Create, Read, Update, Delete) operations using Django ORM (Object-Relational Mapping) involves 
interacting with the database using Python code rather than writing raw SQL queries. Here's a simple guide on how to 
perform CRUD operations using Django ORM.

Step 1: Set Up Django Project
First, ensure that Django is installed. If not, you can install it using:

bash
pip install django
Create a new Django project and app if you haven't done so already:

bash
django-admin startproject myproject
cd myproject
python manage.py startapp myapp
Add your app to the INSTALLED_APPS in myproject/settings.py:

python
INSTALLED_APPS = [
    # other apps
    'myapp',
]
Step 2: Create a Model
In Django, models define the structure of your database tables. For example, let's create a simple model in 
myapp/models.py:

python
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=200)
    author = models.CharField(max_length=100)
    published_date = models.DateField()
    isbn_number = models.CharField(max_length=13, unique=True)

    def __str__(self):
        return self.title
This model represents a book with a title, author, published date, and ISBN number.

Step 3: Apply Migrations
After defining the model, you'll need to create and apply migrations to generate the corresponding database table.

Generate migration files:
bash
python manage.py makemigrations
Apply the migrations to the database:
bash
python manage.py migrate
Step 4: CRUD Operations Using Django ORM
1. Create (Insert data into the database)
To create a new record, you can use the create() method or instantiate an object and then save it.

python
# Using create() method
book = Book.objects.create(
    title="The Django Book",
    author="John Doe",
    published_date="2024-12-25",
    isbn_number="1234567890123"
)

# Alternatively, instantiate and save manually
book = Book(title="Advanced Django", author="Jane Doe", published_date="2024-11-10", isbn_number="9876543210987")
book.save()
2. Read (Retrieve data from the database)
You can use methods like all(), filter(), get(), and exclude() to retrieve data.

python
# Get all books
books = Book.objects.all()

# Get a single book by its primary key (ID)
book = Book.objects.get(id=1)

# Filter books by author
books_by_author = Book.objects.filter(author="John Doe")

# Exclude books with a specific title
books_excluding_django = Book.objects.exclude(title="The Django Book")
3. Update (Modify data in the database)
To update an existing record, retrieve the object, modify its fields, and then save it.

python
# Retrieve a book and update its details
book = Book.objects.get(id=1)
book.title = "Updated Book Title"
book.save()

# Alternatively, you can update multiple records at once
Book.objects.filter(author="John Doe").update(title="Updated Title for John Doe Books")
4. Delete (Remove data from the database)
To delete records, you can use the delete() method.

python
# Delete a single book
book = Book.objects.get(id=1)
book.delete()

# Delete multiple books at once
Book.objects.filter(author="Jane Doe").delete()
Example: CRUD Operations in Django
Here's a complete example of performing CRUD operations in a Django shell. To open the Django shell, run:

bash
python manage.py shell
Inside the shell:

python
# Create a book
book1 = Book.objects.create(
    title="Python Basics",
    author="Alice",
    published_date="2023-06-15",
    isbn_number="1112223334445"
)

# Read books
all_books = Book.objects.all()  # Get all books
book = Book.objects.get(id=1)  # Get a book by its ID
print(book.title)

# Update a book
book1.title = "Advanced Python"
book1.save()

# Delete a book
book1.delete()

# Filter books by author
books_by_alice = Book.objects.filter(author="Alice")
Additional Notes:
QuerySets: Most of the methods like all(), filter(), etc., return QuerySet objects. A QuerySet is a collection of 
database queries, which are executed lazily (only when evaluated).
get() vs filter(): get() is used when you expect a single result (it raises DoesNotExist or MultipleObjectsReturned 
exceptions if there are no results or multiple results), while filter() is used when you expect multiple results.
By using Django's ORM, you can handle database operations easily without writing raw SQL, making your development process 
faster and more secure.

Practical Example: 12) Write a Django project that demonstrates CRUD operations (Create, Read, Update, Delete) on doctor 
profiles using Django ORM.

To create a Django project that demonstrates CRUD operations (Create, Read, Update, Delete) on doctor profiles using 
Django ORM, follow these steps:

1. Set up your Django project
First, make sure you have Django installed. If not, install it using:

bash
pip install django
Next, create a new Django project:

bash
django-admin startproject doctor_crud
cd doctor_crud
Then, create a new Django app within your project called profiles:

bash
python manage.py startapp profiles
2. Define the Doctor model
In the profiles app, define a model for storing doctor information. Open profiles/models.py and add the following code:

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()
    hospital_name = models.CharField(max_length=200)

    def __str__(self):
        return f"{self.first_name} {self.last_name} ({self.specialty})"
3. Register the model in the admin
To be able to manage the doctor profiles via Django admin, register the model. Open profiles/admin.py and add the 
following code:

python
from django.contrib import admin
from .models import Doctor

admin.site.register(Doctor)
4. Set up the app in settings.py
In doctor_crud/settings.py, add the profiles app to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    # other apps
    'profiles',
]
5. Create the database tables
Run the following commands to create the necessary database tables for the Doctor model:

bash
python manage.py makemigrations profiles
python manage.py migrate
6. Create CRUD views and templates
Now, we'll create views for each CRUD operation and define the URLs for them.

Create the views in profiles/views.py:
python
from django.shortcuts import render, redirect, get_object_or_404
from .models import Doctor
from .forms import DoctorForm

# Create View
def create_doctor(request):
    if request.method == "POST":
        form = DoctorForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('doctor_list')
    else:
        form = DoctorForm()
    return render(request, 'profiles/create_doctor.html', {'form': form})

# Read (List) View
def doctor_list(request):
    doctors = Doctor.objects.all()
    return render(request, 'profiles/doctor_list.html', {'doctors': doctors})

# Update View
def update_doctor(request, pk):
    doctor = get_object_or_404(Doctor, pk=pk)
    if request.method == "POST":
        form = DoctorForm(request.POST, instance=doctor)
        if form.is_valid():
            form.save()
            return redirect('doctor_list')
    else:
        form = DoctorForm(instance=doctor)
    return render(request, 'profiles/update_doctor.html', {'form': form})

# Delete View
def delete_doctor(request, pk):
    doctor = get_object_or_404(Doctor, pk=pk)
    if request.method == "POST":
        doctor.delete()
        return redirect('doctor_list')
    return render(request, 'profiles/delete_doctor.html', {'doctor': doctor})
Create the form in profiles/forms.py:
python
from django import forms
from .models import Doctor

class DoctorForm(forms.ModelForm):
    class Meta:
        model = Doctor
        fields = ['first_name', 'last_name', 'specialty', 'phone_number', 'email', 'hospital_name']
7. Create templates for each CRUD operation
Next, create HTML templates for each view in the profiles/templates/profiles/ directory.

create_doctor.html:
html
<!DOCTYPE html>
<html>
<head>
    <title>Create Doctor</title>
</head>
<body>
    <h2>Create a New Doctor</h2>
    <form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Create Doctor</button>
    </form>
    <a href="{% url 'doctor_list' %}">Back to Doctor List</a>
</body>
</html>
doctor_list.html:
html
<!DOCTYPE html>
<html>
<head>
    <title>Doctor List</title>
</head>
<body>
    <h2>Doctor List</h2>
    <table border="1">
        <tr>
            <th>Name</th>
            <th>Specialty</th>
            <th>Actions</th>
        </tr>
        {% for doctor in doctors %}
        <tr>
            <td>{{ doctor.first_name }} {{ doctor.last_name }}</td>
            <td>{{ doctor.specialty }}</td>
            <td>
                <a href="{% url 'update_doctor' doctor.pk %}">Edit</a> |
                <a href="{% url 'delete_doctor' doctor.pk %}">Delete</a>
            </td>
        </tr>
        {% endfor %}
    </table>
    <a href="{% url 'create_doctor' %}">Create New Doctor</a>
</body>
</html>
update_doctor.html:
html
<!DOCTYPE html>
<html>
<head>
    <title>Update Doctor</title>
</head>
<body>
    <h2>Update Doctor</h2>
    <form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Update Doctor</button>
    </form>
    <a href="{% url 'doctor_list' %}">Back to Doctor List</a>
</body>
</html>
delete_doctor.html:
html
<!DOCTYPE html>
<html>
<head>
    <title>Delete Doctor</title>
</head>
<body>
    <h2>Are you sure you want to delete {{ doctor.first_name }} {{ doctor.last_name }}?</h2>
    <form method="post">
        {% csrf_token %}
        <button type="submit">Yes, Delete</button>
    </form>
    <a href="{% url 'doctor_list' %}">Cancel</a>
</body>
</html>
8. Define URLs for the views
In profiles/urls.py, define the URLs for each CRUD operation:

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.doctor_list, name='doctor_list'),
    path('create/', views.create_doctor, name='create_doctor'),
    path('update/<int:pk>/', views.update_doctor, name='update_doctor'),
    path('delete/<int:pk>/', views.delete_doctor, name='delete_doctor'),
]
In doctor_crud/urls.py, include the profiles URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('profiles.urls')),
]
9. Run the server
Finally, run the Django development server to see the application in action:

bash
python manage.py runserver
Visit http://127.0.0.1:8000/ in your browser. You will be able to perform CRUD operations on the doctor profiles.

13. Django Forms and Authentication
Theory:
 Using Django’s built-in form handling.

Django's built-in form handling system provides a powerful way to manage form data, whether it's used for creating, 
editing, or validating data. Here's a basic guide on how to use Django's form handling features:

1. Creating a Form with Django
Django provides two ways to handle forms:

Django Forms (using django.forms.Form): For basic form handling.
Model Forms (using django.forms.ModelForm): Tightly integrates with Django models for saving data directly to the database.
We'll cover both, starting with a basic Django form.

Step 1: Install Django (if you haven't already)
bash
pip install django
Step 2: Create a Simple Django Form
First, we will create a basic form class using django.forms.Form.

Example: Creating a form for user input
Define the form class (forms.py):
python
from django import forms

class ContactForm(forms.Form):
    name = forms.CharField(max_length=100)
    email = forms.EmailField()
    message = forms.CharField(widget=forms.Textarea)
CharField is used for simple text input.
EmailField is used for validating email format.
Textarea widget is used for large text input (e.g., a message).
Step 3: Create a View to Handle the Form
Define a view to process the form data (views.py):
python
from django.shortcuts import render
from .forms import ContactForm

def contact_view(request):
    if request.method == "POST":
        form = ContactForm(request.POST)
        if form.is_valid():  # Check if form data is valid
            name = form.cleaned_data['name']
            email = form.cleaned_data['email']
            message = form.cleaned_data['message']
            # Process the data, save to the database, or send an email
            return render(request, 'thank_you.html', {'name': name})
    else:
        form = ContactForm()

    return render(request, 'contact.html', {'form': form})
request.method == "POST" checks if the form is being submitted.
form.is_valid() checks if the form data is valid.
form.cleaned_data contains the validated form data.
Step 4: Create Templates to Render the Form
Create HTML templates:
Contact Form Template (contact.html):
html
<form method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Submit</button>
</form>
Thank You Template (thank_you.html):
html
<h1>Thank you, {{ name }}! Your message has been received.</h1>
{{ form.as_p }} renders the form fields inside <p> tags.
{% csrf_token %} is important for protecting against cross-site request forgery (CSRF) attacks.
Step 5: Set up URLs
Add URL pattern (urls.py):
python
from django.urls import path
from . import views

urlpatterns = [
    path('contact/', views.contact_view, name='contact'),
]
Step 6: Running the Server
Make sure Django is set up and run the development server:

bash
python manage.py runserver
Now, you can visit the form at http://127.0.0.1:8000/contact/.

2. Using Model Forms for Saving Data
If your form is related to a Django model, you can use ModelForm to automatically generate a form based on a model.

Example: Model Form to Create a Contact Entry
Define a Model (models.py):
python
from django.db import models

class Contact(models.Model):
    name = models.CharField(max_length=100)
    email = models.EmailField()
    message = models.TextField()

    def __str__(self):
        return self.name
Create a Model Form (forms.py):
python
from django import forms
from .models import Contact

class ContactModelForm(forms.ModelForm):
    class Meta:
        model = Contact
        fields = ['name', 'email', 'message']
Modify the View (views.py):
python
from django.shortcuts import render
from .forms import ContactModelForm

def contact_view(request):
    if request.method == "POST":
        form = ContactModelForm(request.POST)
        if form.is_valid():
            form.save()  # Saves the data to the database
            return render(request, 'thank_you.html', {'name': form.cleaned_data['name']})
    else:
        form = ContactModelForm()

    return render(request, 'contact.html', {'form': form})
In this example, we are using a ModelForm that automatically handles data validation and saving to the database.

3. Form Validation and Custom Validation
You can add custom validation logic in both normal forms and model forms. Here's an example of custom validation:

python
class ContactForm(forms.Form):
    name = forms.CharField(max_length=100)
    email = forms.EmailField()
    message = forms.CharField(widget=forms.Textarea)

    def clean_message(self):
        message = self.cleaned_data.get('message')
        if "badword" in message:
            raise forms.ValidationError("Message contains inappropriate language.")
        return message
clean_<field_name> methods are used to perform custom validation for each form field.

 Implementing Django’s authentication system (sign up, login, logout, password
management).

To implement Django's authentication system with features like sign up, login, logout, and password management, you 
need to configure and use Django's built-in authentication views and models. Below is a step-by-step guide to 
implementing these features:

1. Set Up a Django Project
If you haven't already created a Django project, start by creating one.

bash
django-admin startproject myproject
cd myproject
python manage.py startapp accounts
2. Configure settings.py
In the settings.py file of your project, ensure the following settings are configured:

Add accounts to the INSTALLED_APPS section.
Set up the default authentication backends if necessary.
python
# settings.py

INSTALLED_APPS = [
    ...
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'accounts',  # Add your accounts app here
]

# Optionally, configure login redirects
LOGIN_REDIRECT_URL = '/'  # Redirect to homepage after login
LOGOUT_REDIRECT_URL = '/'  # Redirect to homepage after logout
3. Create URLs for Authentication Views
In the accounts/urls.py file (create this file if it doesn't exist), set up URLs for handling authentication-related views.

python
# accounts/urls.py
from django.urls import path
from django.contrib.auth import views as auth_views
from . import views

urlpatterns = [
    path('signup/', views.signup, name='signup'),  # Sign up URL
    path('login/', auth_views.LoginView.as_view(), name='login'),  # Login URL
    path('logout/', auth_views.LogoutView.as_view(), name='logout'),  # Logout URL
    path('password_reset/', auth_views.PasswordResetView.as_view(), name='password_reset'),
    path('password_reset_done/', auth_views.PasswordResetDoneView.as_view(), name='password_reset_done'),
    path('password_reset_confirm/<uidb64>/<token>/', auth_views.PasswordResetConfirmView.as_view(), 
name='password_reset_confirm'),
    path('password_reset_complete/', auth_views.PasswordResetCompleteView.as_view(), name='password_reset_complete'),
]
4. Create Views for Sign Up
The sign-up page requires a view where users can create an account by providing their username, email, and password.

In accounts/views.py, add the signup view:

python
# accounts/views.py
from django.shortcuts import render, redirect
from django.contrib.auth.forms import UserCreationForm
from django.contrib import messages

def signup(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Your account has been created successfully!')
            return redirect('login')
    else:
        form = UserCreationForm()
    return render(request, 'accounts/signup.html', {'form': form})
5. Create Templates
Create HTML templates for each view. These templates should be placed in the templates/accounts/ directory.

Signup Template (signup.html)
html
<!-- templates/accounts/signup.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Sign Up</title>
</head>
<body>
    <h2>Sign Up</h2>
    <form method="POST">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Sign Up</button>
    </form>
</body>
</html>
Login Template (login.html) (Django provides a default login template, but you can customize it):
html
<!-- templates/registration/login.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Login</title>
</head>
<body>
    <h2>Login</h2>
    <form method="POST">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Login</button>
    </form>
</body>
</html>
Logout Template (logout.html) (Optional for logout, but the default logout view works fine):
html
Copy code
<!-- templates/registration/logged_out.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Logged Out</title>
</head>
<body>
    <h2>You have been logged out successfully.</h2>
</body>
</html>
6. Password Management
Django's authentication system already provides views for password management, such as resetting, confirming, and 
completing the password reset. You don’t need to implement these manually, as Django's built-in views handle them. 
However, you can customize the templates if needed.

Password Reset Template (password_reset.html)
html
<!-- templates/registration/password_reset_form.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Password Reset</title>
</head>
<body>
    <h2>Reset Your Password</h2>
    <form method="POST">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Send Reset Link</button>
    </form>
</body>
</html>
You should create the following templates for password reset flow:

password_reset_done.html
password_reset_confirm.html
password_reset_complete.html
These templates are part of Django's default implementation. You can find more about customizing these views and 
templates in the Django documentation.

7. Include Authentication URLs in the Project URL Configuration
In the urls.py of your project, include the accounts.urls to wire everything together.

python
# myproject/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('accounts.urls')),  # Include accounts URLs
]
8. Migrate the Database
Make sure to apply the migrations for the authentication system and any other models.

bash
python manage.py migrate
9. Run the Development Server
Start the Django development server to check if everything works correctly.

bash
python manage.py runserver
10. Test the Authentication System
Navigate to /accounts/signup/ to register a new user.
After signing up, you can log in at /accounts/login/.
Logout using /accounts/logout/.
Test password reset by visiting /accounts/password_reset/.

Lab:
 Create a Django project for user registration and login functionality.

To create a Django project with user registration and login functionality, follow these steps:

Step 1: Install Django
First, ensure that you have Python installed. You can then install Django using pip:

bash
pip install django
Step 2: Create a Django Project
Now, create a new Django project. Open your terminal and navigate to the folder where you want to create the project, 
then run:

bash
django-admin startproject user_auth
cd user_auth
This will create the main project directory (user_auth) with the necessary files.

Step 3: Create a Django App for User Authentication
Next, create a Django app where you'll handle user registration and login functionality:

bash
python manage.py startapp accounts
Now, you'll have an app called accounts where you'll put your user management logic.

Step 4: Define the URLs for the accounts App
In the accounts app directory, create a file named urls.py. This will contain the URL patterns for registration and login.

python
# accounts/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('register/', views.register, name='register'),
    path('login/', views.login_view, name='login'),
    path('logout/', views.logout_view, name='logout'),
]
Step 5: Add the accounts App to INSTALLED_APPS
In user_auth/settings.py, add the accounts app to the INSTALLED_APPS list:

python
# user_auth/settings.py

INSTALLED_APPS = [
    ...
    'accounts',
    'django.contrib.auth',  # This is for user authentication
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
]
Step 6: Implement Views for Registration, Login, and Logout
In accounts/views.py, define the views for user registration, login, and logout:

python
# accounts/views.py

from django.shortcuts import render, redirect
from django.contrib.auth.forms import UserCreationForm, AuthenticationForm
from django.contrib.auth import login, logout
from django.contrib import messages
from django.contrib.auth.decorators import login_required

# User Registration View
def register(request):
    if request.method == 'POST':
        form = UserCreationForm(request.POST)
        if form.is_valid():
            form.save()
            username = form.cleaned_data.get('username')
            messages.success(request, f'Account created for {username}!')
            return redirect('login')
    else:
        form = UserCreationForm()
    return render(request, 'accounts/register.html', {'form': form})

# User Login View
def login_view(request):
    if request.method == 'POST':
        form = AuthenticationForm(data=request.POST)
        if form.is_valid():
            user = form.get_user()
            login(request, user)
            messages.success(request, f'You are now logged in as {user.username}!')
            return redirect('home')
    else:
        form = AuthenticationForm()
    return render(request, 'accounts/login.html', {'form': form})

# User Logout View
@login_required
def logout_view(request):
    logout(request)
    messages.info(request, "You have successfully logged out.")
    return redirect('login')
Step 7: Create Templates for Registration and Login
Create a templates folder in the accounts app directory to store HTML templates. Inside this folder, create the 
following templates:

register.html
html
<!-- accounts/templates/accounts/register.html -->

{% extends "base_generic.html" %}

{% block content %}
  <h2>Register</h2>
  <form method="POST">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Register</button>
  </form>
{% endblock %}
login.html
html
<!-- accounts/templates/accounts/login.html -->

{% extends "base_generic.html" %}

{% block content %}
  <h2>Login</h2>
  <form method="POST">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Login</button>
  </form>
{% endblock %}
Step 8: Set up the Base Template
Create a base_generic.html file in the root templates directory for your base layout:

html
<!-- templates/base_generic.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Django User Authentication</title>
</head>
<body>
    <nav>
        <a href="{% url 'register' %}">Register</a>
        <a href="{% url 'login' %}">Login</a>
        <a href="{% url 'logout' %}">Logout</a>
    </nav>

    <div>
        {% block content %}
        {% endblock %}
    </div>
</body>
</html>
Step 9: Configure URLs in the Project
Now, link the accounts app URLs to the project's main URL configuration. In user_auth/urls.py, add:

python
# user_auth/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('accounts.urls')),
]
Step 10: Migrate the Database
Run the following commands to set up the database and apply migrations for the authentication system:

bash
python manage.py migrate
Step 11: Create a Superuser
Create a superuser to access the Django admin and manage users:

bash
python manage.py createsuperuser
Follow the prompts to set up the superuser account.

Step 12: Run the Server
Finally, start the Django development server:

bash
python manage.py runserver
Step 13: Test the Registration and Login
Go to http://127.0.0.1:8000/accounts/register/ to register a new user.
After registering, you can log in by visiting http://127.0.0.1:8000/accounts/login/.
You will be logged in and redirected accordingly.
Optional: Customizing the User Model
If you need to store extra information about users (e.g., profile information), you can extend the User model by 
creating a custom model or using Django's AbstractUser.

Practical Example: 13) Write a Django project to handle user sign up, login, password reset, and profile updates.

To create a Django project to handle user sign up, login, password reset, and profile updates, you will need to follow 
several steps. Below is a guide to help you build this functionality from scratch.

Prerequisites:
Python installed (preferably Python 3.8+)
Django installed (pip install django)
A PostgreSQL or SQLite database (SQLite is the default)
Step 1: Create a Django Project
Create a new directory for the project:

bash
mkdir user_management
cd user_management
Start a Django project:

bash
django-admin startproject user_management_project .
Create a new Django app to handle the authentication functionality:

bash
python manage.py startapp accounts
Add accounts to INSTALLED_APPS in user_management_project/settings.py:

python
INSTALLED_APPS = [
    # other apps
    'accounts',
]
Step 2: Configure User Model
In this example, we'll use Django's built-in User model to manage users. However, for more advanced projects, you might 
want to create a custom user model.

In accounts/models.py, we won't need to create a new model since Django already provides the User model. But if you want 
to customize the user, you can subclass AbstractUser:

python
from django.contrib.auth.models import AbstractUser

class CustomUser(AbstractUser):
    # You can add additional fields here if needed
    pass
If you use a custom model, remember to update the AUTH_USER_MODEL in settings.py:

python
AUTH_USER_MODEL = 'accounts.CustomUser'
For now, we'll use the default Django User model.

Step 3: Create Views for Sign Up, Login, Password Reset, and Profile Updates
In accounts/views.py, create views to handle user sign up, login, password reset, and profile updates.

1. User Sign Up
First, create a form for user registration in forms.py under the accounts app:

python
# accounts/forms.py
from django import forms
from django.contrib.auth.models import User

class UserSignupForm(forms.ModelForm):
    password = forms.CharField(widget=forms.PasswordInput)
    confirm_password = forms.CharField(widget=forms.PasswordInput)

    class Meta:
        model = User
        fields = ['username', 'email']

    def clean(self):
        cleaned_data = super().clean()
        password = cleaned_data.get("password")
        confirm_password = cleaned_data.get("confirm_password")

        if password != confirm_password:
            raise forms.ValidationError("Passwords do not match.")
Now, create the view to handle user registration:

python
# accounts/views.py
from django.shortcuts import render, redirect
from django.contrib.auth import login
from django.contrib.auth.forms import AuthenticationForm
from .forms import UserSignupForm

def signup_view(request):
    if request.method == 'POST':
        form = UserSignupForm(request.POST)
        if form.is_valid():
            user = form.save(commit=False)
            user.set_password(form.cleaned_data['password'])
            user.save()
            login(request, user)
            return redirect('profile')
    else:
        form = UserSignupForm()
    return render(request, 'accounts/signup.html', {'form': form})
2. User Login
Django provides an AuthenticationForm for user login. We'll use it in our view:

python
# accounts/views.py
from django.contrib.auth import authenticate, login
from django.shortcuts import render, redirect
from .forms import UserSignupForm

def login_view(request):
    if request.method == 'POST':
        form = AuthenticationForm(request, data=request.POST)
        if form.is_valid():
            username = form.cleaned_data.get('username')
            password = form.cleaned_data.get('password')
            user = authenticate(username=username, password=password)
            if user is not None:
                login(request, user)
                return redirect('profile')
    else:
        form = AuthenticationForm()
    return render(request, 'accounts/login.html', {'form': form})
3. Password Reset
Django provides built-in views for password reset. You just need to add the following URLs in your project.

python
# accounts/urls.py
from django.urls import path
from django.contrib.auth import views as auth_views

urlpatterns = [
    path('password_reset/', auth_views.PasswordResetView.as_view(), name='password_reset'),
    path('password_reset_done/', auth_views.PasswordResetDoneView.as_view(), name='password_reset_done'),
    path('password_reset_confirm/<uidb64>/<token>/', auth_views.PasswordResetConfirmView.as_view(), 
name='password_reset_confirm'),
    path('password_reset_complete/', auth_views.PasswordResetCompleteView.as_view(), name='password_reset_complete'),
]
These views will handle sending the password reset emails and resetting the password when the user follows the link in 
the email.

4. Profile Update
Create a form for users to update their profile:

python
# accounts/forms.py
from django import forms
from django.contrib.auth.models import User

class UserProfileForm(forms.ModelForm):
    class Meta:
        model = User
        fields = ['first_name', 'last_name', 'email']
Create a view to update the user profile:

python
# accounts/views.py
from django.contrib.auth.decorators import login_required
from django.shortcuts import render, redirect
from .forms import UserProfileForm

@login_required
def profile_update(request):
    if request.method == 'POST':
        form = UserProfileForm(request.POST, instance=request.user)
        if form.is_valid():
            form.save()
            return redirect('profile')
    else:
        form = UserProfileForm(instance=request.user)
    return render(request, 'accounts/profile_update.html', {'form': form})
Step 4: Set Up URLs
You need to define the URL patterns for these views.

Create a urls.py file inside the accounts app:
python
# accounts/urls.py
from django.urls import path
from .views import signup_view, login_view, profile_update
from django.contrib.auth import views as auth_views

urlpatterns = [
    path('signup/', signup_view, name='signup'),
    path('login/', login_view, name='login'),
    path('profile/', profile_update, name='profile'),
]
Include these URLs in the main urls.py of the project:
python
# user_management_project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('accounts.urls')),
]
Step 5: Create HTML Templates
Create basic templates for each of the views:

signup.html
login.html
profile_update.html
For example, the signup.html template might look like this:

html
<!-- accounts/templates/accounts/signup.html -->
<!DOCTYPE html>
<html>
<head>
    <title>Sign Up</title>
</head>
<body>
    <h2>Sign Up</h2>
    <form method="POST">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Sign Up</button>
    </form>
</body>
</html>
Repeat similar steps for the login.html and profile_update.html.

Step 6: Test the Application
Run the server:

bash
python manage.py runserver
Access the URLs:

/accounts/signup/ to sign up a user.
/accounts/login/ to log in.
/accounts/profile/ to update the profile.
This will provide basic functionality for user sign-up, login, password reset, and profile updates.

Step 7: Set Up Email Backend for Password Reset
To enable the password reset functionality, you need to configure the email backend in settings.py. For development, 
you can use the console backend to simulate sending emails:

python
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
For production, you would configure it to use an actual SMTP server.

14. CRUD Operations using AJAX
Theory:
 Using AJAX for making asynchronous requests to the server without reloading the page.

AJAX (Asynchronous JavaScript and XML) is a technique used in web development to make asynchronous requests to the 
server without refreshing the entire page. This allows you to update parts of a web page dynamically with data from 
the server. It helps improve the user experience by enabling web pages to load faster and function more smoothly.

Here’s a simple example of how to use AJAX in a web page to fetch data from the server asynchronously:

Example: Making an AJAX Request
HTML - Create a simple button to trigger the request.
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AJAX Example</title>
    <script src="script.js" defer></script>
</head>
<body>
    <h1>AJAX Example</h1>
    <button id="loadDataBtn">Load Data</button>
    <div id="result"></div>
</body>
</html>
JavaScript - Create the AJAX function to make the request and handle the response. This example uses the 
XMLHttpRequest object to perform the AJAX request.
javascript
document.getElementById('loadDataBtn').addEventListener('click', function() {
    // Create a new XMLHttpRequest object
    var xhr = new XMLHttpRequest();

    // Configure it: GET-request for the URL /data.json
    xhr.open('GET', 'data.json', true);

    // Set up the function to handle the response
    xhr.onload = function() {
        if (xhr.status == 200) {
            // If request is successful, update the page content
            document.getElementById('result').innerHTML = xhr.responseText;
        } else {
            // Handle error if request fails
            document.getElementById('result').innerHTML = "Error loading data.";
        }
    };

    // Send the request
    xhr.send();
});
JSON Data (Optional) - If you're fetching data from a JSON file on the server (data.json in this example), it might look 
like this:
json
{
    "message": "Hello, this is the data from the server!"
}
Explanation:
HTML: Contains a button that triggers the AJAX request when clicked and a div element (#result) where the response 
will be displayed.

JavaScript:

When the button is clicked, an XMLHttpRequest is created to fetch data.json from the server.
The xhr.onload function is triggered when the server responds. If the status is 200 (OK), the content of the #result 
div is updated with the server's response (xhr.responseText).
The xhr.send() method sends the request to the server.
Alternative: Using Fetch API (Modern Approach)
While XMLHttpRequest is still widely used, the modern fetch() API provides a simpler, promise-based approach to AJAX 
requests.

javascript
document.getElementById('loadDataBtn').addEventListener('click', function() {
    // Fetch data from the server
    fetch('data.json')
        .then(response => response.json())  // Parse JSON response
        .then(data => {
            // Update the page with the fetched data
            document.getElementById('result').innerHTML = data.message;
        })
        .catch(error => {
            // Handle error
            document.getElementById('result').innerHTML = "Error loading data.";
        });
});
Advantages of AJAX:
No Page Reload: You can request and display new data without reloading the entire page, which improves user experience.
Asynchronous: The request is made asynchronously, meaning the page continues to function while waiting for a response.
Better Performance: Only necessary data is loaded, reducing the amount of data transferred and speeding up the application.
AJAX is a powerful tool for creating dynamic, interactive web pages, and it's widely used in modern web applications.

Lab:
 Implement AJAX in a Django project for performing CRUD operations.

Implementing AJAX in a Django project to perform CRUD (Create, Read, Update, Delete) operations can significantly 
improve the user experience by making the application more interactive without requiring page reloads. Below is a 
step-by-step guide on how to implement AJAX for CRUD operations in Django.

Step 1: Setup Django Project
Create a Django project (if you don’t have one already):

bash
django-admin startproject myproject
cd myproject
python manage.py startapp myapp
Install jQuery (or use vanilla JavaScript for AJAX):

In your templates directory, include the jQuery library (for easier AJAX integration). You can use a CDN in the base 
template (like base.html).

html
<!-- base.html -->
<head>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
Step 2: Create Models
Define a model to perform CRUD operations. For this example, we'll use a simple Item model.

python
# myapp/models.py
from django.db import models

class Item(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField()

    def __str__(self):
        return self.name
Run the migrations to create the database table for the Item model:

bash
python manage.py makemigrations
python manage.py migrate
Step 3: Create Views and Templates for CRUD
We will create views to handle creating, updating, reading, and deleting Item instances.

Views
python
# myapp/views.py
from django.http import JsonResponse
from django.shortcuts import render, redirect
from .models import Item
from .forms import ItemForm

# Display all items
def item_list(request):
    items = Item.objects.all()
    return render(request, 'item_list.html', {'items': items})

# Create an item
def item_create(request):
    if request.method == 'POST':
        name = request.POST.get('name')
        description = request.POST.get('description')
        item = Item.objects.create(name=name, description=description)
        return JsonResponse({'id': item.id, 'name': item.name, 'description': item.description})
    return render(request, 'item_create.html')

# Update an item
def item_update(request, item_id):
    item = Item.objects.get(id=item_id)
    if request.method == 'POST':
        item.name = request.POST.get('name')
        item.description = request.POST.get('description')
        item.save()
        return JsonResponse({'id': item.id, 'name': item.name, 'description': item.description})
    return render(request, 'item_update.html', {'item': item})

# Delete an item
def item_delete(request, item_id):
    item = Item.objects.get(id=item_id)
    item.delete()
    return JsonResponse({'success': True})
URLs
Define URLs for the CRUD operations.

python
# myapp/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.item_list, name='item_list'),
    path('create/', views.item_create, name='item_create'),
    path('update/<int:item_id>/', views.item_update, name='item_update'),
    path('delete/<int:item_id>/', views.item_delete, name='item_delete'),
]
Templates
Create the necessary templates for rendering the list and forms.

item_list.html (Displays the list of items)
html
<!-- item_list.html -->
{% for item in items %}
    <div id="item_{{ item.id }}">
        <p>{{ item.name }}: {{ item.description }}</p>
        <button onclick="deleteItem({{ item.id }})">Delete</button>
        <button onclick="editItem({{ item.id }})">Edit</button>
    </div>
{% endfor %}
<button onclick="createItem()">Create New Item</button>
item_create.html (Form for creating a new item)
html
<!-- item_create.html -->
<form id="create_form">
    <input type="text" id="name" placeholder="Item name">
    <textarea id="description" placeholder="Description"></textarea>
    <button type="button" onclick="submitCreateForm()">Create</button>
</form>

<script>
    function submitCreateForm() {
        const name = document.getElementById("name").value;
        const description = document.getElementById("description").value;

        $.ajax({
            url: "/create/",
            method: "POST",
            data: {
                name: name,
                description: description,
                csrfmiddlewaretoken: '{{ csrf_token }}'
            },
            success: function(response) {
                // Append the new item to the list
                $('#item-list').append('<div id="item_' + response.id + '">' + response.name + ': ' + 
response.description + '</div>');
            }
        });
    }
</script>
item_update.html (Form for updating an item)
html
<!-- item_update.html -->
<form id="update_form">
    <input type="text" id="name" value="{{ item.name }}" placeholder="Item name">
    <textarea id="description" placeholder="Description">{{ item.description }}</textarea>
    <button type="button" onclick="submitUpdateForm({{ item.id }})">Update</button>
</form>

<script>
    function submitUpdateForm(item_id) {
        const name = document.getElementById("name").value;
        const description = document.getElementById("description").value;

        $.ajax({
            url: "/update/" + item_id + "/",
            method: "POST",
            data: {
                name: name,
                description: description,
                csrfmiddlewaretoken: '{{ csrf_token }}'
            },
            success: function(response) {
                $('#item_' + response.id).html(response.name + ': ' + response.description);
            }
        });
    }
</script>
Delete functionality via AJAX:
html
<script>
    function deleteItem(item_id) {
        $.ajax({
            url: "/delete/" + item_id + "/",
            method: "POST",
            data: {
                csrfmiddlewaretoken: '{{ csrf_token }}'
            },
            success: function(response) {
                $('#item_' + item_id).remove();  // Remove item from list
            }
        });
    }
</script>
Step 4: Add CSRF Token to the Form
Since Django uses CSRF protection, we need to ensure that the CSRF token is included in AJAX POST requests. In the 
templates where AJAX forms are included, make sure to add {% csrf_token %} inside the form.

For example:

html
<form method="POST" id="create_form">
    {% csrf_token %}
    <input type="text" id="name" placeholder="Item name">
    <textarea id="description" placeholder="Description"></textarea>
    <button type="button" onclick="submitCreateForm()">Create</button>
</form>
Step 5: Run the Server
Make sure you’ve configured the project correctly, and then run the Django development server:

bash
python manage.py runserver
Visit http://127.0.0.1:8000/ to interact with your CRUD application, now with AJAX capabilities.

Practical Example: 14) Write a Django project that uses AJAX to add, edit, or delete doctor profiles without refreshing 
the page.

Sure! Below is a step-by-step guide to create a Django project that uses AJAX to add, edit, or delete doctor profiles 
without refreshing the page.

1. Create the Django Project and App
First, create the Django project and the app where you will implement this functionality.

bash
django-admin startproject doctor_profiles
cd doctor_profiles
python manage.py startapp doctors
2. Install jQuery
Django doesn't come with jQuery by default, so you need to include it in your HTML files to easily handle AJAX requests.

You can include jQuery by adding it to the base template. In your doctor_profiles/templates folder, create the base 
template:

html
<!-- doctor_profiles/templates/base_generic.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Profiles</title>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
</head>
<body>
    <div class="container">
        {% block content %}
        {% endblock %}
    </div>
</body>
</html>
3. Define the Model
Now, let's create the Doctor model. Open the models.py file in the doctors app:

python
# doctors/models.py
from django.db import models

class Doctor(models.Model):
    name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    contact_number = models.CharField(max_length=20)

    def __str__(self):
        return self.name
Run the migrations to create the table:

bash
python manage.py makemigrations
python manage.py migrate
4. Create Views
In the views.py file of the doctors app, define views for adding, editing, deleting, and retrieving doctor profiles.

python
# doctors/views.py
from django.http import JsonResponse
from django.shortcuts import render
from .models import Doctor
from .forms import DoctorForm

def doctor_list(request):
    doctors = Doctor.objects.all()
    return render(request, 'doctor_profiles/doctor_list.html', {'doctors': doctors})

def add_doctor(request):
    if request.method == "POST":
        name = request.POST.get('name')
        specialty = request.POST.get('specialty')
        contact_number = request.POST.get('contact_number')

        doctor = Doctor.objects.create(
            name=name,
            specialty=specialty,
            contact_number=contact_number
        )

        return JsonResponse({'id': doctor.id, 'name': doctor.name, 'specialty': doctor.specialty, 'contact_number': 
doctor.contact_number})

    return JsonResponse({'error': 'Invalid request'}, status=400)

def edit_doctor(request):
    if request.method == "POST":
        doctor_id = request.POST.get('id')
        name = request.POST.get('name')
        specialty = request.POST.get('specialty')
        contact_number = request.POST.get('contact_number')

        doctor = Doctor.objects.get(id=doctor_id)
        doctor.name = name
        doctor.specialty = specialty
        doctor.contact_number = contact_number
        doctor.save()

        return JsonResponse({'id': doctor.id, 'name': doctor.name, 'specialty': doctor.specialty, 'contact_number': 
doctor.contact_number})

    return JsonResponse({'error': 'Invalid request'}, status=400)

def delete_doctor(request):
    if request.method == "POST":
        doctor_id = request.POST.get('id')
        doctor = Doctor.objects.get(id=doctor_id)
        doctor.delete()
        return JsonResponse({'status': 'success'})

    return JsonResponse({'error': 'Invalid request'}, status=400)
5. Create Forms (Optional)
You can optionally create a form to handle input validation. In the forms.py file of the doctors app, create:

python
# doctors/forms.py
from django import forms
from .models import Doctor

class DoctorForm(forms.ModelForm):
    class Meta:
        model = Doctor
        fields = ['name', 'specialty', 'contact_number']
6. Create URLs
In the urls.py file of the doctors app, define URLs for the views:

python
# doctors/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.doctor_list, name='doctor_list'),
    path('add/', views.add_doctor, name='add_doctor'),
    path('edit/', views.edit_doctor, name='edit_doctor'),
    path('delete/', views.delete_doctor, name='delete_doctor'),
]
Then, include these URLs in your project's urls.py file:

python
# doctor_profiles/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('doctors/', include('doctors.urls')),
]
7. Create the Templates
Create the doctor_list.html template to display the list of doctors and provide options for adding, editing, and deleting:

html
<!-- doctor_profiles/templates/doctor_profiles/doctor_list.html -->
{% extends 'base_generic.html' %}

{% block content %}
<h1>Doctor Profiles</h1>

<table>
    <thead>
        <tr>
            <th>Name</th>
            <th>Specialty</th>
            <th>Contact Number</th>
            <th>Actions</th>
        </tr>
    </thead>
    <tbody id="doctor-list">
        {% for doctor in doctors %}
        <tr id="doctor-{{ doctor.id }}">
            <td>{{ doctor.name }}</td>
            <td>{{ doctor.specialty }}</td>
            <td>{{ doctor.contact_number }}</td>
            <td>
                <button onclick="editDoctor({{ doctor.id }})">Edit</button>
                <button onclick="deleteDoctor({{ doctor.id }})">Delete</button>
            </td>
        </tr>
        {% endfor %}
    </tbody>
</table>

<h2>Add New Doctor</h2>
<form id="add-doctor-form">
    <input type="text" name="name" placeholder="Name" required>
    <input type="text" name="specialty" placeholder="Specialty" required>
    <input type="text" name="contact_number" placeholder="Contact Number" required>
    <button type="submit">Add Doctor</button>
</form>

<script>
$(document).ready(function() {
    // Add doctor
    $('#add-doctor-form').on('submit', function(e) {
        e.preventDefault();

        $.ajax({
            url: '{% url "add_doctor" %}',
            type: 'POST',
            data: $(this).serialize(),
            success: function(response) {
                $('#doctor-list').append('<tr id="doctor-' + response.id + '"><td>' + response.name + 
'</td><td>' + response.specialty + '</td><td>' + response.contact_number + '</td><td><button 
onclick="editDoctor(' + response.id + ')">Edit</button><button onclick="deleteDoctor(' + response.id + ')
">Delete</button></td></tr>');
                $('#add-doctor-form')[0].reset();
            }
        });
    });

    // Edit doctor
    window.editDoctor = function(id) {
        const name = prompt("Enter new name:");
        const specialty = prompt("Enter new specialty:");
        const contactNumber = prompt("Enter new contact number:");

        $.ajax({
            url: '{% url "edit_doctor" %}',
            type: 'POST',
            data: {
                id: id,
                name: name,
                specialty: specialty,
                contact_number: contactNumber,
                csrfmiddlewaretoken: '{{ csrf_token }}'
            },
            success: function(response) {
                $('#doctor-' + id).html('<td>' + response.name + '</td><td>' + response.specialty + 
'</td><td>' + response.contact_number + '</td><td><button onclick="editDoctor(' + response.id + ')">Edit</button><button 
onclick="deleteDoctor(' + response.id + ')">Delete</button></td>');
            }
        });
    };

    // Delete doctor
    window.deleteDoctor = function(id) {
        if (confirm("Are you sure you want to delete this doctor?")) {
            $.ajax({
                url: '{% url "delete_doctor" %}',
                type: 'POST',
                data: {
                    id: id,
                    csrfmiddlewaretoken: '{{ csrf_token }}'
                },
                success: function(response) {
                    $('#doctor-' + id).remove();
                }
            });
        }
    };
});
</script>
{% endblock %}
8. Run the Project
Finally, run your Django project:

bash
python manage.py runserver

15. Customizing the Django Admin Panel
Theory:
 Techniques for customizing the Django admin panel.

Customizing the Django admin panel can greatly enhance its functionality and make it more user-friendly. Here are several 
techniques you can use to customize the Django admin panel:

1. Customizing ModelAdmin
Django's ModelAdmin class allows you to customize how a model is displayed in the admin interface. You can override 
various options to control the form, list display, and filtering for each model.

Display Fields in List View: Use the list_display attribute to define which fields should appear in the list view.

python
from django.contrib import admin
from .models import Book

class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'published_date', 'price')

admin.site.register(Book, BookAdmin)
Adding Search Fields: To enable search functionality in the admin panel, use search_fields.

python
class BookAdmin(admin.ModelAdmin):
    search_fields = ['title', 'author__name']
Filtering List View: Use list_filter to add filters in the sidebar.

python
class BookAdmin(admin.ModelAdmin):
    list_filter = ('genre', 'published_date')
Editable Fields in List View: The list_editable attribute allows editing fields directly from the list view.

python
class BookAdmin(admin.ModelAdmin):
    list_display = ('title', 'author', 'price')
    list_editable = ('price',)
2. Customizing the Form
You can control how forms appear in the admin interface by customizing the ModelForm and linking it with ModelAdmin.

Custom ModelForm: If you need to customize the form fields, for example by adding custom validation or changing the 
widgets, you can define a custom form and link it to your ModelAdmin.

python
from django import forms
from .models import Book

class BookForm(forms.ModelForm):
    class Meta:
        model = Book
        fields = '__all__'
    def clean_price(self):
        price = self.cleaned_data['price']
        if price <= 0:
            raise forms.ValidationError("Price must be positive.")
        return price

class BookAdmin(admin.ModelAdmin):
    form = BookForm

admin.site.register(Book, BookAdmin)
3. Customizing the Admin Template
Django allows you to override admin templates to change the look and feel or add custom HTML elements.

Overriding Admin Templates: You can override the default templates used in the Django admin by placing custom HTML files 
in the templates/admin/ directory of your app. For example, if you want to override the change form template for a model:

markdown
myapp/
  templates/
    admin/
      change_form.html
Then, you can modify the change_form.html template to include custom HTML or JavaScript.

4. Inline Models
You can display related models as inline forms directly within the model’s admin page, which is useful for editing 
relationships like ForeignKey or ManyToMany fields.

python
from django.contrib import admin
from .models import Author, Book

class BookInline(admin.TabularInline):
    model = Book
    extra = 1  # Number of empty forms to display by default

class AuthorAdmin(admin.ModelAdmin):
    inlines = [BookInline]

admin.site.register(Author, AuthorAdmin)
5. Custom Actions
You can add custom actions in the admin panel, such as bulk updates or custom reports. Define these actions using 
ModelAdmin.

python
def mark_books_as_published(modeladmin, request, queryset):
    queryset.update(status='published')

mark_books_as_published.short_description = "Mark selected books as published"

class BookAdmin(admin.ModelAdmin):
    actions = [mark_books_as_published]

admin.site.register(Book, BookAdmin)
6. Adding Custom Views
Django allows you to add custom views to the admin panel. You can create custom views that are tied to specific URLs 
and then add them to the admin menu.

python
from django.urls import path
from django.http import HttpResponse
from django.contrib import admin

def custom_view(request):
    return HttpResponse('This is a custom admin view.')

class CustomAdmin(admin.ModelAdmin):
    def get_urls(self):
        urls = super().get_urls()
        custom_urls = [
            path('custom/', self.admin_site.admin_view(custom_view), name='custom_view'),
        ]
        return custom_urls + urls

admin.site.register(Book, CustomAdmin)
7. Custom Admin Actions with Forms
You can create custom actions that require input from the user, like generating reports or sending emails, by providing 
a form in the action.

python
from django import forms
from django.http import HttpResponse

class SendEmailForm(forms.Form):
    email_subject = forms.CharField(max_length=100)
    email_body = forms.CharField(widget=forms.Textarea)

def send_email_action(modeladmin, request, queryset):
    form = SendEmailForm(request.POST or None)
    if form.is_valid():
        # Send email logic
        return HttpResponse('Email sent successfully!')
    return HttpResponse(form.as_p())

send_email_action.short_description = "Send email to selected authors"

class BookAdmin(admin.ModelAdmin):
    actions = [send_email_action]

admin.site.register(Book, BookAdmin)
8. Customizing Admin List Filters
If you want to customize the list filter to show more specific choices, you can define a custom filter by subclassing 
admin.SimpleListFilter.

python
from django.contrib import admin
from .models import Book

class PriceRangeFilter(admin.SimpleListFilter):
    title = 'price range'
    parameter_name = 'price'

    def lookups(self, request, model_admin):
        return (
            ('low', 'Low (< 20)'),
            ('medium', 'Medium (20-50)'),
            ('high', 'High (> 50)'),
        )

    def queryset(self, request, queryset):
        if self.value() == 'low':
            return queryset.filter(price__lt=20)
        if self.value() == 'medium':
            return queryset.filter(price__gte=20, price__lte=50)
        if self.value() == 'high':
            return queryset.filter(price__gt=50)

class BookAdmin(admin.ModelAdmin):
    list_filter = (PriceRangeFilter,)

admin.site.register(Book, BookAdmin)
9. Customizing the Admin Interface with JavaScript
You can add custom JavaScript to improve the interactivity of the admin panel. For example, add date pickers, dynamic 
form fields, or AJAX.

python
class BookAdmin(admin.ModelAdmin):
    class Media:
        js = ('myapp/js/custom_admin.js',)

admin.site.register(Book, BookAdmin)
10. Permissions and Access Control
Customize the access level of admin users by overriding ModelAdmin methods like has_add_permission, 
has_change_permission, or has_delete_permission.

python
class BookAdmin(admin.ModelAdmin):
    def has_add_permission(self, request):
        return request.user.is_superuser  # Only allow superusers to add books

admin.site.register(Book, BookAdmin)
By utilizing these techniques, you can significantly improve the usability and functionality of the Django admin panel 
for your specific use case.

Lab:
 Customize the Django admin panel for better management of records.

Customizing the Django admin panel can greatly enhance the user experience for managing records. By default, Django 
provides a simple interface, but you can modify and enhance it to suit your application's needs. Below are some steps 
you can follow to customize the Django admin panel for better record management:

1. Registering Models in admin.py
First, ensure your models are registered in the admin.py file of your app to make them accessible through the Django 
admin interface.

python
# admin.py
from django.contrib import admin
from .models import MyModel

admin.site.register(MyModel)
2. Customizing the Admin Class
You can create a custom admin class to fine-tune the display, add search, filters, and more for your models.

python
# admin.py
from django.contrib import admin
from .models import MyModel

class MyModelAdmin(admin.ModelAdmin):
    list_display = ('field1', 'field2', 'field3')  # Fields to display in the list view
    list_filter = ('field1', 'field2')  # Filters to help narrow down results
    search_fields = ('field1', 'field2')  # Fields to search for
    ordering = ('-created_at',)  # Default ordering
    list_per_page = 20  # Records per page

admin.site.register(MyModel, MyModelAdmin)
3. Customizing Fieldsets for Better Organization
Fieldsets allow you to organize the fields in the form view by grouping them logically.

python
# admin.py
class MyModelAdmin(admin.ModelAdmin):
    list_display = ('field1', 'field2', 'field3')
    fieldsets = (
        (None, {
            'fields': ('field1', 'field2')
        }),
        ('Additional Information', {
            'fields': ('field3',),
            'classes': ('collapse',)  # Makes the section collapsible
        }),
    )

admin.site.register(MyModel, MyModelAdmin)
4. Inline Models for Related Data
If you have models that have a ForeignKey or a OneToMany relationship, you can use inline models to display related data 
on the same page.

python
from django.contrib import admin
from .models import ParentModel, ChildModel

class ChildModelInline(admin.StackedInline):  # or TabularInline for a different layout
    model = ChildModel
    extra = 1  # Number of empty forms to display by default

class ParentModelAdmin(admin.ModelAdmin):
    inlines = [ChildModelInline]

admin.site.register(ParentModel, ParentModelAdmin)
5. Customizing the Form
You can also customize the form displayed for your model by using a custom form class.

python
# forms.py
from django import forms
from .models import MyModel

class MyModelForm(forms.ModelForm):
    class Meta:
        model = MyModel
        fields = '__all__'

# admin.py
from django.contrib import admin
from .forms import MyModelForm
from .models import MyModel

class MyModelAdmin(admin.ModelAdmin):
    form = MyModelForm

admin.site.register(MyModel, MyModelAdmin)
6. Custom Actions for Bulk Operations
If you want to perform bulk actions (such as delete, mark as active/inactive, etc.), you can add custom actions in 
the admin interface.

python
# admin.py
from django.contrib import admin
from .models import MyModel

def make_active(modeladmin, request, queryset):
    queryset.update(status='active')

make_active.short_description = "Mark selected as active"

class MyModelAdmin(admin.ModelAdmin):
    list_display = ('field1', 'status')
    actions = [make_active]

admin.site.register(MyModel, MyModelAdmin)
7. Customizing the Admin Interface Style
To improve the visual presentation, you can add custom styles by overriding templates or adding your own CSS files.

You can override change_form.html, change_list.html, etc., or use ModelAdmin methods like get_form or get_fieldsets to 
customize the appearance.
For instance, adding custom CSS to change the appearance:

python
# admin.py
from django.contrib import admin
from django.utils.html import format_html
from .models import MyModel

class MyModelAdmin(admin.ModelAdmin):
    class Media:
        css = {
            'all': ('myapp/css/custom_admin.css',)
        }

admin.site.register(MyModel, MyModelAdmin)
8. Customizing the Admin Dashboard
If you want to create a custom dashboard or modify the existing one, you can do so by using third-party packages like 
Django Suit or Django Grappelli.

bash
pip install django-suit
Then, add it to your INSTALLED_APPS in settings.py:

python
Copy code
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'suit',  # Add this line
]
These packages allow you to create a more polished and user-friendly admin interface.

9. Adding Permission-based Access
You can also manage access permissions to various parts of the admin by overriding methods like has_add_permission, 
has_change_permission, and has_delete_permission.

python
class MyModelAdmin(admin.ModelAdmin):
    def has_change_permission(self, request, obj=None):
        # Only allow change if the user is staff
        return request.user.is_staff

admin.site.register(MyModel, MyModelAdmin)
10. Using list_display_links
You can make specific fields clickable for a more user-friendly experience.

python
class MyModelAdmin(admin.ModelAdmin):
    list_display = ('field1', 'field2', 'field3')
    list_display_links = ('field1', 'field2')  # Make these fields clickable

admin.site.register(MyModel, MyModelAdmin)
11. Customize Search
You can customize the search behavior by defining which fields should be used for the search in the search_fields 
attribute.

python
class MyModelAdmin(admin.ModelAdmin):
    search_fields = ['field1', 'field2']

admin.site.register(MyModel, MyModelAdmin)

Practical Example: 15) Write a Django project that customizes the admin panel to display more detailed doctor information 
(e.g., specialties, availability).

To customize the Django admin panel to display more detailed doctor information such as specialties and availability, 
we can follow a series of steps. These steps include creating the necessary models to hold doctor information, 
customizing the Django admin interface to present this information in a user-friendly manner, and ensuring that 
additional fields such as specialties and availability are managed and displayed effectively.

Step-by-Step Implementation
Create a New Django Project and App First, ensure that you have Django installed and create a new project.

bash
django-admin startproject doctor_management
cd doctor_management
python manage.py startapp doctors
Define Models

In your doctors app, edit the models.py file to define the necessary models for doctors, specialties, and availability. 
Here is a simple implementation:

python
# doctors/models.py

from django.db import models

class Specialty(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField()

    def __str__(self):
        return self.name

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    email = models.EmailField()
    phone_number = models.CharField(max_length=20)
    specialties = models.ManyToManyField(Specialty, related_name='doctors')
    bio = models.TextField()
    photo = models.ImageField(upload_to='doctor_photos/', blank=True, null=True)
    
    # Availability can be a more complex structure (i.e., a separate model)
    available_days = models.JSONField(default=list)  # Example: ["Monday", "Wednesday", "Friday"]
    available_times = models.JSONField(default=list)  # Example: ["9:00 AM - 12:00 PM"]

    def __str__(self):
        return f"{self.first_name} {self.last_name}"

Doctor: Represents a doctor with fields like name, email, phone, specialties, and availability.
Specialty: Represents a specialty, such as "Cardiology", "Dermatology", etc.
Availability: Stores the days and times a doctor is available.
Create and Apply Migrations

Run the following commands to create and apply the migrations for your models.

bash
python manage.py makemigrations
python manage.py migrate
Customize the Admin Panel

Next, we need to customize the admin panel to display these new fields and make them easier to manage.

Open the admin.py file in your doctors app and define a custom DoctorAdmin class.

python
# doctors/admin.py

from django.contrib import admin
from .models import Doctor, Specialty

class SpecialtyAdmin(admin.ModelAdmin):
    list_display = ('name', 'description')
    search_fields = ('name',)

class DoctorAdmin(admin.ModelAdmin):
    list_display = ('first_name', 'last_name', 'email', 'phone_number', 'display_specialties', 'display_availability')
    list_filter = ('specialties',)
    search_fields = ('first_name', 'last_name', 'email', 'phone_number')
    filter_horizontal = ('specialties',)  # Makes the Many-to-Many field easier to edit

    # Custom methods to display specialties and availability in the list view
    def display_specialties(self, obj):
        return ", ".join([specialty.name for specialty in obj.specialties.all()])
    display_specialties.short_description = 'Specialties'

    def display_availability(self, obj):
        return ", ".join([f"{day}: {time}" for day, time in zip(obj.available_days, obj.available_times)])
    display_availability.short_description = 'Availability'

    # Customizing the form to show more details in the edit view
    fieldsets = (
        (None, {
            'fields': ('first_name', 'last_name', 'email', 'phone_number', 'bio', 'photo')
        }),
        ('Specialties & Availability', {
            'fields': ('specialties', 'available_days', 'available_times')
        }),
    )

admin.site.register(Doctor, DoctorAdmin)
admin.site.register(Specialty, SpecialtyAdmin)
list_display: This is a custom method to show doctor information like their specialties and availability.
display_specialties: Displays the specialties of the doctor in the list view.
display_availability: Displays the doctor's availability in a readable format in the list view.
fieldsets: Defines how the form for the doctor should be organized.
Add Admin Interface for Doctor Availability

You can store the availability using a JSON field that includes days and time slots, as shown in the Doctor model. 
However, if you want to make it more user-friendly in the admin panel, you could create a custom widget to make the 
interface better. For simplicity, we are using JSONField to store availability directly as a list of days and time slots.

Register the Models and Admin Panel

In doctors/admin.py, ensure that both the Doctor and Specialty models are registered with the customized admin classes.

python
from django.contrib import admin
from .models import Doctor, Specialty

# Register your models here
admin.site.register(Doctor, DoctorAdmin)
admin.site.register(Specialty)
Add urls.py Configuration for Admin Panel

The admin panel is enabled by default, but make sure to include the following configuration in the urls.py of your project:

python
# doctor_management/urls.py

from django.contrib import admin
from django.urls import path

urlpatterns = [
    path('admin/', admin.site.urls),
    # Add other paths here
]
Static Files and Media

Ensure that the media files (e.g., doctor's photos) are properly handled by your Django app. In your project’s 
settings.py, add the following:

python
# doctor_management/settings.py

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Add this to your urlpatterns in urls.py to serve media files in development
from django.conf import settings
from django.conf.urls.static import static

urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)
Run the Development Server

Now that you’ve set everything up, run the server and navigate to the admin panel to manage doctors, their specialties, 
and availability.

bash
python manage.py runserver
Visit the Django admin at http://127.0.0.1:8000/admin/ and log in with the superuser credentials. You should be able to 
manage the doctors and their detailed information (e.g., specialties and availability) via the customized admin interface.

Summary
In this implementation, we've:

Created models for Doctor and Specialty, including fields for specialties and availability.
Customized the Django admin panel to display doctor details, specialties, and availability in a user-friendly manner.
Made the admin interface more efficient by customizing the display of relationships (like ManyToMany for specialties) 
and other data points.
You can extend this by adding more features, like appointment scheduling, detailed availability management, or using 
custom widgets for a more sophisticated interface for availability management.

16. Payment Integration Using Paytm
Theory:
 Introduction to integrating payment gateways (like Paytm) in Django projects.

Introduction to Integrating Payment Gateways (like Paytm) in Django Projects
Integrating a payment gateway into a Django project allows you to process online payments directly from your website or 
application. Payment gateways, such as Paytm, provide the infrastructure to securely handle transactions, manage 
sensitive data, and facilitate payments from users through various methods (e.g., credit cards, debit cards, net banking, 
wallets).

Here’s a structured introduction to integrating a payment gateway like Paytm into a Django project:

1. Understanding Payment Gateway Integration
A payment gateway acts as a bridge between your website and the bank’s financial system. When a customer makes a payment, 
the gateway helps to authorize and authenticate the payment by connecting with the bank, and it securely returns the 
response (success or failure).

Common steps in the payment process include:

Customer enters payment details.
Payment gateway processes the payment.
Response (success/failure) sent back to the website.
The payment confirmation (or failure) is shown to the customer.
2. Overview of Paytm Integration
Paytm is one of India’s largest payment gateways, allowing payments via wallets, UPI, debit cards, credit cards, and more. For integrating Paytm into your Django project, you need:

Merchant ID and Merchant Key from Paytm.
API Keys for authentication and encryption.
Access to Paytm's sandbox environment for testing before going live.
3. Steps to Integrate Paytm in Django
a. Set Up a Paytm Account
Sign up as a merchant at Paytm for Business.
After registration, you'll receive a Merchant ID, Merchant Key, and Website Name which are required for integration.
b. Install Dependencies
You may need libraries for handling HTTP requests and managing secure payment transactions. Install libraries like 
requests to make API calls.

bash
pip install requests
c. Create Models and Views for Payment
In Django, you'll need models to store transaction data, like order details, payment status, etc. You also need views 
to handle user requests for payment and responses from the gateway.

Example:
models.py
python
from django.db import models

class Order(models.Model):
    order_id = models.CharField(max_length=100)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    status = models.CharField(max_length=20, default="Pending")
    transaction_id = models.CharField(max_length=100, null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
views.py
python
import hashlib
import requests
from django.conf import settings
from django.shortcuts import render, redirect
from django.http import HttpResponse
from .models import Order

# Paytm Merchant details
PAYTM_MERCHANT_ID = settings.PAYTM_MERCHANT_ID
PAYTM_MERCHANT_KEY = settings.PAYTM_MERCHANT_KEY
PAYTM_WEBSITE = "WEBSTAGING"
PAYTM_CHANNEL_ID = "WEB"

def initiate_payment(request, order_id):
    order = Order.objects.get(order_id=order_id)
    params = {
        'MID': PAYTM_MERCHANT_ID,
        'ORDER_ID': order.order_id,
        'CUST_ID': "CUST001",
        'INDUSTRY_TYPE_ID': "Retail",
        'CHANNEL_ID': PAYTM_CHANNEL_ID,
        'TXN_AMOUNT': str(order.amount),
        'WEBSITE': PAYTM_WEBSITE,
        'CALLBACK_URL': "http://yourdomain.com/payment/callback/",
    }
    
    # Generate checksum
    checksum = generate_checksum(params)
    params['CHECKSUMHASH'] = checksum
    
    # Create a payment request URL
    paytm_url = "https://securegw-stage.paytm.in/theia/processTransaction"
    
    return render(request, 'payment/payment_form.html', {'paytm_url': paytm_url, 'params': params})

def generate_checksum(params):
    # Paytm checksum generation logic (using hashlib)
    param_string = '&'.join(f"{key}={value}" for key, value in sorted(params.items()))
    param_string += f"&{PAYTM_MERCHANT_KEY}"
    return hashlib.md5(param_string.encode('utf-8')).hexdigest()
d. Payment Form
You need to create an HTML form where the payment request is sent. This form will automatically POST the payment 
details to the Paytm gateway.

payment_form.html
html
<form method="post" action="{{ paytm_url }}">
    {% for key, value in params.items %}
        <input type="hidden" name="{{ key }}" value="{{ value }}" />
    {% endfor %}
    <button type="submit">Pay Now</button>
</form>
e. Handle Callback
Paytm will redirect the user back to your site with the payment status. You need to handle this callback to update the 
transaction status in the database.

views.py (callback handling)
python
def payment_callback(request):
    # Retrieve the Paytm response and verify it
    order_id = request.POST.get('ORDERID')
    checksum = request.POST.get('CHECKSUMHASH')
    
    params = {
        'MID': PAYTM_MERCHANT_ID,
        'ORDER_ID': order_id,
    }
    
    # Verify checksum
    is_valid_checksum = verify_checksum(params, checksum)
    
    if is_valid_checksum:
        payment_status = request.POST.get('STATUS')
        if payment_status == 'TXN_SUCCESS':
            order = Order.objects.get(order_id=order_id)
            order.status = 'Success'
            order.transaction_id = request.POST.get('TXNID')
            order.save()
            return HttpResponse("Payment Successful")
        else:
            return HttpResponse("Payment Failed")
    else:
        return HttpResponse("Checksum Mismatch")

def verify_checksum(params, checksum):
    # Add checksum verification logic here
    return True  # For example, validate checksum using Paytm's provided tools
4. Testing and Going Live
Testing: Use Paytm's sandbox environment to test payments. Make sure that your Paytm account is in test mode and that 
you use the sandbox merchant credentials.
Go Live: After successful testing, switch to the live environment. Update your credentials and URLs accordingly.
5. Security Considerations
Ensure the security of sensitive data:

Use SSL to secure all communication between your site and Paytm.
Safely handle the Merchant Key and Merchant ID by storing them in environment variables or Django settings files.

Lab:
 Implement Paytm payment gateway in a Django project.

To integrate Paytm payment gateway in a Django project, follow these steps:

Prerequisites:
Paytm Merchant Account: Ensure you have a Paytm merchant account to get your Merchant ID, Merchant Key, and Website.
Python Libraries: You’ll need some Python libraries like requests, xml.etree.ElementTree to interact with Paytm.
Step 1: Install Necessary Python Libraries
First, install the necessary libraries:

bash
pip install requests xml.etree.ElementTree
Step 2: Add Paytm Credentials to Settings
In your settings.py, add the following Paytm configuration:

python
PAYTM_MERCHANT_ID = 'your_merchant_id'
PAYTM_MERCHANT_KEY = 'your_merchant_key'
PAYTM_WEBSITE = 'your_website'  # usually "WEBSTAGING" or "PROD"
PAYTM_CHANNEL_ID = 'WEB'
PAYTM_INDUSTRY_TYPE = 'Retail'
PAYTM_CALLBACK_URL = 'http://yourdomain.com/your_callback_url/'
Step 3: Create a Utility Function to Generate Checksum
In Paytm, you need to generate a checksum for every payment request. This checksum is used to verify the integrity of 
the request. Create a utility function to generate the checksum.

Create a file paytm_utils.py in your app folder:
python
import hashlib
import random
import string

from django.conf import settings

# Function to generate checksum for Paytm requests
def generate_checksum(params, merchant_key):
    """Generate checksum hash"""
    params_sorted = sorted(params.items())
    check_string = '|'.join([f"{key}={value}" for key, value in params_sorted])
    check_string += f'|{merchant_key}'
    return hashlib.sha256(check_string.encode('utf-8')).hexdigest().upper()

# Function to verify the checksum from Paytm response
def verify_checksum(response_params, merchant_key):
    """Verify checksum hash"""
    paytm_checksum = response_params.get('CHECKSUMHASH')
    del response_params['CHECKSUMHASH']
    return paytm_checksum == generate_checksum(response_params, merchant_key)
Step 4: Create Payment Views
Now, create views to handle the payment initiation and callback.

In views.py, define these views:
python
import random
import string
import requests
from django.shortcuts import render, redirect
from django.conf import settings
from .paytm_utils import generate_checksum, verify_checksum

def initiate_payment(request):
    """Initiate the payment process"""
    if request.method == 'POST':
        amount = request.POST['amount']
        order_id = ''.join(random.choices(string.ascii_uppercase + string.digits, k=10))  # Generate random order ID

        # Prepare the request params
        params = {
            'MID': settings.PAYTM_MERCHANT_ID,
            'ORDER_ID': order_id,
            'CUST_ID': 'cust123',  # This can be dynamic based on user login
            'INDUSTRY_TYPE_ID': settings.PAYTM_INDUSTRY_TYPE,
            'CHANNEL_ID': settings.PAYTM_CHANNEL_ID,
            'TXN_AMOUNT': amount,
            'WEBSITE': settings.PAYTM_WEBSITE,
            'CALLBACK_URL': settings.PAYTM_CALLBACK_URL,
            'EMAIL': 'customer@example.com',  # Customer email (optional)
            'MOBILE_NO': '9999999999',  # Customer mobile number (optional)
        }

        # Generate checksum for request
        checksum = generate_checksum(params, settings.PAYTM_MERCHANT_KEY)
        params['CHECKSUMHASH'] = checksum

        # Send the request to Paytm
        payment_url = "https://securegw-stage.paytm.in/order/process"  # Use "https://securegw.paytm.in/order/process" 
for production
        return render(request, 'payment_gateway/payment_form.html', {'params': params, 'payment_url': payment_url})

    return render(request, 'payment_gateway/initiate_payment.html')

def payment_callback(request):
    """Handle payment response"""
    response = request.POST.dict()
    if verify_checksum(response, settings.PAYTM_MERCHANT_KEY):
        if response.get('RESPCODE') == '01':
            # Payment successful
            return render(request, 'payment_gateway/success.html', {'response': response})
        else:
            # Payment failed
            return render(request, 'payment_gateway/failure.html', {'response': response})
    else:
        # Invalid checksum
        return render(request, 'payment_gateway/error.html', {'response': response})
Step 5: Create HTML Templates
payment_form.html: This will submit the payment request to Paytm.
html
<form method="POST" action="{{ payment_url }}">
    {% for key, value in params.items %}
    <input type="hidden" name="{{ key }}" value="{{ value }}">
    {% endfor %}
    <input type="submit" value="Pay Now">
</form>
initiate_payment.html: The form to initiate payment.
html
<form method="POST">
    {% csrf_token %}
    <label for="amount">Amount</label>
    <input type="text" id="amount" name="amount" required>
    <input type="submit" value="Pay Now">
</form>
success.html: This will be displayed if the payment is successful.
html
<h2>Payment Success</h2>
<p>Transaction ID: {{ response.TXNID }}</p>
<p>Status: {{ response.STATUS }}</p>
failure.html: This will be displayed if the payment fails.
html
<h2>Payment Failed</h2>
<p>Reason: {{ response.RESPMSG }}</p>
error.html: This will be displayed if there’s a checksum verification error.
html
<h2>Error</h2>
<p>Checksum verification failed.</p>
Step 6: Define URLs
In your urls.py, define the paths for the payment initiation and callback:

python
from django.urls import path
from . import views

urlpatterns = [
    path('initiate-payment/', views.initiate_payment, name='initiate_payment'),
    path('payment-callback/', views.payment_callback, name='payment_callback'),
]
Step 7: Test the Payment Integration
Run the Django server using python manage.py runserver.
Visit http://localhost:8000/initiate-payment/, fill in the amount, and submit the form.
You will be redirected to Paytm’s payment page for completing the transaction.
After completing the payment, Paytm will call your payment_callback view, where you can check the transaction status.
Step 8: Switch to Production
When you're ready for production, switch to the production URLs and use your live Paytm credentials.

For production, replace the sandbox URL with:

plaintext
https://securegw.paytm.in/order/process
Additional Considerations:
Security: Ensure that you are using HTTPS in production.
Testing: Test in Paytm's staging environment before going live.
Transaction Verification: In real use cases, you may want to verify the transaction status by sending a request to 
Paytm’s checkPaymentStatus API.
This is a basic integration. You can extend it with features like handling user accounts, storing transaction data in 
the database, and more.

Practical Example: 16) Write a Django project that integrates Paytm for handling payments in the "Doctor Finder" project.

To integrate Paytm into your Django-based "Doctor Finder" project for handling payments, you need to follow a few steps. 
This includes setting up a Paytm account, integrating the Paytm API with your Django project, and creating the 
necessary views, models, and templates.

Below is a step-by-step guide for setting up the Paytm integration.

1. Create a Paytm Account and Get API Keys
Go to the Paytm Developer Console: https://developer.paytm.com/
Create a new project (select "Website" or "App").
After creating your project, you will get Merchant ID, Merchant Key, and Website. Keep these credentials safe as you 
will use them in your Django project.
2. Install Required Python Libraries
You need to install the paytmchecksum library to handle Paytm's checksum generation and verification.

bash
pip install paytmchecksum
3. Update settings.py
In your Django settings.py, add the Paytm API credentials.

python
# Paytm settings
PAYTM_MERCHANT_ID = 'your_merchant_id'
PAYTM_MERCHANT_KEY = 'your_merchant_key'
PAYTM_WEBSITE = 'your_website_name'
PAYTM_CALLBACK_URL = 'http://yourdomain.com/payment/callback/'
4. Create a Model for Payments (Optional)
You might want to track payments in your database. Create a Payment model to store the transaction data.

python
from django.db import models

class Payment(models.Model):
    order_id = models.CharField(max_length=100)
    transaction_id = models.CharField(max_length=100)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    status = models.CharField(max_length=50)
    payment_date = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"Payment {self.order_id}"
Run the migration after creating this model.

bash
python manage.py makemigrations
python manage.py migrate
5. Create Paytm Payment API Views
Generate Checksum for Payment Request
Create a view to generate the checksum and redirect the user to Paytm's payment gateway.

python
import hashlib
from django.conf import settings
from django.shortcuts import render, redirect
from paytmchecksum import PaytmChecksum
from .models import Payment

def generate_payment(request, doctor_id):
    # Get doctor's fee or service charge (this should be part of your doctor model)
    doctor_fee = 500  # Example: Replace with actual doctor fee logic

    order_id = f"ORD{doctor_id}{str(int(time.time()))}"
    customer_id = request.user.id
    amount = doctor_fee
    txn_id = f"TXN{order_id}"

    # Prepare the data for Paytm request
    data = {
        'MID': settings.PAYTM_MERCHANT_ID,
        'ORDER_ID': order_id,
        'CUST_ID': customer_id,
        'MOBILE_NO': request.user.phone,  # Or any contact number field
        'EMAIL': request.user.email,
        'TXN_AMOUNT': str(amount),
        'CHANNEL_ID': 'WEB',
        'WEBSITE': settings.PAYTM_WEBSITE,
        'CALLBACK_URL': settings.PAYTM_CALLBACK_URL,
    }

    # Generate Checksum
    paytm_params = data.copy()
    paytm_params['INDUSTRY_TYPE_ID'] = 'Retail'
    paytm_params['THEME'] = 'theme1'

    checksum = PaytmChecksum.generate_checksum(paytm_params, settings.PAYTM_MERCHANT_KEY)
    paytm_params['CHECKSUMHASH'] = checksum

    # Save payment details in the database
    payment = Payment(order_id=order_id, amount=amount, status="INITIATED")
    payment.save()

    return redirect(f"https://secure.paytm.in/theia/processTransaction?{urlencode(paytm_params)}")
This view generates a Paytm checksum and redirects the user to the Paytm payment gateway.

Payment Callback View
Create a view to handle the callback from Paytm after payment.

python
from django.http import JsonResponse
from paytmchecksum import PaytmChecksum
from django.conf import settings
from .models import Payment
import logging

logger = logging.getLogger(__name__)

def payment_callback(request):
    paytm_params = request.POST.dict()
    checksum = paytm_params.get('CHECKSUMHASH')

    # Verify the checksum
    is_valid_checksum = PaytmChecksum.verify_checksum(paytm_params, settings.PAYTM_MERCHANT_KEY, checksum)

    if is_valid_checksum:
        order_id = paytm_params.get('ORDERID')
        txn_id = paytm_params.get('TXNID')
        payment_status = paytm_params.get('STATUS')

        # Update payment status in the database
        try:
            payment = Payment.objects.get(order_id=order_id)
            payment.transaction_id = txn_id
            payment.status = payment_status
            payment.save()

            # Handle payment success or failure
            if payment_status == 'TXN_SUCCESS':
                # Handle successful payment (e.g., assign doctor consultation)
                logger.info(f"Payment for order {order_id} successful.")
            else:
                # Handle failed payment
                logger.info(f"Payment for order {order_id} failed.")

            return JsonResponse({'status': 'success'})
        except Payment.DoesNotExist:
            logger.error(f"Payment order {order_id} not found.")
            return JsonResponse({'status': 'failure'}, status=400)
    else:
        logger.error("Checksum verification failed.")
        return JsonResponse({'status': 'failure'}, status=400)
6. Add URLs for Payment Views
In your urls.py, add the necessary paths for the payment views.

python
from django.urls import path
from . import views

urlpatterns = [
    path('generate_payment/<int:doctor_id>/', views.generate_payment, name='generate_payment'),
    path('payment/callback/', views.payment_callback, name='payment_callback'),
]
7. Create Payment Confirmation Templates
Create a simple template for showing the payment page (if needed) and for handling the payment status.

html
<!-- payment_page.html -->
<form action="{% url 'generate_payment' doctor_id=doctor.id %}" method="POST">
    {% csrf_token %}
    <input type="submit" value="Pay Now" />
</form>
8. Test the Integration
Make sure to test the integration in Paytm's sandbox environment before going live.
Use the sandbox credentials and URLs in settings.py for testing purposes.
9. Final Steps
After everything is set up and tested, you can start accepting payments for doctor appointments, consultations, or other 
services.
Ensure you have logging and proper error handling for issues like failed payments or incorrect data.

17. GitHub Project Deployment
Theory:
 Steps to push a Django project to GitHub.

To push a Django project to GitHub, follow these steps:

1. Create a GitHub Repository:
Go to GitHub and log in.
Click on the New button (usually on the left side of the dashboard).
Choose a name for your repository (e.g., my-django-project).
Optionally, provide a description.
Choose visibility (public or private).
Click Create repository.
2. Set Up Git Locally:
Install Git if you haven't already. You can download it from here.
Open a terminal (or Git Bash if on Windows).
Set your Git configuration (only once):
bash
git config --global user.name "Your Name"
git config --global user.email "your_email@example.com"
3. Navigate to Your Django Project Folder:
Open a terminal.
Use cd to navigate to the root folder of your Django project:
bash
cd /path/to/your/django/project
4. Initialize Git Repository:
Initialize a Git repository if you haven't already:
bash
git init
5. Create a .gitignore File:
To avoid pushing sensitive or unnecessary files to GitHub, create a .gitignore file in the root directory of 
your project. You can add the following basic entries for a Django project:
arduino
*.pyc
__pycache__/
.env
.venv/
db.sqlite3
media/
static/
.DS_Store
You can use a template for Django projects from gitignore.io.

6. Stage Your Changes:
Stage all the files (except those ignored by .gitignore):
bash
git add .
7. Commit Your Changes:
Commit the changes with a message:
bash
git commit -m "Initial commit of Django project"
8. Add GitHub Repository as Remote:
Copy the remote URL of the repository you created on GitHub (it will look like https://github.com/username/my-django-project.git).
Add the remote repository to your local git setup:
bash
git remote add origin https://github.com/username/my-django-project.git
9. Push Your Code to GitHub:
Push your local commits to the GitHub repository:
bash
git push -u origin master
For newer repositories, GitHub might use main as the default branch name instead of master. In that case, use:

bash
git push -u origin main
10. Verify the Push:
Go to your GitHub repository URL and refresh the page. Your Django project should now appear there.
Additional Tips:
Pushing Changes Later: After the initial push, for subsequent changes, you can just use:

bash
git add .
git commit -m "Description of changes"
git push
Handling Branches: If you're working with branches, ensure you're on the correct branch before pushing:

bash
git checkout branch-name
git push origin branch-name

Lab:
 Deploy a Django project to GitHub for version control.

Deploying a Django project to GitHub for version control involves several steps, including initializing a Git repository, 
committing your project files, and pushing them to GitHub. Here’s a step-by-step guide to help you get started:

Step 1: Initialize a Git Repository
Open your terminal/command prompt and navigate to the root folder of your Django project.

Initialize Git: Run the following command in the terminal to initialize a new Git repository:

bash
git init
Create a .gitignore file: It's important to create a .gitignore file to avoid pushing sensitive files like database files, 
virtual environments, and other unnecessary files to GitHub. You can create this file manually or use a template.

Example .gitignore file:

bash
*.pyc
__pycache__/
db.sqlite3
/media
/static
venv/
.env
Add files to Git: Add your project files to Git by running the following command:

bash
git add .
This stages all your files for commit.

Step 2: Create a GitHub Repository
Go to GitHub and log in to your account.

Create a new repository:

Click on the + icon in the top-right corner and select New repository.
Give your repository a name (e.g., my-django-project).
You can optionally add a description and choose whether the repository should be public or private.
Click Create repository.
Step 3: Connect Local Git Repository to GitHub
Copy the remote repository URL: After creating the repository on GitHub, you will see the URL for the repository 
(e.g., https://github.com/username/my-django-project.git).

Add the GitHub repository as a remote: In your terminal, add the GitHub repository URL as a remote for your local 
repository:

bash
git remote add origin https://github.com/username/my-django-project.git
Step 4: Commit and Push Your Code
Commit your changes: Commit the changes you’ve staged using the following command:

bash
git commit -m "Initial commit"
Push the changes to GitHub: Push your commit to the main branch on GitHub:

bash
git push -u origin main
If GitHub prompts for authentication, enter your GitHub username and password or personal access token.

Step 5: Verify on GitHub
Go back to your GitHub repository page and refresh it. Your Django project files should now be visible on GitHub.
Step 6: Optional – Setting Up for Collaboration
If you are working in a team or plan to collaborate, it’s a good idea to regularly pull changes from the remote 
repository and push your own updates.

Pull:

bash
git pull origin main
Push:

bash
git push origin main

Practical Example: 17) Write a step-by-step guide to deploying the “Doctor Finder” project to GitHub.

Deploying your "Doctor Finder" project to GitHub involves several key steps, from setting up your repository to 
pushing your code and making sure everything is properly deployed. Below is a step-by-step guide to help you deploy 
your project.

Step 1: Create a GitHub Account (If You Don't Have One)
Go to GitHub and create an account if you don't already have one.
Step 2: Install Git (If Not Installed)
Make sure Git is installed on your local machine. You can check if it's installed by running this command in 
your terminal:
bash
git --version
If it's not installed, download and install Git from here.
Step 3: Initialize a Git Repository in Your Project Folder
Open a terminal or Git Bash and navigate to the folder where your “Doctor Finder” project is located.
bash
cd path/to/your/doctor-finder
Initialize a Git repository in this folder:
bash
git init
Step 4: Create a New Repository on GitHub
Go to GitHub, log in to your account, and click on the + icon in the top-right corner to select New repository.
Name your repository, e.g., "doctor-finder" and choose whether it should be public or private.
Click Create repository.
Step 5: Add Your Remote Repository to Git
After creating your repository on GitHub, GitHub will show you the commands to connect 
your local project to the remote repository.
Copy the URL of your GitHub repository (it will be something like https://github.com/your-username/doctor-finder.git).
In your terminal, run the following commands to link your local Git repository to the GitHub repository:
bash
git remote add origin https://github.com/your-username/doctor-finder.git
Step 6: Stage and Commit Your Code
Stage all the files in your project for commit by running:

bash
git add .
The . indicates that all changes (new files, modifications, deletions) should be staged.

Commit your changes with a meaningful message:

bash
git commit -m "Initial commit of Doctor Finder project"
Step 7: Push Your Code to GitHub
Push your local repository to GitHub using the following command:
bash
git push -u origin master
If you're using GitHub's default branch (now often main), replace master with main.
Step 8: Verify on GitHub
Go to your repository page on GitHub (e.g., https://github.com/your-username/doctor-finder).
Your project files should now be available on GitHub!
Step 9: Set Up GitHub Pages (Optional, for Front-End Deployment)
If your "Doctor Finder" project includes a front-end (HTML, CSS, JavaScript), you can deploy it via GitHub Pages:

In your repository on GitHub, go to the Settings tab.
Scroll down to the Pages section.
Under Source, choose the branch you want to deploy (e.g., main or master).
If you have a folder like docs or public, select that folder for deployment. If you’re deploying the entire root folder, 
leave it as is.
GitHub will provide you with a URL where your project is deployed, like https://your-username.github.io/doctor-finder.
Step 10: Make Future Changes and Push Them to GitHub
As you work on your project and make updates, remember to:

Stage the changes:
bash
git add .
Commit the changes with a message:
bash
git commit -m "Updated feature X or fixed bug Y"
Push the changes to GitHub:
bash
git push
Step 11: Collaborate and Track Issues (Optional)
If you're working with a team or want to track bugs and tasks, you can use Issues and Pull Requests on GitHub.
Create issues for tasks or bugs.
Use Pull Requests for reviewing and merging code changes.

18. Live Project Deployment (PythonAnywhere)
Theory:
 Introduction to deploying Django projects to live servers like PythonAnywhere.

Deploying a Django project to a live server like PythonAnywhere involves several steps that transform your development 
environment into a production-ready system. PythonAnywhere is a popular hosting platform for Python web applications, 
offering easy deployment for small to medium-sized projects. Here’s a step-by-step guide to get your Django project up 
and running on PythonAnywhere.

1. Prepare Your Django Project
Before deploying to PythonAnywhere, ensure your Django project is ready for production:

Set DEBUG = False: In your settings.py, make sure the DEBUG mode is turned off for production.

python
DEBUG = False
Set Allowed Hosts: Configure ALLOWED_HOSTS to include the domain or IP address that your app will use.

python
ALLOWED_HOSTS = ['yourusername.pythonanywhere.com']
Configure Static Files: Django serves static files (like CSS, JavaScript) differently in production, so you need to set 
the path for your static files. In settings.py, ensure you have:

python
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
Configure Database: If you are using SQLite during development, you may want to switch to PostgreSQL or MySQL for 
production, as PythonAnywhere offers these options. However, if you are using SQLite, it should work for smaller 
applications.

2. Create a PythonAnywhere Account
Sign up for a PythonAnywhere account at PythonAnywhere.

Choose a free or paid plan depending on your needs (free accounts have some limitations).
3. Upload Your Django Project to PythonAnywhere
You can upload your project files to PythonAnywhere using one of the following methods:

Git: If your project is on GitHub or another Git repository, you can clone it directly on PythonAnywhere.
FTP/SFTP: Upload files using an FTP client like FileZilla.
For Git-based deployment:

Log in to your PythonAnywhere account.
Go to the Consoles tab and start a Bash console.
Clone your project repository:
bash
git clone https://github.com/yourusername/yourproject.git
4. Set Up a Virtual Environment
Using a virtual environment ensures that your project uses specific Python packages without interfering with global 
Python packages.

Start a Bash console on PythonAnywhere.

Create a virtual environment:

bash
python3.8 -m venv /home/yourusername/yourprojectenv
Activate the virtual environment:

bash
source /home/yourusername/yourprojectenv/bin/activate
Install the required packages for your project:

bash
pip install -r /path/to/yourproject/requirements.txt
5. Configure the Web App on PythonAnywhere
Go to the Web tab on PythonAnywhere dashboard and click Add a new web app.

Choose Manual Configuration and select the appropriate Python version (matching your project).

After creating the web app, you will be taken to the web app configuration page where you can set the following:

Source code directory: Point to the directory where your project is located.

Virtualenv: Select the virtual environment you created earlier.

WSGI configuration file: This file configures how PythonAnywhere interacts with your Django app. PythonAnywhere 
automatically generates a basic file, but you might need to modify it.

Example:

python
import os
import sys

path = '/home/yourusername/yourproject'
if path not in sys.path:
    sys.path.insert(0, path)

os.environ['DJANGO_SETTINGS_MODULE'] = 'yourproject.settings'

from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()
6. Set Up Static and Media Files
Django handles static and media files separately in production:

Static files: Ensure that the STATIC_ROOT is set in settings.py (as mentioned above). Then, run the following command to 
collect all static files into one directory:

bash
python manage.py collectstatic
This will copy all static files into the STATIC_ROOT directory.

Media files: If your project uses media files (uploaded files), configure the MEDIA_ROOT in settings.py.

On PythonAnywhere:

You will also need to set up the static files and media files configuration under the Web tab by defining the URL 
mappings for static and media directories.
7. Migrate Your Database
If you are using a database like SQLite, PostgreSQL, or MySQL, you need to apply migrations to set up the database.

Ensure your database configuration is correct in settings.py.
Run migrations:
bash
python manage.py migrate
8. Testing the Application
Once everything is set up, you can visit your web app's domain (e.g., yourusername.pythonanywhere.com) to check if 
everything is running correctly.

9. Security and Final Configuration
Set up HTTPS: For a production environment, you should configure HTTPS. PythonAnywhere provides free SSL certificates 
for custom domains.
Email settings: If your Django app uses email functionality, configure the SMTP settings in settings.py.
Backup: Regularly back up your database and static files.

Lab:
 Deploy a Django project to PythonAnywhere.

Deploying a Django project to PythonAnywhere is a straightforward process, and the platform provides free and paid plans 
for hosting Python web applications. Below is a step-by-step guide to help you deploy a Django project on PythonAnywhere.

Step 1: Prepare Your Django Project
Before deploying your project, make sure it’s ready for production. This includes:

Install Requirements: Ensure your requirements.txt file is up-to-date with all the necessary dependencies.

pip freeze > requirements.txt
Set DEBUG to False: In your Django settings.py, set DEBUG = False.

python
DEBUG = False
ALLOWED_HOSTS = ['your-username.pythonanywhere.com']
Collect Static Files: Run the collectstatic command to gather all your static files in the STATIC_ROOT directory.

python manage.py collectstatic
Database Configuration: If you're using SQLite for local development, consider switching to a more robust database for 
production, such as PostgreSQL or MySQL, which PythonAnywhere supports.

You can also use SQLite for small projects and ensure you back it up.

Step 2: Create an Account on PythonAnywhere
If you haven’t already, create an account on PythonAnywhere.

Step 3: Upload Your Django Project to PythonAnywhere
There are a few ways to upload your Django project, but one of the most straightforward methods is using Git or directly 
uploading via the PythonAnywhere interface.

Option 1: Using Git
Create a Git repository (if you don't have one) for your project (e.g., on GitHub).
Clone the repository on PythonAnywhere:
Go to the Files tab on PythonAnywhere.

Navigate to the directory where you want your project (or create a new one).

Open a Bash console and clone your repository:

bash
git clone https://github.com/your-username/your-django-project.git
Option 2: Uploading Files Manually
Alternatively, you can upload your Django project files directly through the Files tab on PythonAnywhere.

Open the Files tab on PythonAnywhere.
Navigate to the folder where you want to store your project.
Click Upload a file to upload the files.
Step 4: Set Up Virtual Environment
PythonAnywhere uses virtual environments for running Python projects.

Open a Bash console.

Create a virtual environment (you can use venv or virtualenv):

bash
python3 -m venv myenv
Activate the virtual environment:

bash
source myenv/bin/activate
Install the required dependencies for your Django project:

bash
pip install -r /path/to/your/project/requirements.txt
Step 5: Set Up Your Django Web App
Go to the Web tab in PythonAnywhere.
Click Add a new web app.
Choose the manual configuration option, as we will configure it for Django.
Select Python 3.x (matching the version of your project).
In the Source code section, set the path to your Django project folder.
Step 6: Configure WSGI File
PythonAnywhere uses the wsgi.py file to run the web app.

On the Web tab, under the "WSGI configuration file" section, click the WSGI file link to edit it.

Update the file to point to your Django project:

python
import os
import sys

# Add your project directory to the sys.path
project_home = '/home/your-username/your-project-folder'
if project_home not in sys.path:
    sys.path.append(project_home)

# Activate your virtual environment
activate_this = '/home/your-username/your-virtualenv-folder/myenv/bin/activate_this.py'
exec(open(activate_this).read(), {'__file__': activate_this})

# Set the default Django settings module
os.environ['DJANGO_SETTINGS_MODULE'] = 'your_project.settings'

# Import and start the application
from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()
Step 7: Set Up Static and Media Files
Static files:

In the Web tab, set the path for static files to the STATIC_ROOT directory you created earlier by running collectstatic.
PythonAnywhere will automatically serve static files from this directory.
Media files:

Set up the media files directory by linking to your project’s MEDIA_ROOT in the Web tab.
Configure the URL for media files (usually /media/).
Step 8: Configure the Database (Optional)
If you're using a production database like PostgreSQL or MySQL:

Set up a database on PythonAnywhere (PostgreSQL or MySQL).

Update the database settings in your Django settings.py to point to the new database.

Run migrations:

bash
python manage.py migrate
Step 9: Reload the Web App
After configuring everything, go back to the Web tab and click Reload to restart your web app. This will apply all changes.

Step 10: Test Your Django Project
Your Django app should now be live on PythonAnywhere! You can visit the URL provided in the Web tab 
(e.g., your-username.pythonanywhere.com) to see your deployed app.

Troubleshooting Tips
Debugging Errors: If you encounter any issues, check the Error log in the Web tab for details.
Static Files Not Loading: Ensure the static and media directories are correctly configured and that collectstatic was run.
Database Errors: Verify your database configuration, including credentials and access permissions.

Practical Example: 18) Write a Django project and deploy it on PythonAnywhere, making it accessible online.

To create a Django project and deploy it on PythonAnywhere, follow these steps. This guide covers setting up a Django 
project on your local machine, preparing it for deployment, and deploying it to PythonAnywhere to make it accessible 
online.

Step 1: Set Up Your Local Development Environment
Install Python and Django:

Make sure Python is installed on your machine. You can check this by running:
bash
python --version
Install Django using pip:
bash
pip install django
Create a Django Project:

Create a new directory for your project and navigate into it:
bash
mkdir myproject
cd myproject
Create a new Django project using the django-admin command:
bash
django-admin startproject myproject .
Create a Django App:

Inside the project directory, create a Django app (e.g., blog):
bash
python manage.py startapp blog
Add App to Installed Apps:

Open the myproject/settings.py file and add 'blog' to the INSTALLED_APPS list:
python
INSTALLED_APPS = [
    ...
    'blog',
]
Create Views and URLs:

Inside blog/views.py, create a basic view:
python
from django.http import HttpResponse

def home(request):
    return HttpResponse("Hello, World!")
Define a URL route for the view inside blog/urls.py:
python
Copy code
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
]
Include blog.urls in myproject/urls.py:
python
Copy code
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('blog.urls')),
]
Run Local Development Server:

Run the Django server locally to verify it works:
bash
python manage.py runserver
Visit http://127.0.0.1:8000 in your browser and ensure the "Hello, World!" message appears.
Step 2: Prepare the Project for Deployment
Create a Requirements File:

Freeze the installed packages into a requirements.txt file:
bash
pip freeze > requirements.txt
Configure the Database for Production:

For simplicity, use the default SQLite database in the development environment, but for production, ensure you use a 
production-ready database like PostgreSQL or MySQL (we'll configure this later).
Set Up Static Files Handling:

In myproject/settings.py, set up static files:
python
STATIC_URL = '/static/'
STATIC_ROOT = os.path.join(BASE_DIR, 'static')
Set Debug Mode for Production:

Set DEBUG = False in settings.py for production. Also, ensure ALLOWED_HOSTS is configured:
python
DEBUG = False
ALLOWED_HOSTS = ['yourusername.pythonanywhere.com']
Generate Secret Key:

Generate a new SECRET_KEY for production:
bash
python -c 'import random; print("".join([random.choice("abcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*(-_=+)") for i in 
range(50)]))'
Update the SECRET_KEY in settings.py.
Configure the Database (if using PostgreSQL on PythonAnywhere):

You may need to set up PostgreSQL on PythonAnywhere. For now, ensure your database settings in settings.py match what 
you’ll configure on PythonAnywhere.
Step 3: Deploy the Django Project to PythonAnywhere
Create a PythonAnywhere Account:

Go to PythonAnywhere and sign up for a free or paid account.
Create a New Web App on PythonAnywhere:

Log in to PythonAnywhere and go to the "Web" tab.
Click "Add a new web app."
Choose "Django" and select a Python version.
Select the option to use an existing virtual environment or create a new one.
Upload Your Project Files:

Go to the "Files" tab and upload your Django project files (the entire project directory, including myproject, blog, 
and requirements.txt).
Ensure your requirements.txt file is in the root directory, and the project directory is set to the right path.
Set Up the Virtual Environment on PythonAnywhere:

Open a Bash console in PythonAnywhere and navigate to your project directory.
Create a virtual environment and activate it:
bash
python3 -m venv myenv
source myenv/bin/activate
Install dependencies from requirements.txt:
bash
pip install -r requirements.txt
Configure Database on PythonAnywhere (Optional):

If using PostgreSQL, create a new PostgreSQL database on PythonAnywhere via the "Databases" tab.
Update DATABASES in settings.py to use the PostgreSQL credentials provided by PythonAnywhere.
Update WSGI Configuration:

In PythonAnywhere, navigate to the "Web" tab, and under "WSGI configuration file", edit the wsgi.py file to point to 
your Django project.
Example wsgi.py setup:
python
import os
import sys
path = '/home/yourusername/myproject'
if path not in sys.path:
    sys.path.append(path)

os.environ['DJANGO_SETTINGS_MODULE'] = 'myproject.settings'

from django.core.wsgi import get_wsgi_application
application = get_wsgi_application()
Collect Static Files:

In the PythonAnywhere Bash console, run:
bash
python manage.py collectstatic
Migrate Database:

Run the database migrations on PythonAnywhere:
bash
python manage.py migrate
Restart Your Web App:

Go to the "Web" tab and hit the "Reload" button to restart your web app.
Step 4: Test Your Application
Visit your web app URL: http://yourusername.pythonanywhere.com/. You should see the "Hello, World!" message or 
whatever content you have set up in your views.

19. Social Authentication
Theory:
 Setting up social login options (Google, Facebook, GitHub) in Django using OAuth2.

To set up social login options (like Google, Facebook, or GitHub) in a Django project using OAuth2, the most 
common approach is to use a third-party package like django-allauth or social-auth-app-django. These packages provide 
built-in functionality to integrate OAuth2 with various social platforms, making the implementation easier.

Steps to Set Up Social Login with Django and OAuth2:
We will use social-auth-app-django in this example, as it is a popular choice for handling OAuth2 authentication 
in Django.

1. Install Required Packages
First, install the necessary packages:

bash
pip install social-auth-app-django
pip install social-auth-core
2. Add Installed Apps
In your Django project's settings.py, add the following apps to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    ...
    'social_django',  # Social authentication
    ...
]
3. Add Authentication Backends
Add the authentication backends for the social login options you want to use. For example, to enable Google, Facebook, 
and GitHub login:

python
AUTHENTICATION_BACKENDS = (
    'social_core.backends.google.GoogleOAuth2',
    'social_core.backends.facebook.FacebookOAuth2',
    'social_core.backends.github.GithubOAuth2',
    'django.contrib.auth.backends.ModelBackend',  # Keep the default Django backend as well
)
4. Configure OAuth2 Keys and Secrets
You need to obtain OAuth2 credentials (client ID and secret) from the respective social platforms:

Google: Google Developers Console
Facebook: Facebook Developer Portal
GitHub: GitHub Developer Settings
Add these credentials to the Django settings:

python
SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = '<your-google-client-id>'
SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = '<your-google-client-secret>'

SOCIAL_AUTH_FACEBOOK_KEY = '<your-facebook-app-id>'
SOCIAL_AUTH_FACEBOOK_SECRET = '<your-facebook-app-secret>'

SOCIAL_AUTH_GITHUB_KEY = '<your-github-client-id>'
SOCIAL_AUTH_GITHUB_SECRET = '<your-github-client-secret>'
5. Set Up Redirect URLs
You need to set up the redirect URLs that social platforms will use after a successful login. Add these to your 
settings.py file:

python
SOCIAL_AUTH_LOGIN_REDIRECT_URL = '/'  # Redirect after successful login
SOCIAL_AUTH_LOGIN_ERROR_URL = '/login-error/'  # Redirect on login error
Additionally, you may want to configure the login URL:

python
LOGIN_URL = 'login'  # Where users are redirected to log in
6. Configure URLs
In your urls.py, include the URLs for handling the login flow:

python
from django.urls import path, include

urlpatterns = [
    path('social/', include('social_django.urls')),  # Social login routes
    ...
]
7. Migrate the Database
Run the migrations to set up the necessary database tables for social authentication:

bash
python manage.py migrate
8. Template Integration
To display social login buttons, you need to update your templates to include the social login options. For example, 
in your login.html:

html
{% load social_django %}

<!-- Google Login -->
<a href="{% url 'social:login' 'google' %}">Login with Google</a>

<!-- Facebook Login -->
<a href="{% url 'social:login' 'facebook' %}">Login with Facebook</a>

<!-- GitHub Login -->
<a href="{% url 'social:login' 'github' %}">Login with GitHub</a>
This will create the login buttons for each social platform.

9. (Optional) Customize Authentication Flow
You can override the behavior of social authentication by subclassing social_core signals. For example, to customize 
user creation after a successful login, you can connect to the user_logged_in signal and implement a custom handler.

10. Testing
Start your Django development server:

bash
python manage.py runserver
Visit /social/login/ to test the integration with each social login (Google, Facebook, GitHub).

Lab:
 Implement Google and Facebook login for the Django project.

To implement Google and Facebook login for a Django project, you'll typically use OAuth2 authentication. 
There are ready-made packages like django-allauth or social-auth-app-django that simplify the integration process. 
Below is a guide to help you implement both Google and Facebook login for your Django project using django-allauth.

Step-by-Step Guide to Implement Google and Facebook Login
1. Install Required Packages
First, install the required packages using pip:

bash
pip install django-allauth
pip install social-auth-app-django
2. Add Installed Apps to settings.py
In your settings.py, add django-allauth and related apps to the INSTALLED_APPS:

python
INSTALLED_APPS = [
    'django.contrib.sites',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.admin',

    # Authentication apps
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',
    'allauth.socialaccount.providers.facebook',
]

# Add these settings for django-allauth
AUTHENTICATION_BACKENDS = (
    'allauth.account.auth_backends.AuthenticationBackend',
)

SITE_ID = 1  # This is required for django-allauth to function properly
3. Configure URLs
In your urls.py, include the allauth URLs:

python
from django.urls import path, include

urlpatterns = [
    path('accounts/', include('allauth.urls')),
]
4. Add Social Authentication Settings to settings.py
Now, configure the social authentication providers in your settings.py:

python
# Google OAuth
SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = 'your-client-id'  # Get this from Google Developer Console
SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = 'your-client-secret'  # Get this from Google Developer Console

# Facebook OAuth
SOCIAL_AUTH_FACEBOOK_KEY = 'your-app-id'  # Get this from Facebook Developer Console
SOCIAL_AUTH_FACEBOOK_SECRET = 'your-app-secret'  # Get this from Facebook Developer Console
You can generate your credentials by following these steps:

For Google:

Go to Google Developer Console.
Create a new project.
Enable the Google+ API and OAuth 2.0.
Create OAuth 2.0 credentials (Web application).
Use the Client ID and Client Secret in your Django project.
For Facebook:

Go to Facebook Developers.
Create a new App.
Enable Facebook Login.
Use the App ID and App Secret in your Django project.
5. Update AUTHENTICATION_BACKENDS
Update your AUTHENTICATION_BACKENDS in settings.py to include the Google and Facebook providers:

python
AUTHENTICATION_BACKENDS = (
    'allauth.account.auth_backends.AuthenticationBackend',
    'social_core.backends.google.GoogleOAuth2',  # Add Google login
    'social_core.backends.facebook.FacebookOAuth2',  # Add Facebook login
)
6. Database Migrations
Run the migrations to create the necessary database tables for django-allauth:

bash
python manage.py migrate
7. Template for Social Login
You can now use allauth's built-in templates to display the login buttons. In your HTML template, you can render the 
Google and Facebook login buttons using:

html
<a href="{% provider_login_url 'google' %}">Login with Google</a>
<a href="{% provider_login_url 'facebook' %}">Login with Facebook</a>
Alternatively, you can use django-allauth's default login view, which will automatically show social login options 
if configured correctly.

8. Test the Integration
Run the Django development server:

bash
python manage.py runserver
Navigate to the login page, and you should see the options to log in via Google and Facebook.

Optional: Customizing the Login Flow
If you want to customize the login flow or post-login actions (e.g., redirecting to a specific page after login), 
you can set up allauth signals in your views.py or signals.py to handle these scenarios.

Example: Redirect After Login
You can customize the redirect URL after login by overriding the ACCOUNT_AUTHENTICATED_REDIRECT_URL in your settings.py:

python
ACCOUNT_AUTHENTICATED_REDIRECT_URL = '/'  # Redirect to home page after successful login
You can also create custom signals to perform actions after authentication, like linking user accounts with other services.

Practical Example: 19) Write a Django project to allow users to log in using Google or Facebook.

To create a Django project that allows users to log in using Google or Facebook, we will integrate the OAuth2 
authentication system provided by both platforms. This is done using the django-allauth library, which makes it easy to 
set up authentication with third-party services such as Google and Facebook.

Here is a practical example of how to implement this:

1. Create a New Django Project
First, let's create a new Django project and app.

bash
django-admin startproject social_login
cd social_login
django-admin startapp accounts
2. Install Required Packages
We need to install the following packages:

django-allauth: A powerful authentication package for Django.
django-environ: To handle environment variables for sensitive data like API keys.
Install the necessary packages using pip:

bash
pip install django-allauth django-environ
3. Configure settings.py
Now, configure your settings.py to use django-allauth for Google and Facebook login.

Add django-allauth and required apps to INSTALLED_APPS.
Set the authentication backend.
Configure OAuth2 keys for Google and Facebook (you’ll get these from their developer consoles).
Update settings.py:

python
# settings.py

INSTALLED_APPS = [
    'django.contrib.sites',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'accounts',  # Our app
    'allauth',  # Django allauth for third-party login
    'allauth.account',
    'allauth.socialaccount',  # For social account integration
    'allauth.socialaccount.providers.google',  # Google login
    'allauth.socialaccount.providers.facebook',  # Facebook login
]

AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend',  # Default auth backend
    'allauth.account.auth_backends.AuthenticationBackend',  # Allauth backend
)

SITE_ID = 1  # Required by django-allauth

# Configure Django Allauth
LOGIN_REDIRECT_URL = '/'  # Redirect to homepage after login
ACCOUNT_LOGOUT_REDIRECT_URL = '/'
ACCOUNT_EMAIL_REQUIRED = True  # Ensure email is required

# Social account keys (you'll get these from Google/Facebook developer console)
SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = '<your-google-client-id>'
SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = '<your-google-client-secret>'

SOCIAL_AUTH_FACEBOOK_KEY = '<your-facebook-app-id>'
SOCIAL_AUTH_FACEBOOK_SECRET = '<your-facebook-app-secret>'

# Use django-environ for secret management
import environ
env = environ.Env()
environ.Env.read_env()

SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = env('GOOGLE_CLIENT_ID')
SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = env('GOOGLE_CLIENT_SECRET')

SOCIAL_AUTH_FACEBOOK_KEY = env('FACEBOOK_APP_ID')
SOCIAL_AUTH_FACEBOOK_SECRET = env('FACEBOOK_APP_SECRET')
4. Configure Google and Facebook Developer Consoles
Google Developer Console:

Go to Google Developer Console.
Create a new project.
Enable the "Google+ API".
Set up OAuth consent screen and get your CLIENT_ID and CLIENT_SECRET.
Facebook Developer Console:

Go to Facebook Developers.
Create a new app.
Set up Facebook login.
Get your APP_ID and APP_SECRET.
Once you have these credentials, add them to your environment variables:

.env:

bash
GOOGLE_CLIENT_ID=<your-google-client-id>
GOOGLE_CLIENT_SECRET=<your-google-client-secret>
FACEBOOK_APP_ID=<your-facebook-app-id>
FACEBOOK_APP_SECRET=<your-facebook-app-secret>
5. Add URLs
Add URLs for login and logout, and include django-allauth URLs in your project.

Update social_login/urls.py:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('allauth.urls')),  # Include allauth URLs
]
6. Set Up Templates
Create templates for login and home pages. Django Allauth will automatically handle the login UI.

Create a templates directory inside your project.
Inside templates, create a socialaccount folder, which will contain the login template.
Example templates/socialaccount/login.html:

html
<!-- templates/socialaccount/login.html -->
{% load socialaccount %}
{% block content %}
    <h1>Login</h1>
    <p>Login using your social account:</p>
    <a href="{% provider_login_url "google" %}">Login with Google</a>
    <a href="{% provider_login_url "facebook" %}">Login with Facebook</a>
{% endblock %}
7. Create the Accounts App Views
For simplicity, we can just render a home page once the user is logged in.

Update accounts/views.py:

python
from django.shortcuts import render

def home(request):
    return render(request, 'home.html')
Create the home.html template:

html
<!-- templates/home.html -->
{% if user.is_authenticated %}
    <h1>Welcome, {{ user.username }}!</h1>
    <a href="{% url 'account_logout' %}">Logout</a>
{% else %}
    <h1>Welcome, Guest!</h1>
    <a href="{% url 'account_login' %}">Login</a>
{% endif %}
8. Migrate Database
Run the following command to apply all migrations, including django-allauth’s migrations:

bash
python manage.py migrate
9. Test the Application
Run the development server:

bash
python manage.py runserver
Now you can visit http://127.0.0.1:8000/ in your browser. You should be able to log in using either Google or Facebook.

20. Google Maps API
Theory:
 Integrating Google Maps API into Django projects.

Integrating Google Maps API into a Django project can be a great way to display maps, locations, routes, or other 
geospatial data in your web application. Below are the steps you can follow to integrate Google Maps into your Django 
project:

Steps to Integrate Google Maps API into Django
1. Set Up a Google Cloud Account and Get an API Key
Go to the Google Cloud Console.
Create a new project or select an existing project.
Navigate to the APIs & Services section, and then click on Library.
Search for Maps JavaScript API and Geocoding API (if you want to convert addresses to lat/long) and enable them for 
your project.
Go to the Credentials tab and click on Create Credentials, then choose API key. This will generate an API key that you’ll 
use to authenticate requests from your application.
2. Install Required Python Libraries
To work with Google Maps in Django, you may need a few Python libraries, particularly if you want to handle geospatial 
data or integrate with Django’s models. You can use googlemaps for geocoding and reverse geocoding (converting addresses 
to lat/long and vice versa).

bash
pip install googlemaps
3. Add Google Maps API Key to Django Settings
In your Django project, go to your settings file (settings.py), and add the Google Maps API key.

python
# settings.py
GOOGLE_MAPS_API_KEY = 'your-google-maps-api-key-here'
4. Create a Django View to Pass the API Key to the Template
Now, you need to set up a view that passes the API key to your front-end template, where the Google Maps JavaScript 
API will be loaded.

python
# views.py
from django.conf import settings
from django.shortcuts import render

def map_view(request):
    return render(request, 'map_template.html', {'google_maps_api_key': settings.GOOGLE_MAPS_API_KEY})
5. Create the Template with Google Maps Integration
In your template (e.g., map_template.html), you’ll need to include the Google Maps JavaScript API by linking to the 
Google Maps service. Add this inside the <head> tag.

html
<!-- map_template.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Map Integration</title>
    <!-- Add Google Maps JavaScript API -->
    <script async defer src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initMap"></script>
    <script>
        // Function to initialize the map
        function initMap() {
            const mapOptions = {
                zoom: 8,
                center: { lat: 37.7749, lng: -122.4194 }  // Default center (San Francisco)
            };
            const map = new google.maps.Map(document.getElementById('map'), mapOptions);
        }
    </script>
</head>
<body>
    <h1>Google Map Integration</h1>
    <!-- Create a div where the map will render -->
    <div id="map" style="height: 500px; width: 100%;"></div>
</body>
</html>
{{ google_maps_api_key }} will dynamically load the API key you set in settings.py.
The initMap function is called when the API finishes loading. It initializes the map, sets the zoom level, and places a 
marker at the specified location.
6. Add URL Mapping for the Map View
In your urls.py, map a URL to the map_view function.

python
# urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('map/', views.map_view, name='map_view'),
]
7. Optional: Geocoding Addresses (Python Backend)
If you need to convert addresses to latitude and longitude, you can use the googlemaps Python package on the server 
side to interact with the Google Maps API.

For example, here’s how you can geocode an address:

python
# views.py
import googlemaps
from django.conf import settings
from django.shortcuts import render

def geocode_address(request):
    gmaps = googlemaps.Client(key=settings.GOOGLE_MAPS_API_KEY)
    address = "1600 Amphitheatre Parkway, Mountain View, CA"
    geocode_result = gmaps.geocode(address)
    return render(request, 'geocode_template.html', {'geocode_result': geocode_result})
In this example, gmaps.geocode(address) sends the address to Google Maps and retrieves the corresponding lat/long.

8. Display Geocoding Results in the Template
You can now display the geocoding results in the template:

html
<!-- geocode_template.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Geocoding Example</title>
</head>
<body>
    <h1>Geocoding Results</h1>
    <pre>{{ geocode_result }}</pre>
</body>
</html>
This will show the latitudes and longitudes for the address you provided.

Additional Features (Optional)
Markers on Maps: You can add markers to a map by creating a google.maps.Marker object.
Directions and Routes: If you want to show routes between two places, you can use the Google Maps Directions API.
Geospatial Queries: You can use django.contrib.gis with Django to query geographic data (like locations, distances, etc.) 
and display this data on Google Maps.

Lab:
 Use Google Maps API to display doctor locations in the "Doctor Finder" project.

To display doctor locations on a map in your "Doctor Finder" project using the Google Maps API, you need to follow these 
general steps. I will guide you through the process, assuming you have a basic understanding of web development 
(HTML, JavaScript, and basic API usage).

Prerequisites:
Google Maps API Key: You need to create a project on the Google Cloud Platform, enable the Google Maps JavaScript API, 
and get your API key.
Doctors' Location Data: You'll need a list of doctors with their locations (latitude and longitude). You can either 
hard-code the data or fetch it from a database.
Steps to Integrate Google Maps in Your Project:
1. Create a Google Cloud Project and Get API Key:
Go to Google Cloud Console.
Create a new project.
Enable the Google Maps JavaScript API.
Go to the API & Services > Credentials section, and create a new API key.
Make sure to restrict your API key for security purposes (you can restrict by referrer or IP).
2. Add Google Maps JavaScript to Your HTML:
Add the following script tag to your HTML file in the <head> section to load the Google Maps API. Replace YOUR_API_KEY 
with the API key you got earlier.

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Finder</title>
    <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&callback=initMap" async defer></script>
    <style>
        /* Set the size of the map container */
        #map {
            height: 100%;
            width: 100%;
        }
        /* Set the height of the container */
        body, html {
            height: 100%;
            margin: 0;
        }
    </style>
</head>
<body>
    <div id="map"></div>

    <script>
        // Initialize the map
        function initMap() {
            // Map centered at a default location (can be set dynamically)
            const defaultCenter = { lat: 40.730610, lng: -73.935242 }; // New York coordinates (change as needed)

            const map = new google.maps.Map(document.getElementById("map"), {
                center: defaultCenter,
                zoom: 12, // Zoom level (1 - 20)
            });

            // Sample doctor data (replace this with actual data or fetch from a database)
            const doctors = [
                { name: "Dr. Smith", lat: 40.730610, lng: -73.935242 },
                { name: "Dr. Johnson", lat: 40.752726, lng: -73.977229 },
                { name: "Dr. Lee", lat: 40.758896, lng: -73.985130 },
            ];

            // Loop through the doctor data and add markers to the map
            doctors.forEach(doctor => {
                const marker = new google.maps.Marker({
                    position: { lat: doctor.lat, lng: doctor.lng },
                    map: map,
                    title: doctor.name,
                });

                // Add a click event to show a simple info window
                const infoWindow = new google.maps.InfoWindow({
                    content: `<h3>${doctor.name}</h3>`,
                });

                marker.addListener("click", () => {
                    infoWindow.open(map, marker);
                });
            });
        }
    </script>
</body>
</html>
3. Explanation of the Code:
Google Maps Script: The script is loaded with your API key and an initMap callback function. The async and defer 
attributes are used to load the script asynchronously without blocking other page content.
Map Initialization: The initMap function initializes the Google map with a specific center and zoom level.
Doctor Data: I have provided a sample array of doctors, where each doctor has a name and coordinates (latitude and 
longitude).
Markers: For each doctor, a marker is added on the map at their location.
Info Windows: When you click on a marker, an info window appears showing the doctor's name.
4. Using Dynamic Data:
If you're fetching doctor data from a server or database (e.g., through an API), you can modify the JavaScript to 
dynamically fetch this data instead of using hardcoded values.

Example with fetch:

javascript
fetch("/api/doctors")
    .then(response => response.json())
    .then(doctors => {
        doctors.forEach(doctor => {
            const marker = new google.maps.Marker({
                position: { lat: doctor.lat, lng: doctor.lng },
                map: map,
                title: doctor.name,
            });

            const infoWindow = new google.maps.InfoWindow({
                content: `<h3>${doctor.name}</h3>`,
            });

            marker.addListener("click", () => {
                infoWindow.open(map, marker);
            });
        });
    });
In this case, your backend should provide an endpoint (e.g., /api/doctors) that returns a list of doctors in JSON format.

5. Handling API Key Security:
Ensure that you:

Restrict your API key to be used only on specific domains (your website).
Set up usage limits to prevent overuse and unauthorized access.
6. Deploying Your Project:
Once you have integrated the map and doctor locations, you can deploy your project to a web server or hosting service.

Practical Example: 20) Write a Django project to display doctor locations using Google Maps API.

Creating a Django project to display doctor locations using the Google Maps API involves several steps. I'll walk you 
through setting up a Django project and integrating it with Google Maps to display doctor locations on the map. 
This guide assumes you have basic knowledge of Django and web development.

Prerequisites
Install Python and Django if you haven't already.
Create a Google Maps API key: You need a Google Maps API key to interact with Google Maps. Follow these steps to get an 
API key:
Go to Google Cloud Console.
Create a new project.
Enable the Google Maps JavaScript API and Geocoding API.
Generate an API key.
Step 1: Set Up the Django Project
Create a new Django project:

bash
django-admin startproject doctor_locator
cd doctor_locator
Create a new Django app:

bash
python manage.py startapp map
Add map app to INSTALLED_APPS in doctor_locator/settings.py:

python
INSTALLED_APPS = [
    # other apps...
    'map',
]
Install django-environ to manage environment variables (for storing the Google Maps API key securely):

bash
pip install django-environ
Configure django-environ by creating a .env file in the root directory (same as settings.py) and add your Google 
Maps API key:

bash
GOOGLE_MAPS_API_KEY=your_api_key_here
Update settings.py to use django-environ:

python
import environ

env = environ.Env()
environ.Env.read_env()

GOOGLE_MAPS_API_KEY = env('GOOGLE_MAPS_API_KEY')
Step 2: Set Up the Model for Doctor Locations
In map/models.py, define a model to store information about doctors and their locations:

python
from django.db import models

class Doctor(models.Model):
    name = models.CharField(max_length=255)
    specialty = models.CharField(max_length=100)
    address = models.CharField(max_length=255)
    latitude = models.FloatField()
    longitude = models.FloatField()

    def __str__(self):
        return self.name
After defining the model, run the following commands to create the database table:

bash
python manage.py makemigrations
python manage.py migrate
Step 3: Create Views to Display the Map
In map/views.py, create a view to display the doctor locations on the map:

python
from django.shortcuts import render
from .models import Doctor
from django.conf import settings

def map_view(request):
    doctors = Doctor.objects.all()
    google_maps_api_key = settings.GOOGLE_MAPS_API_KEY
    return render(request, 'map/map.html', {
        'doctors': doctors,
        'google_maps_api_key': google_maps_api_key
    })
Step 4: Create the Template to Display the Map
Create a templates/map folder and a map.html file inside it. This file will include the Google Maps JavaScript API to 
render the map and plot the doctor's locations.

In map/templates/map/map.html:

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Locations</title>
    <script src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initMap&v=weekly" async></script>
    <style>
        #map {
            height: 500px;
            width: 100%;
        }
    </style>
</head>
<body>
    <h1>Doctor Locations</h1>
    <div id="map"></div>

    <script>
        let map;

        function initMap() {
            // Set default map center (e.g., a city)
            map = new google.maps.Map(document.getElementById("map"), {
                zoom: 10,
                center: { lat: 40.7128, lng: -74.0060 },  // Example: New York City
            });

            // Loop through doctor locations and place markers
            {% for doctor in doctors %}
                const marker = new google.maps.Marker({
                    position: { lat: {{ doctor.latitude }}, lng: {{ doctor.longitude }} },
                    map: map,
                    title: "{{ doctor.name }} - {{ doctor.specialty }}",
                });
                const infowindow = new google.maps.InfoWindow({
                    content: "<h3>{{ doctor.name }}</h3><p>{{ doctor.specialty }}</p><p>{{ doctor.address }}</p>"
                });
                marker.addListener("click", function () {
                    infowindow.open(map, marker);
                });
            {% endfor %}
        }
    </script>
</body>
</html>
Step 5: Set Up URL Routing
In map/urls.py, create a URL pattern for the map view:

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.map_view, name='map_view'),
]
Then, include this app’s URLs in the main urls.py of the project (doctor_locator/urls.py):

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('map.urls')),  # Add this line to include map URLs
]
Step 6: Add Doctor Data (Optional)
You can add some sample doctors either by using Django Admin or by creating a data entry script:

To use Django Admin:

Register the model in map/admin.py:

python
from django.contrib import admin
from .models import Doctor

admin.site.register(Doctor)
Create a superuser and access Django admin:

bash
python manage.py createsuperuser
python manage.py runserver
Then log in to the admin panel and add some doctor locations.

Alternatively, you can create a management command or use Django’s shell to add doctor records manually.

Step 7: Run the Server
Finally, run the Django development server:

bash
python manage.py runserver
Navigate to http://127.0.0.1:8000/ in your web browser. You should see the Google Map with doctor locations marked on it. 
When you click on a marker, an info window will display the doctor's name, specialty, and address.

Summary
This guide walks you through:

Setting up a Django project and app.
Creating a model for doctors with latitude and longitude.
Using the Google Maps API to display doctor locations on a map.
Setting up URL routing and templates to render the map with doctor data.

