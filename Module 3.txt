Module #3 Introduction to OOPS Programming
1. Introduction to C++
LAB EXERCISES:
1. First C++ Program: Hello World 
o Write a simple C++ program to display "Hello, World!".// Your First C++ Program

#include <iostream>

int main() {
    std::cout << "Hello World!";
    return 0;
}

Output

Hello World!

o Objective: Understand the basic structure of a C++ program, including #include, main(), and cout.

C++ Structure
// Program to assign data to members of a structure variable

#include <iostream>
using namespace std;

struct Person
{
    string first_name;
    string last_name;
    int age;
    float salary;
};

int main()
{
    Person p1;
    
    cout << "Enter first name: ";
    cin >> p1.first_name;
    cout << "Enter last name: ";
    cin >> p1.last_name;
    cout << "Enter age: ";
    cin >> p1.age;
    cout << "Enter salary: ";
    cin >> p1.salary;

    cout << "\nDisplaying Information." << endl;
    cout << "First Name: " << p1.first_name << endl;
    cout << "Last Name: " << p1.last_name << endl;
    cout << "Age: " << p1.age << endl;
    cout << "Salary: " << p1.salary;

    return 0;
}

Output

Enter first name: Jane
Enter last name: Smith
Enter age: 27
Enter salary: 10000

Displaying Information.
First Name: Jane
Last Name: Smith
Age: 27
Salary: 10000

2. Basic Input/Output o Write a C++ program that accepts user input for their name and age and then displays a 
personalized greeting.

#include <iostream>
using namespace std;

#define MAX_LENGTH 100

int main()
{
    char name[MAX_LENGTH] = { 0 };
    int age;

    cout << "Enter name of the person: ";
    cin.getline(name, MAX_LENGTH);
    cout << "Enter age: ";
    cin >> age;

    cout << "Name: " << name << endl;
    cout << "Age: " << age << endl;

    return 0;
}


Output

Enter name of the person: Vanka Manikanth 
Enter age: 25 
Name: Vanka Manikanth
Age: 25

o Objective: Practice input/output operations using cin and cout.

#include <iostream>

using namespace std;

int main()
{
    char sample[] = "language";

    cout << sample << " - A computer science portal for language";

    return 0;
}

Output: 

language - A computer science portal for language

3. POP vs. OOP Comparison Program o Write two small programs: one using Procedural Programming (POP) to calculate the 
area of a rectangle, and another using Object-Oriented Programming (OOP) with a class and object for the same task.

// C++ program to find area
// and perimeter of rectangle
#include<iostream>
using namespace std;

// Utility function
int areaRectangle(int a, int b)
{
int area = a * b;
return area;
}

int perimeterRectangle(int a, int b)
{
int perimeter = 2*(a + b);
return perimeter;
}

// Driver code
int main()
{
int a = 5;
int b = 6;
cout << "Area = " << 
		areaRectangle(a, b) << 
		endl;
cout << "Perimeter = " << 
		perimeterRectangle(a, b);
return 0;
} 


Output: 

Area = 30
Perimeter = 22

// Program to illustrate the working of
// objects and class in C++ Programming

#include <iostream>
using namespace std;

// create a class
class Room {

   public:
    double length;
    double breadth;
    double height;

    double calculate_area() {
        return length * breadth;
    }

    double calculate_volume() {
        return length * breadth * height;
    }
};

int main() {

    // create object of Room class
    Room room1;

    // assign values to data members
    room1.length = 42.5;
    room1.breadth = 30.8;
    room1.height = 19.2;

    // calculate and display the area and volume of the room
    cout << "Area of Room =  " << room1.calculate_area() << endl;
    cout << "Volume of Room =  " << room1.calculate_volume() << endl;

    return 0;
}

Output

Area of Room =  1309
Volume of Room =  25132.8

o Objective: Highlight the difference between POP and OOP approaches

Difference between OOP and POP:

OOP	POP

Object oriented.	                                Structure oriented.

Program is divided into objects.	                Program is divided into functions.
Bottom-up approach.	                                Top-down approach.
Inheritance property is used.	                        Inheritance is not allowed.
It uses access specifier.	                        It doesn’t use access specifier.
Encapsulation is used to hide the data.	                No data hiding.
Concept of virtual function.	                        No virtual function.
Object functions are linked through message passing.	Parts of program are linked through parameter passing.
Adding new data and functions is easy	                Expanding new data and functions is not easy.
The existing code can be reused.	                No code reusability.
use for solving big problems.	                        Not suitable for solving big problems.
C++, Java.	                                        C, Pascal.

4. Setting Up Development Environment o Write a program that asks for two numbers and displays their sum. Ensure this 
is done after setting up the IDE (like Dev C++ or CodeBlocks).

#include <iostream>
using namespace std;

int main() {

  int first_number, second_number, sum;
    
  cout << "Enter two integers: ";
  cin >> first_number >> second_number;

  // sum of two numbers in stored in variable sumOfTwoNumbers
  sum = first_number + second_number;

  // prints sum 
  cout << first_number << " + " <<  second_number << " = " << sum;     

  return 0;
}

Output

Enter two integers: 4
5
4 + 5 = 9

o Objective: Help students understand how to install, configure, and run programs in an IDE.

An integrated development environment, put simply, is everything a programmer needs to get their work done. The actual 
makeup of an IDE will vary between programming languages, types of projects, and even between programmers, but there are 
some things that are common among a lot of IDEs, which I'll cover below.

The simplest way to understand an IDE is to consider an "all-in-one" solution like Unity. As a fully-featured game 
engine, Unity has everything you'll need to create a 2D or 3D game: a GUI that allows you to build your game world, a 
code editor (Visual Studio) where you can write scripts, a way to download dependencies and assets, and even GitHub 
integration so that you can keep track of build versions and collaborate on projects. For smaller projects, Unity can be 
thought of as a fully functional integrated development environment, where everything is already set up for you after 
downloading the game engine.

Other IDEs can vary greatly in complexity, particularly if you're coming from an online tutorial that allows you to code 
right in the browser. One of my gripes with common answers to the question, "what programming language should I learn?" 
is the notion that learning JavaScript is easier because "it just runs in your browser."

Tell that to anyone who's attempted to set up an IDE for Create React App, which requires several components to get up 
and running - none of which are apparent when you're working through online tutorials. To actually do work as a developer,
you'll need four main things to set up your integrated development environment: a code editor, command line interface 
(CLI), version control system, and package manager.

Major caveat: your IDE may vary greatly depending on programming language or type of project, but you'll likely need one 
or more of the following in any case!

IDE Tool #1: Code Editor (and Compiler)
A whole bunch of online tutorials allow you to just code in the browser, which is great for understanding basic 
programming concepts, but in the long run, you'll need an editor that allows you to save your code (and compile it, 
if you're using a language like C# or C++).

There are a lot of code editors out there, such as Atom (lightweight, free, and open source), Sublime (super popular 
with tons of integrations), and Visual Studio / Visual Studio Code (supported by Microsoft and wonderful to work with). 
It would be reductive to say that they're "all the same thing," as each one provides a different approach to supporting 
your coding workflow, so you might try one or two before deciding which one you like best.

IDE Tool #2: Command Line Interface (CLI)
If you have a computer, you've undoubtedly used your file explorer or some other navigational GUI to access the file 
system, create folders, delete files, and so on.

The command line interface (CLI) allows you to do the same thing...in plain text. Which might seem super archaic or 
annoying at first, but once you wrap your head around chaining commands together and integrating them into your workflow, 
you'll begin to see the power of the CLI and how essential it is to most development environments.

On Mac, you might be using the Terminal. Because I've installed GitHub for Windows (more on GitHub below) on my machine, 
I use Git Bash for my work. There are several options here for you, and it might do to check out a few command line 
tutorials to understand some of the basic principles so that you feel comfortable using it in your IDE.

IDE Tool #3: Version Control System
There are several resources out there that provide overviews of what is version control and why you should use it. 
Suffice it to say that when you're building anything other than a simple project, you'll need a way to back up your work, 
share your code with collaborators, and keep track of the different build versions so that you can muck with parts of 
the code base and not others.

GitHub isn't the only version control system out there, but it is the gold standard at the moment, and it would be worth 
your while to look up a few tutorials to learn how to take advantage of its features, even if you just wind up using it 
as a remote backup method.

Additionally, while there are several addons to integrate GitHub right into your code editor (or game engine), the 
standard practice for doing Git-related tasks is by using the command line interface, which provides another reason 
for becoming proficient with your CLI of choice.

IDE Tool #4: Package Manager
For some IDEs, like with our Unity example above, all you need to do is download and install software to get started 
with building your projects. Most of the dependencies that you'll need will be included with your initial download, and 
if not, there will be a way to access them from within the game engine (e.g. Unity's Asset Store).

For other, more choose-your-own-adventure IDEs, you'll need to piece things together yourself, and one of the essential 
components will be a package manager like NPM or Conda.

Package managers do a lot of things, and at their most basic functionality, they'll help you to install all the 
dependencies you'll need to get your work done. If you want to get started on a React project, for example, you'll 
navigate to a folder through your CLI, and, after installing NPM (which is bundled with Node.js) type:

npx create-react-app my-app 
cd my-app 
npm start
The first line basically says: "Hey, NPM! Download all the dependencies for Create React App, and put them in a folder 
called 'my-app.'"

The second line then tells your CLI: "Navigate to the new directory called 'my-app.'"

The third line gets the action going: "NPM, it's me again. Start a development server that displays my project in a 
browser and updates it whenever I make changes to the code."

Once you've installed all of the necessary dependencies using your package manager, you'll begin working in your code 
editor and using the command line interface to make pull requests or push code to a remote repository using your 
version control system.

THEORY EXERCISE:
1. What are the key differences between Procedural Programming and Object-Oriented Programming (OOP)?

Procedural Oriented Programming

In procedural programming, the program is divided into small parts called functions.
Procedural programming follows a top-down approach.
There is no access specifier in procedural programming.
Adding new data and functions is not easy.	
Procedural programming does not have any proper way of hiding data so it is less secure.
In procedural programming, overloading is not possible.
In procedural programming, there is no concept of data hiding and inheritance.
In procedural programming, the function is more important than the data.
Procedural programming is based on the unreal world.
Procedural programming is used for designing medium-sized programs.
Procedural programming uses the concept of procedure abstraction.
Code reusability absent in procedural programming,
Examples: C, FORTRAN, Pascal, Basic, etc.

Object-Oriented Programming

In object-oriented programming, the program is divided into small parts called objects.
Object-oriented programming follows a bottom-up approach.
Object-oriented programming has access specifiers like private, public, protected, etc.
Adding new data and function is easy.
Object-oriented programming provides data hiding so it is more secure.
Overloading is possible in object-oriented programming.
In object-oriented programming, the concept of data hiding and inheritance is used.
In object-oriented programming, data is more important than function.
Object-oriented programming is based on the real world.
Object-oriented programming is used for designing large and complex programs.
Object-oriented programming uses the concept of data abstraction.
Code reusability present in object-oriented programming.
Examples: C++, Java, Python, C#, etc.

2. List and explain the main advantages of OOP over POP.

OOP supports inheritance and virtual functions and virtual classes via it. There is no concept of inheritance in POP and 
neither does it support the use of virtual classes or virtual functions. OOP supports code reusability. No code 
reusability is provided by POP.

Benefits of OOP
We can build the programs from standard working modules that communicate with one another, rather than having to start 
writing the code from scratch which leads to saving of development time and higher productivity,
OOP language allows to break the program into the bit-sized problems that can be solved easily (one object at a time).
The new technology promises greater programmer productivity, better quality of software and lesser maintenance cost.
OOP systems can be easily upgraded from small to large systems.
It is possible that multiple instances of objects co-exist without any interference,
It is very easy to partition the work in a project based on objects.
It is possible to map the objects in problem domain to those in the program.
The principle of data hiding helps the programmer to build secure programs which cannot be invaded by the code in other 
parts of the program.
By using inheritance, we can eliminate redundant code and extend the use of existing classes.
Message passing techniques is used for communication between objects which makes the interface descriptions with external 
systems much simpler.
The data-centered design approach enables us to capture more details of model in an implementable form.

3. Explain the steps involved in setting up a C++ development environment.

C++ is a general-purpose programming language and is widely used nowadays for competitive programming. It has imperative, 
object-oriented, and generic programming features. 
C++ runs on lots of platforms like Windows, Linux, Unix, Mac, etc. Before we start programming with C++. We will need 
an environment to be set up on our local computer to compile and run our C++ programs successfully. If you do not 
want to set up a local environment you can also use online IDEs for compiling your program.

Using Online IDE
IDE stands for an integrated development environment. IDE is a software application that provides facilities to a 
computer programmer for developing software. There are many online IDEs available that you can use to compile and 
run your programs easily without setting up a local development environment.

// Using online ide of C++ 
#include <iostream>
using namespace std;

int main()
{
	cout << "Learning C++ language";
	return 0;
}

Output
Learning C++ at language

Setting up a Local Environment
For setting up a C++ Integrated Development Environment (IDE) on your local machine you need to install two important 
software:

C++ Compiler
Text Editor
1. C++ Compiler
Once you have installed the text editor and saved your program in a file with the ‘.cpp’ extension, you will need a 
C++ compiler to compile this file. A compiler is a computer program that converts high-level language into 
machine-understandable low-level language. In other words, we can say that it converts the source code written in a 
programming language into another computer language that the computer understands. For compiling a C++ program we will 
need a C++ compiler that will convert the source code written in C++ into machine codes. Below are the details about 
setting up compilers on different platforms.

Installing GNU GCC on Linux
We will install the GNU GCC compiler on Linux. To install and work with the GCC compiler on your Linux machine, 
proceed according to the below steps: 

A. You have to first run the below two commands from your Linux terminal window: 

sudo apt-get update
sudo apt-get install gcc
sudo apt-get install g++
B. This command will install the GCC compiler on your system. You may also run the below command:

sudo apt-get install build-essential
This command will install all the libraries which are required to compile and run a C++ program.
 
C. After completing the above step, you should check whether the GCC compiler is installed in your system correctly or not. 
To do this you have to run the below-given command from the Linux terminal:

g++ --version
D. If you have completed the above two steps without any errors, then your Linux environment is set up and ready to be 
used to compile C++ programs. In further steps, we will learn how to compile and run a C++ program on Linux using the 
GCC compiler. 
 
E. Write your program in a text file and save it with any file name and.CPP extension. We have written a program to 
display “Hello World” and saved it in a file with the filename “helloworld.cpp” on the desktop. 
 
F. Now you have to open the Linux terminal and move to the directory where you have saved your file. Then you have to 
run the below command to compile your file: 

g++ filename.cpp -o any-name
G. filename.cpp is the name of your source code file. In our case, the name is “helloworld.cpp” and any-name can be 
any name of your choice. This name will be assigned to the executable file which is created by the compiler after 
compilation. In our case, we choose any-name to be “hello”. 
We will run the above command as: 

g++ helloworld.cpp -o hello
H. After executing the above command, you will see a new file is created automatically in the same directory where you 
have saved the source file and the name of this file is the name you chose as any-name. 
Now to run your program you have to run the below command: 

./hello
I. This command will run your program in the terminal windows.

2. Text Editor
Text Editors are the type of programs used to edit or write texts. We will use text editors to type our C++ programs. 
The normal extension of a text file is (.txt) but a text file containing a C++ program should be saved with a ‘.cpp’ or 
‘.c’ extension. Files ending with the extension ‘.CPP’ and ‘.C’ are called source code files and they are supposed to 
contain source code written in C++ programming language. These extension helps the compiler to identify that the file 
contains a C++ program. 
Before beginning programming with C++, one must have a text editor installed to write programs. Follow the below 
instructions to install popular code editors like VS Code and Code::Block on different Operating Systems like windows, 
Mac OS, etc.

1. Code::Blocks Installation
There are lots of IDE available that you can use to work easily with the C++ programming language. One of the popular 
IDE is Code::Blocks.

To download Code::Blocks, select the setup package based on your OS from this link – Code::Blocks Setup Packages.
Once you have downloaded the setup file of Code::Blocks from the given link open it and follow the instruction to install.
After successfully installing Code::Blocks, go to File menu -> Select New and create an Empty file.
Now write your C++ program in this empty file and save the file with a ‘.cpp’ extension.
After saving the file with the ‘.cpp’ extension, go to the Build menu and choose the Build and Run option.
2. XCode Mac OS X Installation
If you are a Mac user, you can download Xcode as a code editor.

To download Xcode you have to visit the apple website or you can search for it on the apple app store. You may follow 
the link – Xcode for MacOS to download Xcode. You will find all the necessary installation instructions there.
After successfully installing Xcode, open the Xcode application. 
To create a new project. Go to File menu -> select New -> select Project. This will create a new project for you. 
Now in the next window, you have to choose a template for your project. To choose a C++ template choose the Application 
option which is under the OS X section on the left sidebar. Now choose command-line tools from available options and 
hit the Next button. 
On the next window provide all the necessary details like ‘name of organization’, ‘Product Name, etc. But make sure to 
choose the language as C++. After filling in the details hit the next button to proceed to further steps. 
Choose the location where you want to save your project. After this choose the main.cpp file from the directory list on 
the left sidebar.
Now after opening the main.cpp file, you will see a pre-written c++ program or template provided. You may change this 
program as per your requirement. To run your C++ program you have to go to the Product menu and choose the Run option 
from the dropdown.
Another very easy-to-use and most popular IDE nowadays, is VSC( Visual Studio Code), for both Windows and Mac OS.

3. Installing VS Code on Windows
Start with installing Visual Studio Code as per your windows. Open the downloaded file and click Run -> 
(Accept the agreement) Next -> Next -> Next -> (check all the options) -> Next ->Install->Finish. 
Now you’ll be able to see the Visual Studio Code icon on your desktop.

Download the MinGW from the link.
After Install, “Continue”. Check all the Packages (Right Click -> Mark for Installation). Now, Click on Installation 
(left corner) -> Apply Changes. (This may take time)
Open This PC -> C Drive -> MinGW -> Bin. (Copy this path)
Right, Click on “This PC” -> Properties -> Advanced System Setting -> Environment variables ->  (Select PATH in System 
variables) -> Edit -> New -> Paste the path here and OK.
Go to Visual Studio Code, and Install some useful extensions (from the right sidebar, last icon(probably))-
C/C++
Code Runner
 Now, Go to Setting -> Settings -> Search for Terminal -> Go to the end of this page -> Check [ Code-runner: Run In 
Terminal ]
Yay!  You are good to go now. Open any folder, create new files and Save them with the extension “.cpp”. 

4. Installing VS Code on Mac OS
First of all, Install Visual Studio Code for Mac OS using this link. Then We’ll install the compiler MinGW. For this, 
we first need to install Homebrew.

To install Homebrew, Open Terminal (cmd + space). Write Terminal and hit Enter. In cmd copy the given command 

arch -x86_64 ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install)" < /dev/null 2> 
/dev/null
This will download and install HomeBrew on your Mac system. This process may take time.

Now We’ll install the MinGW compiler on Mac OS. Paste the given command in the terminal and press Enter.

arch -x86_64 brew install MinGW-w64
This is also time taking process so be patient!     
Go to Visual Studio Code, and Install some useful extensions (from the right sidebar, last icon(probably))-
C/C++
Code Runner
Now, Go to Setting -> Settings -> Search for Terminal -> Go to the end of this page -> Check [ Code-runner:  Run In 
Terminal ]


4. What are the main input/output operations in C++? Provide examples.

C++ comes with libraries that provide us with many ways for performing input and output. In C++ input and output are 
performed in the form of a sequence of bytes or more commonly known as streams.

Input Stream: If the direction of flow of bytes is from the device(for example, Keyboard) to the main memory then 
this process is called input.
Output Stream: If the direction of flow of bytes is opposite, i.e. from main memory to device( display screen ) then 
this process is called output.

Header files available in C++ for Input/Output operations are: 

iostream: iostream stands for standard input-output stream. This header file contains definitions of objects like cin, 
cout, cerr, etc.
iomanip: iomanip stands for input-output manipulators. The methods declared in these files are used for manipulating 
streams. This file contains definitions of setw, setprecision, etc.
fstream: This header file mainly describes the file stream. This header file is used to handle the data being read from 
a file as input or data being written into the file as output.
bits/stdc++: This header file includes every standard library. In programming contests, using this file is a good idea, 
when you want to reduce the time wasted in doing chores; especially when your rank is time sensitive.

In C++ after the header files, we often use ‘using namespace std;‘. The reason behind it is that all of the standard 
library definitions are inside the namespace std. As the library functions are not defined at global scope, so in order 
to use them we use namespace std. So, that we don’t need to write STD:: at every line (eg. STD::cout etc.).

The two instances cout in C++ and cin in C++ of iostream class are used very often for printing outputs and taking 
inputs respectively. These two are the most basic methods of taking input and printing output in C++. To use cin and 
cout in C++ one must include the header file iostream in the program.

Understanding input and output operations is essential for any C++ programmer. The C++ Course includes comprehensive 
lessons on basic I/O operations, ensuring you can manage user interaction in your programs.

This article mainly discusses the objects defined in the header file iostream like the cin and cout.  

Standard output stream (cout): Usually the standard output device is the display screen. The C++ cout statement is the 
instance of the ostream class. It is used to produce output on the standard output device which is usually the display 
screen. The data needed to be displayed on the screen is inserted in the standard output stream (cout) using the insertion
operator(<<).

#include <iostream>

using namespace std;

int main()
{
    char sample[] = "language";

    cout << sample << " - computer science ";

    return 0;
}

Output
language - computer science

In the above program, the insertion operator(<<) inserts the value of the string variable sample followed by the 
string “A computer science portal for geeks” in the standard output stream cout which is then displayed on the screen.

standard input stream (cin): Usually the input device in a computer is the keyboard. C++ cin statement is the instance 
of the class istream and is used to read input from the standard input device which is usually a keyboard. 
The extraction operator(>>) is used along with the object cin for reading inputs. The extraction operator extracts 
the data from the object cin which is entered using the keyboard.

#include <iostream>
using namespace std;

int main()
{
    int age;

    cout << "Enter your age:";
    cin >> age;
    cout << "\nYour age is: " << age;

    return 0;
}

Input : 

18
Output: 

Enter your age:
Your age is: 18

The above program asks the user to input the age. The object cin is connected to the input device. The age entered by 
the user is extracted from cin using the extraction operator(>>) and the extracted data is then stored in the variable 
age present on the right side of the extraction operator.

Un-buffered standard error stream (cerr): The C++ cerr is the standard error stream that is used to output the errors. 
This is also an instance of the iostream class. As cerr in C++ is un-buffered so it is used when one needs to display 
the error message immediately. It does not have any buffer to store the error message and display it later.
The main difference between cerr and cout comes when you would like to redirect output using “cout” that gets redirected 
to file if you use “cerr” the error doesn’t get stored in file.(This is what un-buffered means ..It cant store the message)

#include <iostream>

using namespace std;

int main()
{
    cerr << "An error occurred";
    return 0;
}

Output: 

An error occurred

buffered standard error stream (clog): This is also an instance of ostream class and used to display errors but 
unlike cerr the error is first inserted into a buffer and is stored in the buffer until it is not fully filled. or 
the buffer is not explicitly flushed (using flush()). The error message will be displayed on the screen too.

#include <iostream>

using namespace std;

int main()
{
    clog << "An error occurred";

    return 0;
}

Output: 

An error occurred


LAB EXERCISES:
1. Variables and Constants o Write a C++ program that demonstrates the use of variables and constants. 
Create variables of different data types and perform operations on them.

Variables in C++ is a name given to a memory location. It is the basic unit of storage in a program. 

The value stored in a variable can be changed during program execution.
A variable is only a name given to a memory location, all the operations done on the variable effects that memory location.
In C++, all the variables must be declared before use.

How to Declare Variables?
// Declaring a single variable
type variable_name;

// Declaring multiple variables:
type variable1_name, variable2_name, variable3_name;

Examples:  

// Declaring float variable
float simpleInterest; 

// Declaring integer variable
int time, speed; 

// Declaring character variable
char var;  

int a=50,b=100;  //declaring 2 variable of integer type    
float f=50.8;  //declaring 1 variable of float type     
char c='Z';    //declaring 1 variable of char type   

Rules For Declaring Variable
The name of the variable contains letters, digits, and underscores.
The name of the variable is case sensitive (ex Arr and arr both are different variables).
The name of the variable does not contain any whitespace and special characters (ex #,$,%,*, etc).
All the variable names must begin with a letter of the alphabet or an underscore(_). 
We cannot used C++ keyword(ex float,double,class)as a variable name.

Valid variable names:

int x;   //can be letters 
int _yz; //can be underscores   
int z40;//can be letters    
Invalid variable names:

int 89; Should not be a number   
int a b; //Should not contain any whitespace    
int double;// C++ keyword CAN NOT BE USED  

// C++ program to show difference between
// definition and declaration of a 
// variable
#include <iostream>
using namespace std;

int main()
{
    // this is declaration of variable a
    int a;
  
    // this is initialisation of a
    a = 10;
  
    // this is definition = declaration + initialisation
    int b = 20;

    // declaration and definition
    // of variable 'a123'
    char a123 = 'a';

    // This is also both declaration and definition
    // as 'c' is allocated memory and
    // assigned some garbage value.
    float c;

    // multiple declarations and definitions
    int _c, _d45, e;

    // Let us print a variable
    cout << a123 << endl;

    return 0;
}

Output
a

Types of Variables
There are three types of variables based on the scope of variables in C++

Local Variables
Instance Variables
Static Variables

Instance Variable Vs Static Variable
Each object will have its own copy of the instance variable whereas We can only have one copy of a static variable per 
class irrespective of how many objects we create.
Changes made in an instance variable using one object will not be reflected in other objects as each object has its own 
copy of the instance variable. In the case of static, changes will be reflected in other objects as static variables are 
common to all objects of a class.
We can access instance variables through object references and Static Variables can be accessed directly using the class 
name.
The syntax for static and instance variables:
class Example
{
    static int a; // static variable
    int b;        // instance variable
}

c++ Data Type

All variables use data type during declaration to restrict the type of data to be stored. Therefore, we can say that 
data types are used to tell the variables the type of data they can store. Whenever a variable is defined in C++, 
the compiler allocates some memory for that variable based on the data type with which it is declared. Every data type 
requires a different amount of memory. 

C++ supports a wide variety of data types and the programmer can select the data type appropriate to the needs of 
the application. Data types specify the size and types of values to be stored. However, storage representation and 
machine instructions to manipulate each data type differ from machine to machine, although C++ instructions are 
identical on all machines.

C++ supports the following data types:

Primary or Built-in or Fundamental data type
Derived data types
User-defined data types

Data Types in C++ are Mainly Divided into 3 Types: 
1. Primitive Data Types: These data types are built-in or predefined data types and can be used directly by the user to 
declare variables. example: int, char, float, bool, etc. Primitive data types available in C++ are: 

Integer
Character
Boolean
Floating Point
Double Floating Point
Valueless or Void
Wide Character
2. Derived Data Types: Derived data types that are derived from the primitive or built-in datatypes are referred to as 
Derived Data Types. These can be of four types namely: 

Function
Array
Pointer
Reference
3. Abstract or User-Defined Data Types: Abstract or User-Defined data types are defined by the user itself. Like, 
defining a class in C++ or a structure. C++ provides the following user-defined datatypes:  

Class
Structure
Union
Enumeration
Typedef defined Datatype

// C++ Program to Demonstrate the correct size
// of various data types on your computer.
#include <iostream>
using namespace std;

int main()
{
    cout << "Size of char : " << sizeof(char) << endl;
    cout << "Size of int : " << sizeof(int) << endl;

    cout << "Size of long : " << sizeof(long) << endl;
    cout << "Size of float : " << sizeof(float) << endl;

    cout << "Size of double : " << sizeof(double) << endl;

    return 0;
}

Output
Size of char : 1
Size of int : 4
Size of long : 8
Size of float : 4
Size of double : 8

Advantages:

Data types provide a way to categorize and organize data in a program, making it easier to understand and manage.
Each data type has a specific range of values it can hold, allowing for more precise control over the type of data being 
stored.
Data types help prevent errors and bugs in a program by enforcing strict rules about how data can be used and manipulated.
C++ provides a wide range of data types, allowing developers to choose the best type for a specific task.


Disadvantages:

Using the wrong data type can result in unexpected behavior and errors in a program.
Some data types, such as long doubles or char arrays, can take up a large amount of memory and impact performance if 
used excessively.
C++’s complex type system can make it difficult for beginners to learn and use the language effectively.
The use of data types can add additional complexity and verbosity to a program, making it harder to read and understand.

Data type modifiers available in C++ are: 

Signed
Unsigned
Short
Long

Constants
Constants are program components whose value does not change from the beginning to the end of the program. Constants 
with the following data types can be used in C++:

Integer Constants
Decimal Constants
Character Constants
String Constants
Integer Constants
There are three types: 'int' (integer), 'short' (short integer) and 'long' (long integer). Let's take 1995 as an 
example and explain the job of defining the type of an integer in this example.

To indicate which type a constant belongs to, a character is added to the end of that constant to indicate its type. 
If a numeric expression does not have any characters at the end, the type of that expression is 'int'. In this case, 
the expression 1995 in our example is an integer of type 'int'. To designate this expression as type 'long' we need to 
append 'l' or 'L' character:

1995l or 1995L. That way the expression now belongs to type 'long' and not type 'int' an example and explain the job of 
defining the type of an integer in this example.

Also, integers that cross the 'int' type limits in the flow of the program are automatically converted to 'long', even 
if they do not have a trailing 'l' or 'L' suffix.

There is a special case for the 'short' type. When calculating the value of an expression, it is treated like 'int' 
even though it belongs to type 'short'. In this case, we can say that there is no constant of type 'short'. Because 
constants within the bounds of 'short' are considered as type 'int' by C++.

Floating Constants
There are three types: 'float' (floating decimal), 'double' (double decimal) and 'long double' (long decimal). Let's 
take the expression 1881.1938 as an example and explain the job of defining the type of an integer in this example.

If a decimal constant does not have any characters at the end, the type of that expression is considered 'double'. 
In this case, 1881.1938 in our example is a decimal constant of type 'double'. To designate this expression as a type 
'float' we need to append the 'f' or 'F' character: 1881.1938f or 1881.1938F. This way the expression no longer belongs 
to the 'double' type but of the 'float' type.

Although not often used, to specify a decimal constant of type 'long double', we must append the character 'l' or 'L': 
1881.1938l or 1881.1938L.

Character Constants
We know that type 'char' takes a value between -128 and +127 or 0 and +255. Well, since these constants are named 
'characters' and have an alphabetic nature, why are we still talking about numerical expressions?

Because every character used in C++ has a numeric equivalent in the **ASCII (American Standard Code for Information 
Interchange) **table, and these numbers, in which the character constants are kept within the specified ranges, are the 
ASCII equivalents of the characters used. In other words; When we talk about 97 as the character constant, we are actually 
talking about the character 'a', which is the ASCII table equivalent of 97.

When using character constants, we can use the numeric equivalents of the characters. Of course, the commonly preferred 
usage in C++ is to use the characters themselves. However, when we are going to use the characters themselves, we must 
enclose these characters in single quotes (').

 two variables of type char are defined and the constants 103 and 'g' are assigned to these variables, respectively.

char character1=103; 
char character2='g'; 
Since the numeric equivalent of the 'g' character in the ASCII table is 103, these two lines actually mean the same thing. However, pay special attention to the fact that the 'g' character is written in single quotation marks.

String Constants
'string' (character) literals consist of sequentially ordered strings of character literals. In C++, every expression 
enclosed in double quotes (") is a constant of type 'string'. Consider the following examples:

“Fatih"	"1995"	"1920.1923"	"Harvard University"
As you can see, numeric expressions enclosed in double quotes are now a 'string' constant. We can no longer do numerical 
operations such as addition and subtraction with them.

Actually there is no type named 'string' in C++. The 'string' type occurs when the compiler treats multiple character 
constants as a string of characters. Accordingly, the expression "Fatih" would actually work like this:

'F' 'a' 't' 'i' 'h'

The compiler treats all these characters as a string and puts them together by adding the '\0' character to the end.

Constants are defined with the word const in the C++ program, and the following definitions are made to declare the data 
type of the invariant to be used:

int const constant name = value;
char const constant name = 'value';
Code:

#include <iostream>
using namespace std;

int const age = 15;
char const gender = 'M';

int main() 
{
   cout << " Age: " << age <<"\n";
   cout << " Gender: " << gender <<"\n";

   return 0; 
} 
Output:

Age: 15
Gender: M

Type Conversion
Variables or constants in our programs can be of different types. If this is the case, it is important what type of 
calculation result will be in our mathematical operations. Therefore, type conversion must be done to avoid an error.

Code:

#include <iostream>
using namespace std;

int main(){

  int num=9; 
  float a,b,c; 

  a=num/4; 
  b=num/4.0; 
  c=(float)num/4; 

  cout << "a value= " << a << endl; 
  cout << "b value= " << b << endl; 
  cout << "c value= " << c << endl; 

return 0; 
}
Output:

a value= 2
b value= 2.25
c value= 2.25


o Objective: Understand the difference between variables and constants.

Constant

A constant is a variable or value that cannot be altered once defined.
A constant is used to hold the fixed values which we can retrieve later but cannot change.
The constants are generally stored in the text segment as they are read-only
We can only assign a value to the constant while defining it.
A constant can be defined by using #define or const keyword.
Example: #define pi 3.14

const int pi = 3.14;

Variables

A variable is a name associated with some memory location.
A variable is used to hold some value that can be changed according to the requirement.
The variables are stored inside a data segment, heap, or stack depending on the environment it
is declared in.
We can assign value to the variable anytime.
A variable can only be defined using the standard variable definition syntax.
Example: int var = 25;

var = 10;

2. Type Conversion o Write a C++ program that performs both implicit and explicit type conversions and prints the results.

Type conversion is essential for managing different data types in C++. The C++ Course covers the various methods of type 
conversion, helping you understand how to handle data types correctly. A type cast is basically a conversion from one 
type to another. There are two types of type conversion:

Implicit Type Conversion Also known as ‘automatic type conversion’.
Done by the compiler on its own, without any external trigger from the user.
Generally takes place when in an expression more than one data type is present. In such condition type conversion 
(type promotion) takes place to avoid lose of data.
All the data types of the variables are upgraded to the data type of the variable with largest data type.
bool -> char -> short int -> int -> 

unsigned int -> long -> unsigned -> 

long long -> float -> double -> long double
It is possible for implicit conversions to lose information, signs can be lost (when signed is implicitly converted to 
unsigned), and overflow can occur (when long long is implicitly converted to float).

// An example of implicit conversion

#include <iostream>
using namespace std;

int main()
{
    int x = 10; // integer x
    char y = 'a'; // character c

    // y implicitly converted to int. ASCII
    // value of 'a' is 97
    x = x + y;

    // x is implicitly converted to float
    float z = x + 1.0;

    cout << "x = " << x << endl
         << "y = " << y << endl
         << "z = " << z << endl;

    return 0;
}

Output
x = 107
y = a
z = 108

Explicit Type Conversion: This process is also called type casting and it is user-defined. Here the user can typecast 
the result to make it of a particular data type. In C++, it can be done by two ways:
Converting by assignment: This is done by explicitly defining the required type in front of the expression in parenthesis. 
This can be also considered as forceful casting. Syntax:
(type) expression

// C++ program to demonstrate
// explicit type casting

#include <iostream>
using namespace std;

int main()
{
    double x = 1.2;

    // Explicit conversion from double to int
    int sum = (int)x + 1;

    cout << "Sum = " << sum;

    return 0;
}

Output
Sum = 2

Advantages of Type Conversion:

This is done to take advantage of certain features of type hierarchies or type representations.
It helps to compute expressions containing variables of different data types.

o Objective: Practice type casting in C++.

1. Type Casting: In typing casting, a data type is converted into another data type by the programmer using the casting 
operator during the program design. In typing casting, the destination data type may be smaller than the source data 
type when converting the data type to another data type, that’s why it is also called narrowing conversion. 

Syntax/Declaration:-

destination_datatype = (target_datatype)variable;


(): is a casting operator.
target_datatype: is a data type in which we want to convert the source data type. 

Type Casting example –

float x;
byte y;
...
...
y=(byte)x;  //Line 5

TYPE CASTING

In type casting, a data type is converted into another data type by a programmer using casting operator
Type casting can be applied to compatible data types as well as incompatible data types.
In type casting, casting operator is needed in order to cast a data type to another data type.
In typing casting, the destination data type may be smaller than the source data type, when converting the data type 
to another data type.
Type casting takes place during the program design by programmer.
Type casting is also called narrowing conversion because in this, the destination data type may be smaller than the 
source data type.
Type casting is often used in coding and competitive programming works.
Type casting is more efficient and reliable.

3. Operator Demonstration
o Write a C++ program that demonstrates arithmetic, relational, logical, and bitwise operators. Perform operations using 
each type of operator and display the results.

Arithmetic Operators
These operators perform basic mathematical operations like addition, subtraction, multiplication, and division. 
We will categorize the arithmetic operators into two categories based on the number of operands and then look at their 
functionality.
Type	Operator	Name of Operator	Functionality
Unary	++	Increment	Increases the value by 1
- -	Decrement	Decreases the value by 1
+	Unary plus	No change in the operand value
-	Unary minus	changes the negative number to the positive and vice-versa
Binary	+	Addition	Add two values
-	Subtraction	Subtracts one value from the other
*	Multiplication	Multiplies two values
/	Division	Divides one by the other value
%	Modulus	Finds the remainder after division

Example to demonstrate Arithmetic Operators in C++

#include <iostream>
using namespace std;
int main() {
 // Unary operators
 int x = 5, y = 6, z = 7, w = 8;
 cout << ++x << endl; // Increments the value of x
 cout << --y << endl; // Decrements the value of y
 cout << +z << endl; // Unary +
 cout << -w << endl; // Unary - on a positive number
 cout << -(-w) << endl; // Unary - on a negative number

 // Binary operators
 int a = 10, b = 3;
 int sum = a + b;
 int difference = a - b;
 int product = a * b;
 int quotient = a / b;
 int remainder = a % b;

 cout << "Sum: " << sum << endl;
 cout << "Difference: " << difference << endl;
 cout << "Product: " << product << endl;
 cout << "Quotient: " << quotient << endl;
 cout << "Remainder: " << remainder << endl;

 return 0;
}

Output
6
5
7
-8
8
Sum: 13
Difference: 7
Product: 30
Quotient: 3
Remainder: 1

Relational Operators
They are also known as Comparison Operators. They compare the values of the two operands. The result of the comparison is 
either true or false. If the comparison is true, it returns 1; If the comparison results in false, it returns 0. 
These are known as boolean values.
Operator	Name
==	Equal to
>	Greater than
<	Less than
>=	Greater than or equal to
<=	Less than or equal to
!=	Not equal to
Example to demonstrate relational operators in C++

#include <iostream>
using namespace std;
int main() {
 int x = 5;
 int y = 3;
 
 cout << (x == y) << endl; // returns 0 (false) because 5 is not equal to 3
 cout << (x != y) << endl; // returns 1 (true) because 5 is not equal to 3
 cout << (x > y) << endl; // returns 1 (true) because 5 is greater than 3
 cout << (x < y) << endl; // returns 0 (false) because 5 is not less than 3
 cout << (x >= y) << endl; // returns 1 (true) because 5 is greater than or equal to 3
 cout << (x <= y) << endl; // returns 0 (false) because 5 is not less than or equal to 3
 
 return 0;
}

Output
0
1
1
0
1
0 

Logical Operators
They are used to combine two or more conditions/constraints. It returns either 0 or 1 depending upon whether the 
expression results in true or false. If the result is true, it returns 1 else returns 0.
The logical operators are used in decision-making and looping statements.

We will categorize the logical operators into two categories based on the number of operands and then look at their 
functionality.

Type	Operator	Name	Functionality
Binary	&&	Logical AND	returns 1(true) if both the expressions/values are true.
||	Logical OR	returns 1(true) if one of the expressions/values evaluates to true.
Unary	!=	Logical NOT	Negates the expression and returns 1 or 0.
Example to demonstrate logical operators in C++ Online Compiler

#include <iostream>
using namespace std;
int main() {
 int a = 1, b = 0;

 if (a && b) {
 cout << "Both a and b are true (non-zero)" << endl;
 } else {
 cout << "At least one of a or b is false (zero)" << endl;
 }

 if (a || b) {
 cout << "At least one of a or b is true (non-zero)" << endl;
 } else {
 cout << "Both a and b are false (zero)" << endl;
 }

 if (!b) { // value of b becomes 1
 cout << "b is false (zero)" << endl;
 } else {
 cout << "b is true (non-zero)" << endl;
 }

 return 0;
}

Output
At least one of a or b is false (zero)
At least one of a or b is true (non-zero)
b is false (zero)

Bitwise Operators
These operators work on individual bits. The operands are first converted into bits i.e. 0 or 1, and then the calculation 
is performed on them.
We will categorize the bitwise operators into two categories based on the number of operands and then look at their 
functionality.

Type	Operator	Name
Unary	~	One's complement or Bitwise Complement
<<	Left Shift
>>	Right Shift
Binary	&	Bitwise AND
|	Bitwise OR
^	Bitwise Exclusive OR or XOR
Assignment Operators
These are used to assign values to the variables. The most fundamental assignment operator is =.
Example to demonstrate assignment operators in C++

#include <iostream>
using namespace std;
int main() {
 int x;
 x = 10; // Assigning the value 10 to x
 cout << "The value of x is: " << x << endl;
 return 0;
}

Output
The value of x is: 10

o Objective: Reinforce understanding of different types of operators in C++.

An operator is a symbol that operates on a value to perform specific mathematical or logical computations. They form the 
foundation of any programming language. In C++, we have built-in operators to provide the required functionality.

An operator operates the operands. For example, 

int c = a + b;
Here, ‘+’ is the addition operator. ‘a’ and ‘b’ are the operands that are being ‘added’.

Operators in C++ can be classified into 6 types:

Arithmetic Operators
Relational Operators
Logical Operators
Bitwise Operators
Assignment Operators
Ternary or Conditional Operators

1) Arithmetic Operators
These operators are used to perform arithmetic or mathematical operations on the operands. For example, ‘+’ is used for 
addition, ‘-‘ is used for subtraction ‘*’ is used for multiplication, etc. 

Arithmetic Operators can be classified into 2 Types:

A) Unary Operators: These operators operate or work with a single operand. For example: Increment(++) and Decrement(–) 
Operators.

Name	Symbol	Description	Example
Increment Operator	++	 Increases the integer value of the variable by one	
int a = 5;

a++; // returns 6

Decrement Operator	—	 Decreases the integer value of the variable by one	
int a = 5;

a–; // returns 4

Example:

the description


Output
a++ is 10
++a is 12
b-- is 15
--b is 13

B) Binary Operators: These operators operate or work with two operands. For example: Addition(+), Subtraction(-), etc.

Name	Symbol	Description	Example
Addition	+	Adds two operands	
int a = 3, b = 6;

int c = a+b; // c = 9

Subtraction	–	Subtracts second operand from the first	
int a = 9, b = 6;

int c = a-b; // c = 3

Multiplication	*	Multiplies two operands	
int a = 3, b = 6;

int c = a*b; // c = 18

Division	/	Divides first operand by the second operand 	
int a = 12, b = 6;

int c = a/b; // c = 2

Modulo Operation	%	Returns the remainder an integer division	
int a = 8, b = 6;

int c = a%b; // c = 2

// CPP Program to demonstrate the Binary Operators
#include <iostream>
using namespace std;

int main()
{
    int a = 8, b = 3;

    // Addition operator
    cout << "a + b = " << (a + b) << endl;
  
    // Subtraction operator
    cout << "a - b = " << (a - b) << endl;
  
    // Multiplication operator
    cout << "a * b = " << (a * b) << endl;
  
    // Division operator
    cout << "a / b = " << (a / b) << endl;
  
    // Modulo operator
    cout << "a % b = " << (a % b) << endl;

    return 0;
}

Output
a + b = 11
a - b = 5
a * b = 24
a / b = 2
a % b = 2

2) Relational Operators
These operators are used for the comparison of the values of two operands. For example, ‘>’ checks if one operand is 
greater than the other operand or not, etc. The result returns a Boolean value, i.e., true or false.

Name	Symbol	Description	Example
Is Equal To	==	Checks if both operands are equal	
int a = 3, b = 6;

a==b; 

// returns false

Greater Than	>	Checks if first operand is greater than the second operand	
int a = 3, b = 6;

a>b; 

// returns false

Greater Than or Equal To	>=	Checks if first operand is greater than or equal to the second operand	
int a = 3, b = 6;

a>=b; 

// returns false

Less Than	<	Checks if first operand is lesser than the second operand	
int a = 3, b = 6;

a<b;

 // returns true

Less Than or Equal To	<=	Checks if first operand is lesser than or equal to the second operand	
int a = 3, b = 6;

a<=b; 

// returns true

Not Equal To	!=	Checks if both operands are not equal	
int a = 3, b = 6;

a!=b; 

// returns true

// CPP Program to demonstrate the Relational Operators
#include <iostream>
using namespace std;

int main()
{
    int a = 6, b = 4;

    // Equal to operator
    cout << "a == b is " << (a == b) << endl;
  
    // Greater than operator
    cout << "a > b is " << (a > b) << endl;
  
    // Greater than or Equal to operator
    cout << "a >= b is " << (a >= b) << endl;
  
    //  Lesser than operator
    cout << "a < b is " << (a < b) << endl;
  
    // Lesser than or Equal to operator
    cout << "a <= b is " << (a <= b) << endl;
  
    // true
    cout << "a != b is " << (a != b) << endl;

    return 0;
}

Output
a == b is 0
a > b is 1
a >= b is 1
a < b is 0
a <= b is 0
a != b is 1

3) Logical Operators
These operators are used to combine two or more conditions or constraints or to complement the evaluation of the original condition in consideration. The result returns a Boolean value, i.e., true or false.

Name	Symbol	Description	Example
Logical AND	&&	Returns true only if all the operands are true or non-zero	
int a = 3, b = 6;

a&&b;

// returns true

Logical OR	||	Returns true if either of the operands is true or non-zero	
int a = 3, b = 6;

a||b;

// returns true

Logical NOT	!	Returns true if the operand is false or zero	
int a = 3;

!a;

// returns false



// CPP Program to demonstrate the Logical Operators
#include <iostream>
using namespace std;

int main()
{
    int a = 6, b = 4;

    // Logical AND operator
    cout << "a && b is " << (a && b) << endl;
  
    // Logical OR operator
    cout << "a || b is " << (a || b) << endl;
  
    // Logical NOT operator
    cout << "!b is " << (!b) << endl;

    return 0;
}

Output
a && b is 1
a ! b is 1
!b is 0

4) Bitwise Operators
These operators are used to perform bit-level operations on the operands. The operators are first converted to bit-level and then the calculation is performed on the operands. Mathematical operations such as addition, subtraction, multiplication, etc. can be performed at the bit level for faster processing. 

Name	Symbol	Description	Example
Binary AND	&	Copies a bit to the evaluated result if it exists in both operands	
int a = 2, b = 3;

(a & b); //returns 2

Binary OR	|	Copies a bit to the evaluated result if it exists in any of the operand	
int a = 2, b = 3;

(a | b); //returns 3

Binary XOR	^	Copies the bit to the evaluated result if it is present in either of the operands but not both	
int a = 2, b = 3;

(a ^ b); //returns 1

Left Shift	<<	Shifts the value to left by the number of bits specified by the right operand.	
int a = 2, b = 3;

(a << 1); //returns 4

Right Shift	>>	Shifts the value to right by the number of bits specified by the right operand.	
int a = 2, b = 3;

(a >> 1); //returns 1

One’s Complement	~	Changes binary digits 1 to 0 and 0 to 1	
int b = 3;

(~b); //returns -4


// CPP Program to demonstrate the Bitwise Operators
#include <iostream>
using namespace std;

int main()
{
    int a = 6, b = 4;

    // Binary AND operator
    cout << "a & b is " << (a & b) << endl;

    // Binary OR operator
    cout << "a | b is " << (a | b) << endl;

    // Binary XOR operator
    cout << "a ^ b is " << (a ^ b) << endl;

    // Left Shift operator
    cout << "a<<1 is " << (a << 1) << endl;

    // Right Shift operator
    cout << "a>>1 is " << (a >> 1) << endl;

    // One’s Complement operator
    cout << "~(a) is " << ~(a) << endl;

    return 0;
}

Output
a & b is 4
a | b is 6
a ^ b is 2
a<<1 is 12
a>>1 is 3
~(a) is -7

5) Assignment Operators
These operators are used to assign value to a variable. The left side operand of the assignment operator is a variable and the right side operand of the assignment operator is a value. The value on the right side must be of the same data type as the variable on the left side otherwise the compiler will raise an error. 

Namemultiply

Symbol

Description

Example

Assignment Operator	
=

Assigns the value on the right to the variable on the left 	
int a = 2; 

// a = 2

Add and Assignment Operator	
+=

First adds the current value of the variable on left to the value on the right and then assigns the result to the 
variable on the left 	
int a = 2, b = 4;

a+=b; // a = 6

Subtract and Assignment Operator	
      -=        

First subtracts the value on the right from the current value of the variable on left and then assign the result to the 
variable on the left	
int a = 2, b = 4;

a-=b; // a = -2

Multiply and Assignment Operator	
*=

First multiplies the current value of the variable on left to the value on the right and then assign the result to the 
variable on the left	
int a = 2, b = 4;

a*=b; // a = 8

Divide and Assignment Operator	
/=

First divides the current value of the variable on left by the value on the right and then assign the result to the 
variable on the left	
int a = 4, b = 2;

a /=b; // a = 2

// CPP Program to demonstrate the Assignment Operators
#include <iostream>
using namespace std;

int main()
{
    int a = 6, b = 4;

    // Assignment Operator
    cout << "a = " << a << endl;
  
    //  Add and Assignment Operator
    cout << "a += b is " << (a += b) << endl;
  
    // Subtract and Assignment Operator
    cout << "a -= b is " << (a -= b) << endl;
  
    //  Multiply and Assignment Operator
    cout << "a *= b is " << (a *= b) << endl;
  
    //  Divide and Assignment Operator
    cout << "a /= b is " << (a /= b) << endl;

    return 0;
}

Output
a = 6
a += b is 10
a -= b is 6
a *= b is 24
a /= b is 6

6) Ternary or Conditional Operators(?:)
This operator returns the value based on the condition. 

Expression1? Expression2: Expression3
The ternary operator ? determines the answer on the basis of the evaluation of Expression1. If it is true, then 
Expression2 gets evaluated and is used as the answer for the expression. If Expression1 is false, then Expression3 
gets evaluated and is used as the answer for the expression.

// CPP Program to demonstrate the Conditional Operators
#include <iostream>
using namespace std;

int main()
{
    int a = 3, b = 4;

    // Conditional Operator
    int result = (a < b) ? b : a;
    cout << "The greatest number is " << result << endl;

    return 0;
}

Output
The greatest number is 4

THEORY EXERCISE:
1. What are the different data types available in C++? Explain with examples.

All variables use data type during declaration to restrict the type of data to be stored. Therefore, we can say that 
data types are used to tell the variables the type of data they can store. Whenever a variable is defined in C++, 
the compiler allocates some memory for that variable based on the data type with which it is declared. Every data type 
requires a different amount of memory. 

C++ supports a wide variety of data types and the programmer can select the data type appropriate to the needs of the 
application. Data types specify the size and types of values to be stored. However, storage representation and 
machine instructions to manipulate each data type differ from machine to machine, although C++ instructions are 
identical on all machines.

C++ supports the following data types:

Primary or Built-in or Fundamental data type
Derived data types
User-defined data types

Data Types in C++ are Mainly Divided into 3 Types: 
1. Primitive Data Types: These data types are built-in or predefined data types and can be used directly by the user to declare variables. example: int, char, float, bool, etc. Primitive data types available in C++ are: 

Integer
Character
Boolean
Floating Point
Double Floating Point
Valueless or Void
Wide Character
2. Derived Data Types: Derived data types that are derived from the primitive or built-in datatypes are referred to as Derived Data Types. These can be of four types namely: 

Function
Array
Pointer
Reference
3. Abstract or User-Defined Data Types: Abstract or User-Defined data types are defined by the user itself. Like, defining a class in C++ or a structure. C++ provides the following user-defined datatypes:  

Class
Structure
Union
Enumeration
Typedef defined Datatype

Primitive Data Types

// C++ Program to Demonstrate the correct size
// of various data types on your computer.
#include <iostream>
using namespace std;

int main()
{
    cout << "Size of char : " << sizeof(char) << endl;
    cout << "Size of int : " << sizeof(int) << endl;

    cout << "Size of long : " << sizeof(long) << endl;
    cout << "Size of float : " << sizeof(float) << endl;

    cout << "Size of double : " << sizeof(double) << endl;

    return 0;
}

Output
Size of char : 1
Size of int : 4
Size of long : 8
Size of float : 4
Size of double : 8

Advantages:

Data types provide a way to categorize and organize data in a program, making it easier to understand and manage.
Each data type has a specific range of values it can hold, allowing for more precise control over the type of data being 
stored.
Data types help prevent errors and bugs in a program by enforcing strict rules about how data can be used and manipulated.
C++ provides a wide range of data types, allowing developers to choose the best type for a specific task.

Disadvantages:

Using the wrong data type can result in unexpected behavior and errors in a program.
Some data types, such as long doubles or char arrays, can take up a large amount of memory and impact performance if 
used excessively.
C++’s complex type system can make it difficult for beginners to learn and use the language effectively.
The use of data types can add additional complexity and verbosity to a program, making it harder to read and understand.

2. Explain the difference between implicit and explicit type conversion in C++.

Type conversion is essential for managing different data types in C++. The C++ Course covers the various methods of type 
conversion, helping you understand how to handle data types correctly. A type cast is basically a conversion from one 
type to another. There are two types of type conversion:

Implicit Type Conversion Also known as ‘automatic type conversion’.
Done by the compiler on its own, without any external trigger from the user.
Generally takes place when in an expression more than one data type is present. In such condition type conversion 
(type promotion) takes place to avoid lose of data.
All the data types of the variables are upgraded to the data type of the variable with largest data type.
bool -> char -> short int -> int -> 

unsigned int -> long -> unsigned -> 

long long -> float -> double -> long double
It is possible for implicit conversions to lose information, signs can be lost (when signed is implicitly converted to 
unsigned), and overflow can occur (when long long is implicitly converted to float).

// An example of implicit conversion

#include <iostream>
using namespace std;

int main()
{
    int x = 10; // integer x
    char y = 'a'; // character c

    // y implicitly converted to int. ASCII
    // value of 'a' is 97
    x = x + y;

    // x is implicitly converted to float
    float z = x + 1.0;

    cout << "x = " << x << endl
         << "y = " << y << endl
         << "z = " << z << endl;

    return 0;
}

Output
x = 107
y = a
z = 108

Explicit Type Conversion: This process is also called type casting and it is user-defined. Here the user can typecast 
the result to make it of a particular data type. In C++, it can be done by two ways:
Converting by assignment: This is done by explicitly defining the required type in front of the expression in parenthesis. 
This can be also considered as forceful casting. Syntax:
(type) expression

// C++ program to demonstrate
// explicit type casting

#include <iostream>
using namespace std;

int main()
{
    double x = 1.2;

    // Explicit conversion from double to int
    int sum = (int)x + 1;

    cout << "Sum = " << sum;

    return 0;
}

Output
Sum = 2

Conversion using Cast operator: A Cast operator is an unary operator which forces one data type to be converted into 
another data type. C++ supports four types of casting:
Static Cast
Dynamic Cast
Const Cast
Reinterpret Cast

#include <iostream>
using namespace std;
int main()
{
    float f = 3.5;

    // using cast operator
    int b = static_cast<int>(f);

    cout << b;
}

Output
3

3. What are the different types of operators in C++? Provide examples of each.

Operators are symbols that perform operations on variables and values. For example, + is an operator used for addition, 
while - is an operator used for subtraction.

Operators in C++ can be classified into 6 types:

Arithmetic Operators
Assignment Operators
Relational Operators
Logical Operators
Bitwise Operators
Other Operators
1. C++ Arithmetic Operators
Arithmetic operators are used to perform arithmetic operations on variables and data. For example,

a + b;
Here, the + operator is used to add two variables a and b. Similarly there are various other arithmetic operators in C++.

Operator	Operation
+	Addition
-	Subtraction
*	Multiplication
/	Division
%	Modulo Operation (Remainder after division)


Advantages of Type Conversion:

This is done to take advantage of certain features of type hierarchies or type representations.
It helps to compute expressions containing variables of different data types.

#include <iostream>
using namespace std;

int main() {
    int a, b;
    a = 7;
    b = 2;

    // printing the sum of a and b
    cout << "a + b = " << (a + b) << endl;

    // printing the difference of a and b
    cout << "a - b = " << (a - b) << endl;

    // printing the product of a and b
    cout << "a * b = " << (a * b) << endl;

    // printing the division of a by b
    cout << "a / b = " << (a / b) << endl;

    // printing the modulo of a by b
    cout << "a % b = " << (a % b) << endl;

    return 0;
}

Output

a + b = 9
a - b = 5
a * b = 14
a / b = 3
a % b = 1

Here, the operators +, - and * compute addition, subtraction, and multiplication respectively as we might have expected.

/ Division Operator

Note the operation (a / b) in our program. The / operator is the division operator.

As we can see from the above example, if an integer is divided by another integer, we will get the quotient. However, 
if either divisor or dividend is a floating-point number, we will get the result in decimals.

In C++,

7/2 is 3
7.0 / 2 is 3.5
7 / 2.0 is 3.5
7.0 / 2.0 is 3.5
% Modulo Operator

The modulo operator % computes the remainder. When a = 9 is divided by b = 4, the remainder is 1.

Increment and Decrement Operators
C++ also provides increment and decrement operators: ++ and -- respectively.

++ increases the value of the operand by 1
-- decreases it by 1
For example,

int num = 5;

// increment operator
++num;  // 6

// Working of increment and decrement operators

#include <iostream>
using namespace std;

int main() {
    int a = 10, b = 100, result_a, result_b;

    // incrementing a by 1 and storing the result in result_a
    result_a = ++a;
    cout << "result_a = " << result_a << endl;


    // decrementing b by 1 and storing the result in result_b   
    result_b = --b;
    cout << "result_b = " << result_b << endl;

    return 0;
}

Output

result_a = 11
result_b = 99

2. C++ Assignment Operators
In C++, assignment operators are used to assign values to variables. For example,

// assign 5 to a
a = 5;
Here, we have assigned a value of 5 to the variable a.

Operator	Example	Equivalent to
=	a = b;	a = b;
+=	a += b;	a = a + b;
-=	a -= b;	a = a - b;
*=	a *= b;	a = a * b;
/=	a /= b;	a = a / b;
%=	a %= b;	a = a % b;


#include <iostream>
using namespace std;

int main() {
    int a, b;

    // 2 is assigned to a
    a = 2;

    // 7 is assigned to b
    b = 7;

    cout << "a = " << a << endl;
    cout << "b = " << b << endl;
    cout << "\nAfter a += b;" << endl;

    // assigning the sum of a and b to a
    a += b;  // a = a +b
    cout << "a = " << a << endl;

    return 0;
}

Output

a = 2
b = 7

After a += b;
a = 9

3. C++ Relational Operators
A relational operator is used to check the relationship between two operands. For example,

// checks if a is greater than b
a > b;
Here, > is a relational operator. It checks if a is greater than b or not.

If the relation is true, it returns 1 whereas if the relation is false, it returns 0.

Operator	Meaning	Example
==	Is Equal To	3 == 5 gives us false
!=	Not Equal To	3 != 5 gives us true
>	Greater Than	3 > 5 gives us false
<	Less Than	3 < 5 gives us true
>=	Greater Than or Equal To	3 >= 5 give us false
<=	Less Than or Equal To	3 <= 5 gives us true


#include <iostream>
using namespace std;

int main() {
    int a, b;
    a = 3;
    b = 5;
    bool result;

    result = (a == b);   // false
    cout << "3 == 5 is " << result << endl;

    result = (a != b);  // true
    cout << "3 != 5 is " << result << endl;

    result = a > b;   // false
    cout << "3 > 5 is " << result << endl;

    result = a < b;   // true
    cout << "3 < 5 is " << result << endl;

    result = a >= b;  // false
    cout << "3 >= 5 is " << result << endl;

    result = a <= b;  // true
    cout << "3 <= 5 is " << result << endl;

    return 0;
}

Output

3 == 5 is 0
3 != 5 is 1
3 > 5 is 0
3 < 5 is 1
3 >= 5 is 0
3 <= 5 is 1

4. C++ Logical Operators
Logical operators are used to check whether an expression is true or false. If the expression is true, it returns 1 whereas if the expression is false, it returns 0.

Operator	Example	Meaning
&&	expression1 && expression2	Logical AND.
True only if all the operands are true.
||	expression1 || expression2	Logical OR.
True if at least one of the operands is true.
!	!expression	Logical NOT.
True only if the operand is false.
In C++, logical operators are commonly used in decision making. To further understand the logical operators, let's 
see the following examples,

Suppose,
a = 5
b = 8

Then,

(a > 3) && (b > 5) evaluates to true
(a > 3)  && (b < 5) evaluates to false

(a > 3) || (b > 5) evaluates to true
(a > 3) || (b < 5) evaluates to true
(a < 3) || (b < 5) evaluates to false

!(a < 3) evaluates to true
!(a > 3) evaluates to false

#include <iostream>
using namespace std;

int main() {
    bool result;

    result = (3 != 5) && (3 < 5);     // true
    cout << "(3 != 5) && (3 < 5) is " << result << endl;

    result = (3 == 5) && (3 < 5);    // false
    cout << "(3 == 5) && (3 < 5) is " << result << endl;

    result = (3 == 5) && (3 > 5);    // false
    cout << "(3 == 5) && (3 > 5) is " << result << endl;

    result = (3 != 5) || (3 < 5);    // true
    cout << "(3 != 5) || (3 < 5) is " << result << endl;

    result = (3 != 5) || (3 > 5);    // true
    cout << "(3 != 5) || (3 > 5) is " << result << endl;

    result = (3 == 5) || (3 > 5);    // false
    cout << "(3 == 5) || (3 > 5) is " << result << endl;

    result = !(5 == 2);    // true
    cout << "!(5 == 2) is " << result << endl;

    result = !(5 == 5);    // false
    cout << "!(5 == 5) is " << result << endl;

    return 0;
}

Output

(3 != 5) && (3 < 5) is 1
(3 == 5) && (3 < 5) is 0
(3 == 5) && (3 > 5) is 0
(3 != 5) || (3 < 5) is 1
(3 != 5) || (3 > 5) is 1
(3 == 5) || (3 > 5) is 0
!(5 == 2) is 1
!(5 == 5) is 0

5. C++ Bitwise Operators
In C++, bitwise operators are used to perform operations on individual bits. They can only be used alongside char and int 
data types.

Operator	Description
&	Binary AND
|	Binary OR
^	Binary XOR
~	Binary One's Complement
<<	Binary Shift Left
>>	Binary Shift Right

4. Explain the purpose and use of constants and literals in C++.

C++ literals are data used for representing fixed point values that we can directly use in the code. For 
example: 100, 3.1421, 'y', 'n' etc.

Please note that a variable can be assign different values but literals can’t. There are 6 types of literals in C++.

1. Integer literal 🡪 An integer is a fixed point numeric literal. It has no fractional or exponential part. 
There are three types of integer literals used in C++ programming i.e. decimal (base 10), octal (base 8) and 
hexadecimal (base 16). Please note that octal literal starts with a 0 while hexadecimal literal starts 
with a 0x. For e.g.

Decimal literal : -1, 0, 100 etc.
Octal literal : 045, 067, 043 etc.
Hexadecimal literal: 0x8f, 0xa2, 0x721 etc.
Floating point literal 🡪 A floating-point literal is different from integar literal as it has an integer part, a 
decimal point, a fractional part, and an exponent part. You can represent floating point

B.literals either in decimal form or exponential form. Decimal form must have the decimal point, the exponent, or both 
and while the exponential form must have the integer part, the fractional part, or both. The signed exponent is 
denoted by e or E. For e.g.

3.14134       // Legal
314159E-5L    // Legal
620E          // Illegal: incomplete exponent
22f          // Illegal: no decimal or exponent
.e755          // Illegal: missing integer or fraction
C.Boolean literal 🡪 C++ has two Boolean literals i.e. true which denotes for success/truth and false which stands for 
failure/falsehood. A programmer usually uses considers the value of true equal to 1 and value of false equal to 0.

D.Character literal 🡪 A character literal is created by enclosing a single character inside single quotation marks. 
For example: 'a', 'm', 'F', '2', '}' etc. Please note that f for literals begins with L, you should store 
it in wchar_t type of variable as it is a wide character literal. For e.g.

'y', 'n', L'fu', '(', ']' etc.
E.String literals 🡪 String literals are proper strings that are enclosed in double quotes ("...."). A string literal 
can have anything such as plain characters, escape sequences, and universal characters. We can break a long line into 
multiple lines using string literals and separate them using whitespaces. Here are some examples of string literals 
that are identical strings.

"India is great"


"India \

is great"


"India \

is \

great"
F.Escape sequence 🡪 this type of literal is used for some special operation or to denote a special character that 
cannot be typed using keyboard. For example, newline (enter), tab, question mark, etc.  Some common escape sequences 
are \n to add new line; \t to add tab space; \b to add a backspace etc.

3. Control Flow Statements
LAB EXERCISES:
1. Grade Calculator o Write a C++ program that takes a student’s marks as input and calculates the grade based on 
if-else conditions.

Writing a C++ program to calculate a student’s grade is one of the questions you will only encounter in schools as a 
computer science student. You will never get such questions in higher education in computer science because they are 
so easy to solve. You get such questions so that you can learn how to use the syntax of a programming language correctly, 
because when you are new to a programming language, only learning the fundamentals of a programming language should be 
your priority which can only be achieved if you continue to solve such questions.

Now coming back to writing a C++ program to calculate grades, to write this program you will get the grading system in 
the question itself which you need to follow. For now, I’ll use the grading system mentioned below to write this C++ 
program:

100 – 90	A+
90 – 80	A
80 – 70	B+
70 – 60	B
60 – 50	C
50 – 40	D
40 – 30	E
30 – 0	F
I hope you have understood the grading system mentioned above. Now here is how you can write a C++ program to calculate 
grades:


#include <iostream>
using namespace std;

int main(){
    int marks;
    cout<<"Enter Your Marks: ";
    cin>>marks;
    if (marks >= 90){
        cout<<"Your Grade is A+";
    }
    else if (marks >= 80){
        cout<<"Your Grade is A";
    }
    else if (marks >= 70){
        cout<<"Your Grade is B+";
    }
    else if (marks >= 60){
        cout<<"Your Grade is B";
    }
    else if (marks >= 50){
        cout<<"Your Grade is C";
    }
    else if (marks >= 40){
        cout<<"Your Grade is D";
    }
    else if (marks >= 30){
        cout<<"Your Grade is E";
    }
    else if (marks <= 30){
        cout<<"Your Grade is F";
    }
    else{
        cout<<"Enter Valid Marks";
    }
    return 0;
}

o Objective: Practice conditional statements (if-else).

The if statement alone tells us that if a condition is true it will execute a block of statements and if the condition 
is false, it won’t. But what if we want to do something else if the condition is false. Here comes the C++ if else 
statement. We can use the else statement with if statement to execute a block of code when the condition is false.

#include <iostream> 
using namespace std; 
  
int main()  { 
    int i = 10; 
  
    // If statement
    if (i < 15) { 
        cout << "10 is less than 15"; 
    }
  
      // Else statement with the above if
      else {
          cout << "10 is not less than 15";
    }
  
    return 0;
}

Output
10 is less than 15

2. Number Guessing Game o Write a C++ program that asks the user to guess a number between 1 and 100. 
The program should provide hints if the guess is too high or too low. Use loops to allow the user multiple attempts.

Requirements
These are the following requirements: -

User should have a code editor for example - VS Code or Sublime.
The ctime and cstdlib libraries are used.
Loops and iteration knowledge.
The functions - srand() and rand() knowledge.
The user must be aware of the exit function.

    cout << "\n\t\t\tWelcome to \n\t\tGuess The Number game!!"<< endl;
    cout<<"\n\t\t\tINSTRUCTIONS"<<endl;
    cout << "\t\tYou have to guess a number between 1 and 100. "
			"\tYou'll get limited chances based on the difficulty level you choose."<< endl;

    while (true) {
        cout << "\nDifficulty Levels\n";
        cout << "\n1 for easy level!\t";
        cout << "\n2 for medium-level!\t";
        cout << "\n3 for difficult level!\t";
        cout << "\n0 for ending the game!\n" << endl;

        // select the level of difficulty
        int level;
        cout << "Enter the difficulty level number: ";
        cin >> level;

    int level;
    cout << "Enter the difficulty level number: ";
    cin >> level;

        // generating the random number
        srand(time(0));
        int randomNumber = (rand() % (100-1))+1;
        int guess;

    //if the player chooses difficulty level as easy
    if (level == 1) {
        cout << "\nYou will get 7 choices for finding the random number between 1 and 100.";
        int leftChance = 7;
        for (int i = 1; i <= 7; i++) {
            
            // asking the player to guess the number
            cout << "\n\nEnter the number: ";
            cin >> guess;
            if(guess== randomNumber){
                cout<<"Voila! You guessed the right number";
                break;
            }
            else if(guess>randomNumber){
                cout<<guess<<" is greater than the random number";
                    }
            else{
               cout<<guess<<" is less than the random number";
            }
            leftChance--;
            if(leftChance==0){
                cout<<"\nBetter luck next time"<<endl;
                cout<<randomNumber<<" is the number";
            }
        }           
    }

    //if the player chooses difficulty level as easy
    if (level == 1) {
        cout << "\nYou will get 7 choices for finding the random number between 1 and 100.";
        int leftChance = 7;
        for (int i = 1; i <= 7; i++) {
            
            // asking the player to guess the number
            cout << "\n\nEnter the number: ";
            cin >> guess;
            if(guess== randomNumber){
                cout<<"Voila! You guessed the right number";
                break;
            }
            else if(guess>randomNumber){
                cout<<guess<<" is greater than the random number";
                    }
            else{
               cout<<guess<<" is less than the random number";
            }
            leftChance--;
            if(leftChance==0){
                cout<<"\nBetter luck next time"<<endl;
                cout<<randomNumber<<" is the number";
            }
        }           
    }

    else if (level == 3) {
        cout << "\nYou have 3 choices for finding the secret number between 1 and 100.";
        int leftChance = 3;
        for (int i = 1; i <= 3; i++) {
            cout << "\n\nEnter the number: ";
            cin >> guess;
            if(guess== randomNumber){
                cout<<"Voila! You guessed the right number";
                break;
            }
            else if(guess>randomNumber){
                cout<<guess<<" is greater than the random number";
            }
            else{
                cout<<guess<<" is less than the random number";
            }
            leftChance--;
            if(leftChance==0){
                cout<<"\nBetter luck next time"<<endl;
                cout<<randomNumber<<" is the number";
            }
        }
    }

        // To end the game
        else if (level == 0) {
            exit(0);
        }
        else {
            cout << "Kindly select between (0,1,2,3)"<< endl;
        }

                        Welcome to 
                Guess The Number game!!

                        INSTRUCTIONS
        You have to guess a number between 1 and 100. 
    You'll get limited chances based on the difficulty level you choose.

Difficulty Levels
1 for easy level!     
2 for medium-level!   
3 for difficult level!        
0 for ending the game!

Enter the difficulty level number: 3

You have 3 choices for finding the secret number between 1 and 100.

Enter the number: 50
50 is less than the random number

Enter the number: 70
70 is less than the random number

Enter the number: 90
90 is greater than the random number
Better luck next time
88 is the number

Difficulty Levels
1 for easy level!     
2 for medium-level!   
3 for difficult level!        
0 for ending the game!

Enter the difficulty level number: 0



#include <iostream>
#include <cstdlib>
#include <ctime>
using namespace std;

int main()
{
    int randomNumber;
    int guess;
    int chances = 0;
    srand(time(0)); 
    randomNumber = rand() % 100 + 1; 
    cout << "\t\t\tWelcome to Guess the Number Game\n\n";

    do
    {
        cout << "Enter your guess between 1 and 100: ";
        cin >> guess;
        chances++;

        if (guess > randomNumber){
            cout << "The "<<guess<<" is Too high!\n\n";
        }
        else if (guess < randomNumber){
            cout << "The "<<guess<<" is Too low!\n\n";
        }
        else{
            cout << "\nVoila! You got the right guess "<<guess <<"in "<< chances << " tries!\n";
        }
    } 
        while (guess != randomNumber);

	return 0;
}

output
                        Welcome to Guess the Number Game

Enter your guess between 1 and 100: 40
The 40 is Too high!

Enter your guess between 1 and 100: 20
The 20 is Too high!

Enter your guess between 1 and 100: 10
The 10 is Too low!

Enter your guess between 1 and 100: 15
The 15 is Too low!

Enter your guess between 1 and 100: 18
The 18 is Too high!

Enter your guess between 1 and 100: 17
The 17 is Too high!

Enter your guess between 1 and 100: 16

Voila! You got the right guess 16in 7 tries!

o Objective: Understand while loops and conditional logic.

C++ Loops
Loops can execute a block of code as long as a specified condition is reached.

Loops are handy because they save time, reduce errors, and they make code more readable.

C++ While Loop
The while loop loops through a block of code as long as a specified condition is true:

Syntax
while (condition) {
  // code block to be executed
}

Example
int i = 0;
while (i < 5) {
  cout << i << "\n";
  i++;
}

C++ While Loop in Practice
You’ll frequently see the while loop in C++ used as an incremental counter to output values that meet the condition of 
the loop. Here’s an example:

int main()
{
  int x = 0;
  while (x <= 10) {
    cout << x << " ";
    x+=2;
  }
   
    return 0;
}
This while loop starts with variable “x” at 0. Remember that the while loop will check the condition before performing 
the code inside the loop. It will generate outputs as long as “x” is less than or equal to 10. Since “x” starts at 0 
and meets our condition, the first output will be 0. The loop will terminate once “x” gets above 10. Here’s the result:

0 2 4 6 8 10
There are times where you need to break out of a C++ while loop. Here’s an example of how that works:

int main()
{
  int z = 0;
  while  (z <= 20) {
    if (z == 7) {
      break;
    }
    cout << z << "\n";
    z++;
  }  
  return 0;
}
This while loop would normally increment by 1 until “z” reaches 21, upon which the loop would terminate. However, 
since we’ve added a break for once “z” hits 7, the break throws us out of the loop before it has a chance to finish 
counting to 20. In this program, the code terminates at that point.

3. Multiplication Table o Write a C++ program to display the multiplication table of a given number using a for loop.

// C++ program to print table
// of a number
#include <iostream>
using namespace std;

// Driver code
int main()
{
	// Change here to change output
	int n = 5;
	for (int i = 1; i <= 10; ++i)
		cout << n << " * " << i << " = " << n * i << endl;
	return 0;
}


Output
5 * 1 = 5
5 * 2 = 10
5 * 3 = 15
5 * 4 = 20
5 * 5 = 25
5 * 6 = 30
5 * 7 = 35
5 * 8 = 40
5 * 9 = 45
5 * 10 = 50


C++ Program to Display Multiplication Table Up to a Given Range

// C++ program to print table
// over a range
#include <iostream>
using namespace std;

// Driver code
int main()
{
	// Change here to change
	// input number
	int n = 8;

	// Change here to change result
	int range = 11;
	for (int i = 1; i <= range; ++i)
		cout << n << " * " << i << " = " << n * i << endl;

	return 0;
}


Output
8 * 1 = 8
8 * 2 = 16
8 * 3 = 24
8 * 4 = 32
8 * 5 = 40
8 * 6 = 48
8 * 7 = 56
8 * 8 = 64
8 * 9 = 72
8 * 10 = 80
8 * 11 = 88

o Objective: Practice using loops.

What are Loops in C++?
Loops in C++ are like a computer's way of doing something over and over again until a certain condition is met. 
Instead of writing the same code multiple times, you can use a loop to tell the computer, "Keep doing this until I say 
stop!"

For example, if you want to print numbers from 1 to 10, you could write:


cout << 1 << endl;
cout << 2 << endl;
cout << 3 << endl;
// ... and so on until 10

The While Loop

while (condition) {
    // code to be executed
}

int a = 0;
while (a < 7) {
    cout << a << endl;
    a++;
}

We start with a = 0.
The loop checks if a < 7. If true, it runs the code inside.
It prints a and then increases it by 1 (a++).
This repeats until a is no longer less than 7.

The For Loop

for (initialization; condition; update) {
    // code to be executed
}

Initialization: This happens once at the start.
Condition: If this is true, the loop continues.
Update: This happens at the end of each loop.

for (int i = 0; i < 5; i++) {
    cout << "C++" << endl;
}

We start with i = 0.
It checks if i < 5. If true, it prints "C++".
After printing, it increases i by 1 (i++).
This repeats until i is no longer less than 5.

The Do-While Loop

do {
    // code to be executed
} while (condition);

int i = 0;
do {
    cout << i << " ";
    i++;
} while (i < 6);

Nested Loops

int n = 4;
for (int i = 0; i < n; i++) {
    for (int j = 0; j < n; j++) {
        cout << "* ";
    }
    cout << endl;
}

Break and Continue Statements
Sometimes you need more control over your loops. That's where break and continue come in:

break: This exits the loop immediately.
continue: This skips the rest of the current loop and moves to the next iteration.

for (int i = 0; i < 10; i++) {
    if (i == 5) {
        break;
    }
    cout << i << " ";
}

for (int i = 0; i < 5; i++) {
    if (i == 2) {
        continue;
    }
    cout << i << " ";
}

4. Nested Control Structures o Write a program that prints a right-angled triangle using stars (*) with a nested loop.

#include <iostream>
using namespace std;
void solve( int n ){
   int i, j, k;
   for( i = 1; i <= n; i++ ) {
      for( k = 1; k <= (n - i); k++ ) {
         cout << ". ";
      }
      for( j = 1; j <= i; j++ ) {
         cout << "* ";
      }
      cout << endl;
   }
}
int main(){
   int n = 10;
   cout << "Left Star Pattern using " << n << " number of lines:" << endl;
   solve( n );
}

Output
Left Star Pattern using 10 number of lines:
. . . . . . . . . * 
. . . . . . . . * * 
. . . . . . . * * * 
. . . . . . * * * * 
. . . . . * * * * * 
. . . . * * * * * * 
. . . * * * * * * * 
. . * * * * * * * * 
. * * * * * * * * * 
* * * * * * * * * * 

o Objective: Learn nested control structures

Nested control structures refer to the usage of control structures within each other. This allows us to create complex 
decision-making processes and iterate over multiple levels of data.

By nesting control structures, we can perform different actions based on multiple conditions. This provides us with more 
flexibility and allows us to create powerful algorithms.

#include <iostream>
using namespace std;

int main() {
  int age = 25;
  bool isStudent = true;

  if (age >= 18) {
    cout << "You are an adult."
;
    if (isStudent) {
      cout << "You are a student."
;
    } else {
      cout << "You are not a student."
;
    }
  } else {
    cout << "You are not an adult."
;
  }

  return 0;
}

In this example, we have nested an if statement inside another if statement. The outer if statement checks if the age 
is greater than or equal to 18. If it is, then it prints "You are an adult." The inner if statement checks if the person 
is a student. If they are, it prints "You are a student." If they are not, it prints "You are not a student." If the 
age is less than 18, it prints "You are not an adult."

By nesting control structures, we can create more complex logic and handle different scenarios based on multiple 
conditions. This allows us to build more sophisticated programs and algorithms.

#include <iostream>
using namespace std;

int main() {
  int age = 25;
  bool isStudent = true;

  if (age >= 18) {
    cout << "You are an adult.";
    if (isStudent) {
      cout << " You are a student.";
    } else {
      cout << " You are not a student.";
    }
  } else {
    cout << "You are not an adult.";
  }

  return 0;
}

THEORY EXERCISE:
1. What are conditional statements in C++? Explain the if-else and switch statements.

You already know that C++ supports the usual logical conditions from mathematics:

Less than: a < b
Less than or equal to: a <= b
Greater than: a > b
Greater than or equal to: a >= b
Equal to a == b
Not Equal to: a != b
You can use these conditions to perform different actions for different decisions.

C++ has the following conditional statements:

Use if to specify a block of code to be executed, if a specified condition is true
Use else to specify a block of code to be executed, if the same condition is false
Use else if to specify a new condition to test, if the first condition is false
Use switch to specify many alternative blocks of code to be executed


The if Statement
Use the if statement to specify a block of C++ code to be executed if a condition is true.

Syntax
if (condition) {
  // block of code to be executed if the condition is true
}

In the example below, we test two values to find out if 20 is greater than 18. If the condition is true, print some text:

Example
if (20 > 18) {
  cout << "20 is greater than 18";
}


Example
int x = 20;
int y = 18;
if (x > y) {
  cout << "x is greater than y";
}

The else Statement
Use the else statement to specify a block of code to be executed if the condition is false.

Syntax
if (condition) {
  // block of code to be executed if the condition is true
} else {
  // block of code to be executed if the condition is false
}
Example
int time = 20;
if (time < 18) {
  cout << "Good day.";
} else {
  cout << "Good evening.";
}
// Outputs "Good evening."

C++ Switch Statements
Use the switch statement to select one of many code blocks to be executed.

Syntax
switch(expression) {
  case x:
    // code block
    break;
  case y:
    // code block
    break;
  default:
    // code block
}
The switch expression is evaluated once
The value of the expression is compared with the values of each case
If there is a match, the associated block of code is executed
The break and default keywords are optional, and will be described later in this chapter

Example
int day = 4;
switch (day) {
  case 1:
    cout << "Monday";
    break;
  case 2:
    cout << "Tuesday";
    break;
  case 3:
    cout << "Wednesday";
    break;
  case 4:
    cout << "Thursday";
    break;
  case 5:
    cout << "Friday";
    break;
  case 6:
    cout << "Saturday";
    break;
  case 7:
    cout << "Sunday";
    break;
}
// Outputs "Thursday" (day 4)


2. What is the difference between for, while, and do-while loops in C++?

for loop provides a concise way of writing the loop structure. Unlike a while loop, a for statement consumes the initialization, condition and increment/decrement in one line thereby providing a shorter, easy to debug structure of looping.

Syntax:

for (initialization condition; testing condition; 
                              increment/decrement)
{
    statement(s)
}

#include <iostream> 
using namespace std; 

int main() 
{ 

	int i = 0; 

	for (i = 5; i < 10; i++) { 
		cout << "GFG\n"; 
	} 

	return 0; 
} 


Output:
GFG
GFG
GFG
GFG
GFG

do-while loop:

do while loop is similar to while loop with the only difference that it checks for the condition after executing the 
statements, and therefore is an example of Exit Control Loop.

Syntax:

do
{
    statements..
}
while (condition);

#include <iostream> 
using namespace std; 

int main() 
{ 

	int i = 5; 

	do { 
		i++; 
		cout << "GFG\n"; 
	} while (i < 10); 

	return 0; 
} 


Output:
GFG
GFG
GFG
GFG
GFG

while loop:

A while loop is a control flow statement that allows code to be executed repeatedly based on a given Boolean condition. 
The while loop can be thought of as a repeating if statement.

Syntax :

while (boolean condition)
{
   loop statements...
}

#include <iostream>
using namespace std;

int main()
{

    int i = 5;

    while (i < 10) {
        i++;
        cout << "GFG\n";
    }

    return 0;
}

Output
GFG
GFG
GFG
GFG
GFG

while

Condition is checked first then statement(s) is executed.
It might occur statement(s) is executed zero times, If condition is false.
No semicolon at the end of while. while(condition)
Variable in condition is initialized before the execution of loop.
while loop is entry controlled loop.
while(condition) { statement(s); }



For loop	                                        Do-While loop

Statement(s) is executed once the condition is checked.	Condition is checked after the statement(s) is executed.
It might be that statement(s) gets executed zero times.	Statement(s) is executed at least once.
For the single statement, bracket is not compulsory.	Brackets are always compulsory.
Initialization may be outside or in condition box.	Initialization may be outside or within the loop.
for loop is entry controlled loop.	                do-while is exit controlled loop.
for ( init ; condition ; iteration )                    do { statement(s); }
{ statement (s); }	                                while (condition);


3. How are break and continue statements used in loops? Provide examples.

Break and continue are loop control statements in C++ that are used to exit from the loop or skip any iteration in the 
loop.

Break
The break statement is used to terminate the loop. As soon as a break statement is executed within the loop, the 
loop iteration stops and the very next statement after the loop starts executing.

Syntax
Ace Editor

break;

The break statement can be implemented in 3 types of loops:

simple loop
nested loop
infinite loop

#include <iostream>
using namespace std;

int main() {
  cout << "Before loop" << endl;
  for (int i=0 ; i<10 ; i++){
    cout << i << endl;
    if(i==5){
      break;
    }
  }
  cout << "After loop";
  return 0;
}

#include <iostream>
using namespace std;

int main() {
  cout << "Before loop" << endl;
  for (int i=0 ; i<10 ; i++){
    cout << "i: " <<  i << endl;
    for (int j =0 ; j< 3 ; j++){
      cout << "j: " << j << endl;
      if(j==1){
        cout << "using break ----" << endl;
        break;
      }
    }
    
  }
  cout << "After loop";
  return 0;
}

#include <iostream>
using namespace std;

int main() {
  int i = 0 ;
  while(1){
    cout << "i:" << i << endl;
    if(i==15){
      cout << "using break----" << endl;
      break;
    }
    i++;
  }
}

Continue
A continue statement, just like a break statement, is a loop control statement. Instead of terminating the loop and 
exiting from it, the continue statement forces the loop to skip the current iteration and continue from the next iteration.

Syntax

continue;

#include <iostream>
using namespace std;

int main() {
  // your code goes here
  for (int i=1; i<=10 ; i++){
    if(i%2==0){
      cout <<"missing itertionusing continue statement" << endl;
      continue;
    }
    cout << i << endl;
  }
  return 0;
}

4. Explain nested control structures with an example

A structure element (member) may be either complex or simple. The simple elements can be any of C++'s fundamental 
data types, such as int, float, char, or double. However, a structure may consist of an element that itself is complex, 
e.g., arrays, structures, etc.

Thus, an element of a structure may have been an array or a structure in itself. A structure consisting of such complex 
elements is called a complex structure.

C++ Nested Structure Definition

struct addr
{
   int houseno;
   string area;
   string city;
   string state;
};
struct emp
{
   int id ;
   string name;
   addr address;            // complex element
   float basic;
};

C++ Nested Structure Example


#include<iostream>
using namespace std;

struct addr
{
   int houseno;
   string area;
   string city;
   string state;
};
struct emp
{
   int id ;
   string name;
   addr address;            // complex element
} ;

int main()
{
   emp e;
   
   cout<<"Enter the ID: ";
   cin>>e.id;
   cout<<"Enter the Name: ";
   cin>>e.name;
   cout<<"Enter the House No.: ";
   cin>>e.address.houseno;
   cout<<"Enter the Area: ";
   cin>>e.address.area;
   cout<<"Enter the City: ";
   cin>>e.address.city;
   cout<<"Enter the State: ";
   cin>>e.address.state;

   cout<<"\n\nEmployee ID: "<<e.id;
   cout<<"\nEmployee Name: "<<e.name;
   cout<<"\nAddress: ";
   cout<<e.address.houseno<<", "<<e.address.area<<", "<<e.address.city<<", "<<e.address.state;
   cout<<endl;

   return 0;
}

4. Functions and Scope
LAB EXERCISES:
1. Simple Calculator Using Functions
o Write a C++ program that defines functions for basic arithmetic operations (add, subtract, multiply, divide). 
The main function should call these based on user input.

#include <iostream>
using namespace std;

int main()
{
    int first, second, add, subtract, multiply;
    float divide;
    
    cout << "Please enter two integer: ";
    cin >> first;
    cin >> second;
    
    add        = first + second;
    subtract = first - second;
    multiply = first * second;
    divide     = first / (float)second;   //typecasting
    
    cout << endl <<"Sum = " << add;
    cout << endl <<"Difference = " << subtract;
    cout << endl <<"Multiplication = " << multiply;
    cout << endl <<"Division = " << divide; 
    
    return 0;
}

output
Please enter two integer:
11
2

Sum = 13
Difference = 9
Multiplication = 22
Division = 5.5

o Objective: Practice defining and using functions in C++.

A function is a set of statements that takes input, does some specific computation, and produces output. The idea is to 
put some commonly or repeatedly done tasks together to make a function so that instead of writing the same code again 
and again for different inputs, we can call this function.
In simple terms, a function is a block of code that runs only when it is called.

// C++ Program to demonstrate working of a function
#include <iostream>
using namespace std;

// Following function that takes two parameters 'x' and 'y'
// as input and returns max of two input numbers
int max(int x, int y)
{
    if (x > y)
        return x;
    else
        return y;
}

// main function that doesn't receive any parameter and
// returns integer
int main()
{
    int a = 10, b = 20;

    // Calling above function to find max of 'a' and 'b'
    int m = max(a, b);

    cout << "m is " << m;
    return 0;
}

Output
m is 20

Types of Functions


User Defined Function
User-defined functions are user/customer-defined blocks of code specially customized to reduce the complexity of big 
programs. They are also commonly known as “tailor-made functions” which are built only to satisfy the condition in 
which the user is facing issues meanwhile reducing the complexity of the whole program.

Library Function 
Library functions are also called “built-in Functions“. These functions are part of a compiler package that is already 
defined and consists of a special function with special and different meanings. Built-in Function gives us an edge as 
we can directly use them without defining them whereas in the user-defined function we have to declare and define a 
function before using them. 
For Example: sqrt(), setw(), strcat(), etc.

Function Declaration
A function declaration tells the compiler about the number of parameters, data types of parameters, and returns type of 
function. Writing parameter names in the function declaration is optional but it is necessary to put them in the 
definition. Below is an example of function declarations. (parameter names are not present in the below declarations) 
The C++ Course provides comprehensive lessons on defining and using functions, enhancing your programming skills.

// C++ Program to show function that takes
// two integers as parameters and returns
// an integer
int max(int, int);

// A function that takes an int
// pointer and an int variable
// as parameters and returns
// a pointer of type int
int* swap(int*, int);

// A function that takes
// a char as parameter and
// returns a reference variable
char* call(char b);

// A function that takes a
// char and an int as parameters
// and returns an integer
int fun(char, int);


Function Definition

// C++ Program to demonstrate function definition
#include <iostream>
using namespace std;

void fun(int x)
{
    // definition of
    // function
    x = 30;
}

int main()
{
    int x = 20;
    fun(x);
    cout << "x = " << x;
    return 0;
}

Output
x = 20

2. Factorial Calculation Using Recursion o Write a C++ program that calculates the factorial of a number using recursion.

#include<iostream>
using namespace std;

int factorial(int n);

int main() {

  int n;

  cout << "Enter a positive integer: ";
  cin >> n;

  cout << "Factorial of " << n << " = " << factorial(n);

  return 0;
}

int factorial(int n) {
  if(n > 1)
    return n * factorial(n - 1);
  else
    return 1;
}

Output

Enter an positive integer: 6
Factorial of 6 = 720

o Objective: Understand recursion in functions

Working of Recursion in C++
void recurse()
{
    ... .. ...
    recurse();
    ... .. ...
}

int main()
{
    ... .. ...
    recurse();
    ... .. ...
}

// Factorial of n = 1*2*3*...*n

#include <iostream>
using namespace std;

int factorial(int);

int main() {
    int n, result;

    cout << "Enter a non-negative number: ";
    cin >> n;

    result = factorial(n);
    cout << "Factorial of " << n << " = " << result;
    return 0;
}

int factorial(int n) {
    if (n > 1) {
        return n * factorial(n - 1);
    } else {
        return 1;
    }
}

Output

Enter a non-negative number: 4
Factorial of 4 = 24

Advantages of C++ Recursion
It makes our code shorter and cleaner.
Recursion is required in problems concerning data structures and advanced algorithms, such as Graph and Tree Traversal.

Disadvantages of C++ Recursion
It takes a lot of stack space compared to an iterative program.
It uses more processor time.
It can be more difficult to debug compared to an equivalent iterative program.


3. Variable Scope o Write a program that demonstrates the difference between local and global variables in C++. 
Use functions to show scope.

Local variables are declared within a specific block of code, such as a function or method, and have limited scope and 
lifetime, existing only within that block. Global variables, on the other hand, are declared outside of any function and 
can be accessed from any part of the program, persisting throughout its execution.

Local Variables:

Local variables are declared within a specific block of code, such as within a function or a loop.
They are only accessible within the block in which they are declared.
Once the block of code in which they are declared exits, the memory allocated to these variables is released, and they 
are no longer accessible.
Local variables can have the same name as variables in other blocks without conflict because their scope is limited to 
the block in which they are declared.
They are typically used for temporary storage or only relevant data within a specific context.

Global Variables:

Global variables are declared outside of any function or block of code, usually at the top of a program or in a separate 
file.
They are accessible from any part of the program, including within functions, loops, or other blocks of code.
Global variables retain their value throughout the lifetime of the program unless explicitly modified or reset.
Due to their accessibility from anywhere in the program, global variables can introduce unintended side effects and make 
it harder to understand and debug code, especially in larger programs.
They are typically used for values that need to be accessed and modified by multiple parts of the program.

Aspect	        Local Variables	                                                Global Variables
Scope	        Limited to the block of code	                                Accessible throughout the program
Declaration	Typically within functions or specific blocks	                Outside of any function or block
Access	        Accessible only within the block where they are declare         Accessible from any part of the program
Lifetime	Created when the block is entered and destroyed when it exits	Retain their value throughout the lifetime of the program
Name conflicts	Can have the same name as variables in other blocks	        Should be used carefully to avoid unintended side effects
Usage	        Temporary storage, specific to a block of code	                Values that need to be accessed and modified by multiple parts of the program

o Objective: Reinforce the concept of variable scope

In C++, the scope of a variable is the extent in the code upto which the variable can be accessed or worked with. 
It is the region of the program where the variable is accessible using the name it was declared with.

#include <iostream>
using namespace std;

// Declaring first variable
int a = 10;

int main() {

      // Declaring second variable
      int b = 9;

      // Accessing a and b variable in their scope
    cout << a << " " << b;

    return 0;
}

Output
10 9

Global Scope
Global scope refers to the region outside any function or a block. The variables declared here are accessible throughout 
the entire program and are called Global Variables.

#include<iostream>
using namespace std;

// Global variable
int global = 5;

// Global variable accessed from within
// a function
void display() {
    cout << global << endl;
}

int main() {
    display();
    
    // Changing value of global from main
      // function before calling display()
    global = 10;
    display();
  
      return 0;
}

Output
5
10

Local Scope
The local scope is the region inside the curly braces { }. Variables defined within a function or block are said to be 
local to those functions or a block and are called local variables. Local variables do not exist outside the block in 
which they are declared, i.e. they cannot be accessed or used outside that block.

#include<iostream>
using namespace std;

void func() {
  
    // This variable is local to function func() and
      // cannot be accessed outside this function
    int age = 18;
}

int main() {
  
      // Accessing variable from func() in main function
    cout << "Age is: " << age;
    
    return 0;
}

Output

./Solution.cpp: In function 'int main()':
./Solution.cpp:14:27: error: 'age' was not declared in this scope
     cout << "Age is: " << age;
                           ^

#include<iostream>
using namespace std;

void func() {

    // This variable is local to function func() and
      // cannot be accessed outside this function
    int age = 18;
    cout << age;
}

int main() {
    cout << "Age is: ";
    func();
    
    return 0;
}

Output
Age is: 18

Variations of Scopes in C++
Apart from the primary classification of the scopes as global and local, there are few other specialized variations of 
these scopes that divides the declared variable based on its accessibility and visibility. Following are some common 
variations of variable scopes in C++.

Instance Scope
Static Member Scope
Namespace Scope

THEORY EXERCISE:
1. What is a function in C++? Explain the concept of function declaration, definition, and calling.

A function in C is a set of statements that when called perform some specific tasks. It is the basic building block 
of a C program that provides modularity and code reusability. The programming statements of a function are enclosed 
within { } braces, having certain meanings and performing certain operations. They are also called subroutines or 
procedures in other languages.

Syntax of Functions in C
The syntax of function can be divided into 3 aspects:

Function Declaration
Function Definition
Function Calls
Function Declarations
In a function declaration, we must provide the function name, its return type, and the number and type of its parameters. 
A function declaration tells the compiler that there is a function with the given name defined somewhere else in the 
program.

Syntax
return_type name_of_the_function (parameter_1, parameter_2);
The parameter name is not mandatory while declaring functions. We can also declare the function without using the name 
of the data variables.

Example
int sum(int a, int b);  // Function declaration with parameter names
int sum(int , int);      // Function declaration without parameter names

Function Definition
The function definition consists of actual statements which are executed when the function is called (i.e. when the 
program control comes to the function).

A C function is generally defined and declared in a single step because the function definition always starts with the 
function declaration so we do not need to declare it explicitly. The below example serves as both a function 
definition and a declaration.

return_type function_name (para1_type para1_name, para2_type para2_name)
{
    // body of the function
}

Function Call
A function call is a statement that instructs the compiler to execute the function. We use the function name and 
parameters in the function call.

In the below example, the first sum function is called and 10,30 are passed to the sum function. After the function 
call sum of a and b is returned and control is also returned back to the main function of the program.

How Does C Function Work?
Working of the C function can be broken into the following steps as mentioned below:

Declaring a function: Declaring a function is a step where we declare a function. Here we specify the return types and 
parameters of the function.
Defining a function: This is where the function’s body is provided. Here, we specify what the function does, including the 
operations to be performed when the function is called.
Calling the function: Calling the function is a step where we call the function by passing the arguments in the function.
Executing the function: Executing the function is a step where we can run all the statements inside the function to get 
the final result.
Returning a value: Returning a value is the step where the calculated value after the execution of the function is 
returned. Exiting the function is the final step where all the allocated memory to the variables, functions, etc is 
destroyed before giving full control back to the caller.

Types of Functions
There are two types of functions in C:

Library Functions
User Defined Functions

1. Library Function
A library function is also referred to as a “built-in function”. A compiler package already exists that contains these 
functions, each of which has a specific meaning and is included in the package. Built-in functions have the advantage of 
being directly usable without being defined, whereas user-defined functions must be declared and defined before being used. 

For Example:

pow(), sqrt(), strcmp(), strcpy() etc.

2. User Defined Function
Functions that the programmer creates are known as User-Defined functions or “tailor-made functions”. User-defined 
functions can be improved and modified according to the need of the programmer. Whenever we write a function that is 
case-specific and is not defined in any header file, we need to declare and define our own functions 

Advantages of Functions in C
Functions in C is a highly useful feature of C with many advantages as mentioned below:

The function can reduce the repetition of the same statements in the program.
The function makes code readable by providing modularity to our program.
There is no fixed number of calling functions it can be called as many times as you want.
The function reduces the size of the program.
Once the function is declared you can just use it without thinking about the internal working of the function.
Disadvantages of Functions in C
The following are the major disadvantages of functions in C:

Cannot return multiple values.
Memory and time overhead due to stack frame allocation and transfer of program control.

2. What is the scope of variables in C++? Differentiate between local and global scope.

In C++, the scope of a variable is the extent in the code upto which the variable can be accessed or worked with. 
It is the region of the program where the variable is accessible using the name it was declared with.

#include <iostream>
using namespace std;

// Declaring first variable
int a = 10;

int main() {

      // Declaring second variable
      int b = 9;

      // Accessing a and b variable in their scope
    cout << a << " " << b;

    return 0;
}

Output
10 9

Global Scope
Global scope refers to the region outside any function or a block. The variables declared here are accessible throughout 
the entire program and are called Global Variables.

#include<iostream>
using namespace std;

// Global variable
int global = 5;

// Global variable accessed from within
// a function
void display() {
    cout << global << endl;
}

int main() {
    display();
    
    // Changing value of global from main
      // function before calling display()
    global = 10;
    display();
  
      return 0;
}

Output
5
10

Local Scope
The local scope is the region inside the curly braces { }. Variables defined within a function or block are said to be 
local to those functions or a block and are called local variables. Local variables do not exist outside the block in 
which they are declared, i.e. they cannot be accessed or used outside that block.

#include<iostream>
using namespace std;

void func() {
  
    // This variable is local to function func() and
      // cannot be accessed outside this function
    int age = 18;
}

int main() {
  
      // Accessing variable from func() in main function
    cout << "Age is: " << age;
    
    return 0;
}

Output

./Solution.cpp: In function 'int main()':
./Solution.cpp:14:27: error: 'age' was not declared in this scope
     cout << "Age is: " << age;
                           ^

Variations of Scopes in C++
Apart from the primary classification of the scopes as global and local, there are few other specialized variations of 
these scopes that divides the declared variable based on its accessibility and visibility. Following are some common 
variations of variable scopes in C++.

Instance Scope
Static Member Scope
Namespace Scope

Local Variables:

Local variables are declared within a specific block of code, such as within a function or a loop.
They are only accessible within the block in which they are declared.
Once the block of code in which they are declared exits, the memory allocated to these variables is released, and they 
are no longer accessible.
Local variables can have the same name as variables in other blocks without conflict because their scope is limited to 
the block in which they are declared.
They are typically used for temporary storage or only relevant data within a specific context.

Global Variables:
Global variables are declared outside of any function or block of code, usually at the top of a program or in a separate 
file.
They are accessible from any part of the program, including within functions, loops, or other blocks of code.
Global variables retain their value throughout the lifetime of the program unless explicitly modified or reset.
Due to their accessibility from anywhere in the program, global variables can introduce unintended side effects and 
make it harder to understand and debug code, especially in larger programs.
They are typically used for values that need to be accessed and modified by multiple parts of the program.

3. Explain recursion in C++ with an example

Assume that you have to paint a few balls. If you do it alone, it will take a lot of time. One thing you can do is to 
take help from your friend. Assuming that you have the same work speed, the task will be done in half of the time. Now, 
instead of taking help from only one of your friends, you take help from multiple friends such that each friend have 
only one ball to paint. The task will be done much faster as compared to when you were doing it alone. Recursion is a 
problem-solving technique that works in a similar way.

C++ Recursion
Recursion in C++ is a technique in which a function calls itself repeatedly until a given condition is satisfied. 
In other words, recursion is the process of solving a problem by breaking it down into smaller, simpler sub-problems.

Syntax Structure of Recursion
return_type recursive_func {
    ....
       // Base Condition
       // Recursive Case
       ....
}

Recursive Function
A function that calls itself is called a recursive function. When a recursive function is called, it executes a set of 
instructions and then calls itself to execute the same set of instructions with a smaller input. This process continues 
until a base case is reached, which is a condition that stops the recursion and returns a value.

Base Condition
The base condition is the condition that is used to terminate the recursion. The recursive function will keep calling 
itself till the base condition is satisfied.

Recursive Case
Recursive case is the way in which the recursive call is present in the function. Recursive case can contain multiple 
recursive calls, or different parameters such that at the end, the base condition is satisfied and the recursion is 
terminated.

// C++ Program to calculate the sum of first N natural
// numbers using recursion
#include <iostream>
using namespace std;

int nSum(int n)
{
    // base condition to terminate the recursion when N = 0
    if (n == 0) {
        return 0;
    }

    // recursive case / recursive call
    int res = n + nSum(n - 1);

    return res;
}

int main()
{
    int n = 5;

    // calling the function
    int sum = nSum(n);

    cout << "Sum = " << sum;
    return 0;
}

Output
Sum = 15

Types of Recursion in C++
There are two different types of recursion which are as follows:

Direct Recursion
Indirect Recursion
1. Direct Recursion
In direct recursion, the function contains one or more recursive calls to itself. The function directly calls itself in 
the direct recursion and there is no intermediate function. Direct recursion can also be classified into three types 
based on how and how many recursive calls are present in the body of the function.

a) Head Recursion: In head recursion, the recursive call is present at the start of the function. It is a kind of linear 
recursion where only a single recursive call is used.

b) Tail Recursion: Tail recursion is a linear recursion where it’s one and only recursive call is present at the end of 
the function. The recursive call is generally the last statement in the function. The significance of tail recursion is 
that we can reduce its memory consumption by using tail call optimization.

c) Tree Recursion: In Tree Recursion, there are multiple recursive calls present in the body of the function. While 
tracing tree recursion, we get a tree-like structure where multiple recursive calls branch from one function.

2. Indirect Recursion
In indirect recursion, the function does not call itself directly but instead, it calls another function which then 
eventually calls the first function creating a cycle of function calls.

// C++ Program to find fibonacci series using recursion
#include <iostream>
using namespace std;

// Function for fibonacci
int fib(int n)
{
    // Stop condition
    if (n == 0)
        return 0;
    // Stop condition
    if (n == 1 || n == 2)
        return 1;
    // Recursion function
    else
        return (fib(n - 1) + fib(n - 2));
}

// Driver Code
int main()
{
    // Initialize variable n.
    int n = 5;
    cout << "Fibonacci series of 5 numbers is: ";
    // for loop to print the fibonacci series.
    for (int i = 0; i < n; i++) {
        cout << fib(i) << " ";
    }
    return 0;
}


Output
Fibonacci series of 5 numbers is: 0 1 1 2 3 

Applications of Recursion
Recursion has many applications in computer science and programming. Here are some of the most common applications of 
recursion:

Solving: Fibonacci sequences, Factorial Function, Reversing an array, Tower of Hanoi.
Backtracking: It is a technique for solving problems by trying out different solutions and undoing them if they do not 
work. Recursive algorithms are often used in backtracking.
Searching and Sorting Algorithms: Many searching and sorting algorithms, such as binary search and quicksort, use 
recursion to divide the problem into smaller sub-problems.
Tree and Graph Traversal: Recursive algorithms are often used to traverse trees and graphs, such as depth-first search 
and breadth-first search.
Mathematical Computations: Recursion is also used in many mathematical computations, such as the factorial function and 
the Fibonacci sequence.
Dynamic Programming: It is a technique for solving optimization problems by breaking them down into smaller sub-problems. 
Recursive algorithms are often used in dynamic programming.

Drawbacks of Recursion
Performance: Recursive algorithms can be less efficient than iterative algorithms in some cases, particularly if the data 
structure is large or if the recursion goes too deep.
Memory usage: Recursive algorithms can use a lot of memory, particularly if the recursion goes too deep or if the data 
structure is large. Each recursive call creates a new stack frame on the call stack, which can quickly add up to a 
significant amount of memory usage.
Code complexity: Recursive algorithms can be more complex than iterative algorithms.
Debugging: Recursive algorithms can be more difficult to debug than iterative algorithms, particularly if the recursion 
goes too deep or if the program is using multiple recursive calls.
Stack Overflow: If the recursion goes too deep, it can cause a stack overflow error, which can crash the program.

4. What are function prototypes in C++? Why are they used?

Function prototype tells the return type of the data that the function will return.
Function prototype tells the number of arguments passed to the function.
Function prototype tells the data types of each of the passed arguments.
Also, the function prototype tells the order in which the arguments are passed to the function.

If one doesn’t specify the function prototype, the behavior is specific to the C standard (either C90 or C99) that the 
compilers implement. Up to the C90 standard, C compilers assumed the return type of the omitted function prototype as int. 
And this assumption on the compiler side may lead to unspecified program behavior.

Later C99 standard specified that compilers could no longer assume the return type as int. Therefore, C99 became more 
restricted in type checking of function prototypes. But to make C99 standard backward compatible, in practice, compilers 
throw the warning saying that the return type is assumed as int. But they go ahead with compilation. Thus, it becomes 
the responsibility of programmers to make sure that the assumed function prototype and the actual function type match.

// C program to demonstrate the error occured
// when function prototype is not specified

// Prototype of foo() function is not specified

int main()
{
	// foo() function called
	foo();
	getchar();
	return 0;
}

// definition of foo() function
void foo() {
printf("foo called");
}


Output

main.c: In function ‘foo’:
main.c:8:3: warning: implicit declaration of function ‘printf’ [-Wimplicit-function-declaration]
   8 |   printf("foo called");
     |   ^~~~~~

5. Arrays and Strings
LAB EXERCISES:
1. Array Sum and Average o Write a C++ program that accepts an array of integers, calculates the sum and average, and 
displays the results

#include <iostream>
using namespace std;

int main()
{
    int n, i;
    float num[100], sum=0.0, average;

    cout << "Enter the numbers of data: ";
    cin >> n;

    while (n > 100 || n <= 0)
    {
        cout << "Error! number should in range of (1 to 100)." << endl;
        cout << "Enter the number again: ";
        cin >> n;
    }

    for(i = 0; i < n; ++i)
    {
        cout << i + 1 << ". Enter number: ";
        cin >> num[i];
        sum += num[i];
    }

    average = sum / n;
    cout << "Average = " << average;

    return 0;
}
Output

Enter the numbers of data: 6
1. Enter number: 45.3
2. Enter number: 67.5
3. Enter number: -45.6
4. Enter number: 20.34
5. Enter number: 33
6. Enter number: 45.6
Average = 27.69

o Objective: Understand basic array manipulation.

This article demonstrates some of the inbuilt functions that can be used to query and manipulate array types, even a 
multidimensional array. These functions can be useful in cases we need information or manipulate array we initiated 
with different dimensions. These functions are defined in header file . Some of the functions include :

is_array() : As the name suggest, the sole purpose of this function is to check if a variable is a array type or not. 
Notable here is that even an std::array is not considered an array according to this function. The “value” member constant 
returns true if type is array, else returns a false.
is_same() : This function is to check Type relationships and it returns true if two types have exactly same 
characteristics. The “value” member constant returns true if types are same, else returns a false.


// C++ code to demonstrate the working of 
// is_array() and is_same() 

#include<type_traits> 
#include<iostream> 
#include<array> 
#include<string> 
using namespace std; 

int main() 
{ 
	// checking which is array using is_array 
	cout << "Is Integer an array? : " << is_array<int>::value << endl; 
	
	cout << "Is Array an array? : " << is_array<int[10]>::value << endl; 
	
	cout << "Is 2D Array an array? : "
	<< is_array<int[10][10]>::value << endl; 
	
	cout << "Is String an array? : " << is_array<string>::value << endl; 
	
	cout << "Is Character Array an array? : "
	<< is_array<char[10]>::value << endl; 
	
	cout << "Is Array class type an array? : "
	<< is_array<array<int,3>>::value << endl; 
	
	cout << endl; 
	
	// checking for same types using is_same() 
	cout << "Is 2D array same as 1D array? : " << 
	is_same<int[10],int[10][10]>::value << endl; 
	
	cout << "Is Character array same as Integer array? : "
	<< is_same<int[10],char[10]>::value << endl; 
	
	cout << "Is 1D array same as 1D array (Different sizes) ? : "
	<< is_same<int[10],int[20]>::value << endl; 
	
	cout << "Is 1D array same as 1D array? (Same sizes): "
	<< is_same<int[10],int[10]>::value << endl; 
	return 0; 
} 


Output:

Is Integer an array? : 0
Is Array an array? : 1
Is 2D Array an array? : 1
Is String an array? : 0
Is Character Array an array? : 1
Is Array class type an array? : 0

Is 2D array same as 1D array? : 0
Is Character array same as Integer array? : 0
Is 1D array same as 1D array (Different sizes) ? : 0
Is 1D array same as 1D array? (Same sizes): 1

rank() : This is a property query function which returns the rank of the array. Rank means the dimension of the array. 
The value member constant returns the rank of object.

// C++ code to demonstrate the working of 
// rank() 

#include<type_traits> // for array query functions 
#include<iostream> 
using namespace std; 

int main() 
{ 
	// checking rank of different types 
	cout << "The rank of integer is : " << rank<int>::value << endl; 
	
	cout << "The rank of 1D integer array is : "
	<< rank<int[10]>::value << endl; 
	
	cout << "The rank of 2D integer array is : "
	<< rank<int[20][10]>::value << endl; 
	
	cout << "The rank of 3D integer array is : "
	<< rank<int[20][10][40]>::value << endl; 
	
	cout << "The rank of 1D character array is : "
	<< rank<char[10]>::value << endl; 

	cout << endl; 
	
} 

Output:

The rank of integer is : 0
The rank of 1D integer array is : 1
The rank of 2D integer array is : 2
The rank of 3D integer array is : 3
The rank of 1D character array is : 1

extent() : Both extent and remove extent are Compound type alterations that can be applied to arrays in C++. This function 
returns the size of the particular dimension of array. This function takes two arguments, the array type and the 
dimension in whose size have to be found. This also has the member constant value for printing value.
remove_extent() : This function removes the first dimension from left in the matrix/array declared.
remove_all_extents() : This function removes all the dimensions of the matrix/array and converts it into base data type.

// C++ code to demonstrate the working of 
// extent(), remove_extent(), remove_all_extents() 

#include<type_traits> // for array query functions 
#include<iostream> 
using namespace std; 

int main() 
{ 

	
	// Checking extent of different types (using extent) 
	cout << "The extent of 1st dimension of 3D integer array is : " ; 
	cout << extent<int[20][10][40],0>::value << endl; 
	
	cout << "The extent of 2nd dimension of 3D integer array is : " ; 
	cout << extent<int[20][10][40],1>::value << endl; 
	
	cout << "The extent of 3rd dimension of 3D integer array is : " ; 
	cout << extent<int[20][10][40],2>::value << endl; 
	
	cout << "The extent of 4th dimension of 3D integer array is : " ; 
	cout << extent<int[20][10][40],3>::value << endl; 
	
	cout << endl; 
	
	// Removing extent of types 
	cout << "The rank after removing 1 extent is : " ; 
	cout << rank<remove_extent<int[20][10][30]>::type>::value << endl; 
	
	// 1st dimension from left is deleted 
	cout << "The extent of 1st after removing 1 extent is : " ; 
	cout << extent<remove_extent<int[20][10][30]>::type>::value << endl; 
	
	cout << endl; 
	
	// Removing all extents of types 
	cout << "The rank after removing all extents is : " ; 
	cout << rank<remove_all_extents<int[20][10][30]>::type>::value << endl; 
	
	// All extents are deleted 
	cout << "The extent of 1st after removing all extents is : " ; 
	cout << extent<remove_all_extents<int[20][10][30]>::type>::value << endl; 

	cout << endl; 
	
} 

Output:

The extent of 1st dimension of 3D integer array is  : 20
The extent of 2nd dimension of 3D integer array is  : 10
The extent of 3rd dimension of 3D integer array is  : 40
The extent of 4th dimension of 3D integer array is  : 0

The rank after removing 1 extent is : 2
The extent of 1st after removing 1 extent is : 10

The rank after removing all extents is : 0
The extent of 1st after removing all extents is : 0

2. Matrix Addition o Write a C++ program to perform matrix addition on two 2x2 matrices.

#include <iostream>
using namespace std;

int main()
{
    int r, c, a[100][100], b[100][100], sum[100][100], i, j;

    cout << "Enter number of rows (between 1 and 100): ";
    cin >> r;

    cout << "Enter number of columns (between 1 and 100): ";
    cin >> c;

    cout << endl << "Enter elements of 1st matrix: " << endl;

    // Storing elements of first matrix entered by user.
    for(i = 0; i < r; ++i)
       for(j = 0; j < c; ++j)
       {
           cout << "Enter element a" << i + 1 << j + 1 << " : ";
           cin >> a[i][j];
       }

    // Storing elements of second matrix entered by user.
    cout << endl << "Enter elements of 2nd matrix: " << endl;
    for(i = 0; i < r; ++i)
       for(j = 0; j < c; ++j)
       {
           cout << "Enter element b" << i + 1 << j + 1 << " : ";
           cin >> b[i][j];
       }

    // Adding Two matrices
    for(i = 0; i < r; ++i)
        for(j = 0; j < c; ++j)
            sum[i][j] = a[i][j] + b[i][j];

    // Displaying the resultant sum matrix.
    cout << endl << "Sum of two matrix is: " << endl;
    for(i = 0; i < r; ++i)
        for(j = 0; j < c; ++j)
        {
            cout << sum[i][j] << "  ";
            if(j == c - 1)
                cout << endl;
        }

    return 0;
}
Output

Enter number of rows (between 1 and 100): 2
Enter number of columns (between 1 and 100): 2

Enter elements of 1st matrix:
Enter element a11: -4
Enter element a12: 5
Enter element a21: 6
Enter element a22: 8

Enter elements of 2nd matrix:
Enter element b11: 3
Enter element b12: -9
Enter element b21: 7
Enter element b22: 2

Sum of two matrix is:
-1   -4
13   10

o Objective: Practice multi-dimensional arrays

#include <iostream>
using namespace std;

int main()
{
    int r, c, a[100][100], b[100][100], sum[100][100], i, j;

    cout << "Enter number of rows (between 1 and 100): ";
    cin >> r;

    cout << "Enter number of columns (between 1 and 100): ";
    cin >> c;

    cout << endl << "Enter elements of 1st matrix: " << endl;

    // Storing elements of first matrix entered by user.
    for(i = 0; i < r; ++i)
       for(j = 0; j < c; ++j)
       {
           cout << "Enter element a" << i + 1 << j + 1 << " : ";
           cin >> a[i][j];
       }

    // Storing elements of second matrix entered by user.
    cout << endl << "Enter elements of 2nd matrix: " << endl;
    for(i = 0; i < r; ++i)
       for(j = 0; j < c; ++j)
       {
           cout << "Enter element b" << i + 1 << j + 1 << " : ";
           cin >> b[i][j];
       }

    // Adding Two matrices
    for(i = 0; i < r; ++i)
        for(j = 0; j < c; ++j)
            sum[i][j] = a[i][j] + b[i][j];

    // Displaying the resultant sum matrix.
    cout << endl << "Sum of two matrix is: " << endl;
    for(i = 0; i < r; ++i)
        for(j = 0; j < c; ++j)
        {
            cout << sum[i][j] << "  ";
            if(j == c - 1)
                cout << endl;
        }

    return 0;
}
Output

Enter number of rows (between 1 and 100): 2
Enter number of columns (between 1 and 100): 2

Enter elements of 1st matrix:
Enter element a11: -4
Enter element a12: 5
Enter element a21: 6
Enter element a22: 8

Enter elements of 2nd matrix:
Enter element b11: 3
Enter element b12: -9
Enter element b21: 7
Enter element b22: 2

Sum of two matrix is:
-1   -4
13   10

3. String Palindrome Check o Write a C++ program to check if a given string is a palindrome (reads the same forwards and 
backwards).

// C++ program to check whether the given string
// is palindrome or not using reverse() function
#include <bits/stdc++.h>
using namespace std;

void isPalindrome(string str) {
  
      // Stores the reverse of the string s
    string rev = str;

    // Reverse the string
    reverse(rev.begin(), rev.end());

    // If rev is equal to str
    if (str == rev)
        cout << "\"" << str
          << "\" is palindrome." << endl;
      
    // If rev is NOT equal to str
    else
        cout << "\"" << str
          << "\" is NOT palindrome." << endl;
}

int main() {
    
      // Checking if strings given strings are palindrome
    isPalindrome("ABCDCBA");
      isPalindrome("ABCD");

    return 0;
}

Output
Palindrome

// C++ program to check whether the string
// is palindrome or not using loop
#include <bits/stdc++.h>
using namespace std;

void isPalindrome (string str) {
  
      // Specify the starting and ending indexes
    int left = 0, right = str.size() - 1;
  
      // Flag to terminate the loop if mismatch
      // characters found
      bool flag = true;
      
      // Till the left is less than right
    while (left < right) {

        // If any character not match, break the
        // loop, string is not palindrome
        if (str[left] != str[right]) {
            flag = false;
            break;
        }
        left++;
        right--;
    }
      
      if (flag)
        cout << "\"" << str
          << "\" is palindrome." << endl;
          
    else
        cout << "\"" << str
          << "\" is NOT palindrome." << endl;
}
  

int main() {
  
      // Checking if given strings are palindrome
      isPalindrome("ABCDCBA");
    isPalindrome("ABCD");            
    return 0;
}

Output
Palindrome

o Objective: Practice string operations.

C++ strings are sequences of characters stored in a char array. Strings are used to store words and text. They are also 
used to store data, such as numbers and other types of information.

1. C Style Strings
These strings are stored as the plain old array of characters terminated by a null character ‘\0’. They are the type of 
strings that C++ inherited from C language.

Syntax:

char str[] = "language"; 

// C++ Program to demonstrate strings
#include <iostream>
using namespace std;

int main()
{

    char s[] = "language";
    cout << s << endl;
    return 0;
}

Output
language

2. std::string Class
These are the new types of strings that are introduced in C++ as std::string class defined inside <string> header file. 
This provides many advantages over conventional C-style strings such as dynamic size, member functions, etc.

Syntax:

std::string str("language");

// C++ program to create std::string objects
#include <iostream>
using namespace std;

int main()
{

    string str("language");
    cout << str;
    return 0;
}

Output
language

Ways to Define a String in C++
Strings can be defined in several ways in C++. Strings can be accessed from the standard library using the string class. 
Character arrays can also be used to define strings. String provides a rich set of features, such as searching and 
manipulating, which are commonly used methods. Despite being less advanced than the string class, this method is still 
widely used, as it is more efficient and easier to use. Ways to define a string in C++ are:

Using String keyword
Using C-style strings

1. Using string Keyword
It is more convenient to define a string with the string keyword instead of using the array keyword because it is easy to write and understand.

Syntax:

string s = "language";
string s("language");

// C++ Program to demonstrate use of string keyword
#include <iostream>
using namespace std;

int main()
{

    string s = "language";
    string str("language");

    cout << "s = " << s << endl;
    cout << "str = " << str << endl;

    return 0;
}

Output
s = language
str = language

2. Using C-style strings
Using C-style string libraries functions such as strcpy(), strcmp(), and strcat() to define strings. This method is 
more complex and not as widely used as the other two, but it can be useful when dealing with legacy code or when you 
need performance.

char s[] = {'g', 'f', 'g', '\0'};
char s[4] = {'g', 'f', 'g', '\0'};
char s[4] = "gfg";
char s[] = "gfg";

// C++ Program to demonstrate C-style string declaration
#include <iostream>
using namespace std;

int main()
{

    char s1[] = { 'g', 'f', 'g', '\0' };
    char s2[4] = { 'g', 'f', 'g', '\0' };
    char s3[4] = "gfg";
    char s4[] = "gfg";

    cout << "s1 = " << s1 << endl;
    cout << "s2 = " << s2 << endl;
    cout << "s3 = " << s3 << endl;
    cout << "s4 = " << s4 << endl;

    return 0;
}

Output
s1 = gfg
s2 = gfg
s3 = gfg
s4 = gfg

#include <iostream>
using namespace std;

int main()
{
    string S = "language";
    cout << "Your string is= ";
    cout << S << endl;

    return 0;
}

Output
Your string is= language

How to Take String Input in C++
String input means accepting a string from a user. In C++. We have different types of taking input from the user 
which depend on the string. The most common way is to take input with cin keyword with the extraction operator (>>) 
in C++. Methods to take a string as input are:

cin
getline
stringstream
1. Using Cin
The simplest way to take string input is to use the cin command along with the stream extraction operator (>>). 

Syntax:

cin>>s;
Example:


// C++ Program to demonstrate string input using cin
#include <iostream>
using namespace std;

int main() {

      string s;
      
    cout<<"Enter String"<<endl;
      cin>>s;
  
      cout<<"String is: "<<s<<endl;
    return 0;
}

Output
Enter String
String is: 
Output:

Enter String
language
String is: language

2. Using getline 
The getline() function in C++ is used to read a string from an input stream. It is declared in the <string> header file.

Syntax:

getline(cin,s);

// C++ Program to demonstrate use of getline function
#include <iostream>
using namespace std;

int main()
{

    string s;
    cout << "Enter String" << endl;
    getline(cin, s);
    cout << "String is: " << s << endl;
    return 0;
}

Output
Enter String
String is: 
Output:

Enter String
language
String is: language

3. Using stringstream
The stringstream class in C++ is used to take multiple strings as input at once. 

Syntax:

stringstream stringstream_object(string_name);

// C++ Program to demonstrate use of stringstream object
#include <iostream>
#include <sstream>
#include<string>

using namespace std;

int main()
{

    string s = " language in the c++ ";
    stringstream obj(s);
    // string to store words individually
    string temp;
    // >> operator will read from the stringstream object
    while (obj >> temp) {
        cout << temp << endl;
    }
    return 0;
}

Output
language
in
the
c++

How to Pass Strings to Functions?
In the same way that we pass an array to a function, strings in C++ can be passed to functions as character arrays. 
Here is an example program:

// C++ Program to print string using function
#include <iostream>
using namespace std;

void print_string(string s)
{
    cout << "Passed String is: " << s << endl;
    return;
}

int main()
{

    string s = "language";
    print_string(s);

    return 0;
}

Output
Passed String is: language

C++ String Functions
C++ provides some inbuilt functions which are used for string manipulation, such as the strcpy() and strcat() functions for copying and concatenating strings. Some of them are:

Function

Description

length()	This function returns the length of the string.
swap() 	        This function is used to swap the values of 2 strings.
size() 	        Used to find the size of string
resize()	This function is used to resize the length of the string up to the given number of characters.
find()	        Used to find the string which is passed in parameters
push_back()	This function is used to push the passed character at the end of the string
pop_back() 	This function is used to pop the last character from the string
clear() 	This function is used to remove all the elements of the string.
strncmp()	This function compares at most the first num bytes of both passed strings.
strncpy()	This function is similar to strcpy() function, except that at most n bytes of src are copied
strrchr()	This function locates the last occurrence of a character in the string.
strcat()	This function appends a copy of the source string to the end of the destination string
find()	        This function is used to search for a certain substring inside a string and returns the position of the first 
                character of the substring. 
replace()	This function is used to replace each element in the range [first, last) that is equal to old value with 
                new value.
substr()	This function is used to create a substring from a given string. 
compare()	This function is used to compare two strings and returns the result in the form of an integer.
erase()	        This function is used to remove a certain part of a string.

1. What are arrays in C++? Explain the difference between single-dimensional and multi- dimensional arrays.

Array is a data structure that is used to store variables that are of similar data types at contiguous locations. 
The main advantage of the array is random access and cache friendliness. There are mainly three types of the array:

One Dimensional (1D) Array
Two Dimension (2D) Array
Multidimensional Array
One Dimensional Array: 

It is a list of the variable of similar data types.
It allows random access and all the elements can be accessed with the help of their index.
The size of the array is fixed.
For a dynamically sized array, vector can be used in C++.

Two Dimensional Array:

It is a list of lists of the variable of the same data type.
It also allows random access and all the elements can be accessed with the help of their index.
It can also be seen as a collection of 1D arrays. It is also known as the Matrix.
Its dimension can be increased from 2 to 3 and 4 so on.
They all are referred to as a multi-dimension array.
The most common multidimensional array is a 2D array.

Applications of Arrays:

2D Arrays are used to implement matrices.
Arrays can be used to implement various data structures like a heap, stack, queue, etc.
They allow random access.
They are cache-friendly.

One Dimension Array

Store a single list of the element of a similar data type.
Represent multiple data items as a list.
The declaration varies for different programming language:

For C++,  
datatype variable_name[row]
For Java,  
datatype [] variable_name= new datatype[row]

One
size of(datatype of the variable of the array) * size of the array
Address of a[index] is equal to (base Address+ Size of each element of array * index).
int arr[5];  //an array with one row and five columns will be created.

{a , b , c , d , e}


Two Dimension Array

Store a ‘list of lists’ of the element of a similar data type.
Represent multiple data items as a table consisting of rows and columns.
The declaration varies for different programming language:

For C++, 
datatype variable_name[row][column]
For Java,  
datatype [][] variable_name= new datatype[row][column]
Dimension	
Two

size of(datatype of the variable of the array)* the number of rows* the number of columns.
Address of a[i][j] can be calculated in two ways row-major and column-major

Column Major: Base Address + Size of each element (number of rows(j-lower bound of the column)+(i-lower bound of the rows))
Row Major: Base Address + Size of each element (number of columns(i-lower bound of the row)+(j-lower bound of the column))

int arr[2][5];  //an array with two rows and five columns will be created.

               a  b  c  d  e

               f  g   h  i   j

2. Explain string handling in C++ with examples.

The <string> library has many functions that allow you to perform tasks on strings.

Function	Description
at()	Returns an indexed character from a string
length()	Returns the length of a string
size()	Alias of length(). Returns the length of a string
max_size()	Returns the maximum length of a string
empty()	Checks wheter a string is empty or not
append()	Appends a string (or a part of a string) to another string
substr()	Returns a part of a string from a start index (position) and length
find()	Returns the index (position) of the first occurrence of a string or character
rfind()	Returns the index (position) of the last occurrence of a string or character
replace()	Replaces a part of a string with another string
insert()	Inserts a string at a specified index (position)
erase()	Removes characters from a string
compare()	Compares two strings


3. How are arrays initialized in C++? Provide examples of both 1D and 2D arrays.

Initializing an Array in C++
To initialize an array in C++, we can use the assignment operator = to assign values to the array at the time of 
declaration. The values are provided in a comma-separated list enclosed in curly braces {}.

Syntax to Initialize an Array in C++
We can use the below syntax to initialize an array at the time of declaration.

datatype arrayName[arraySize] = {element, element2, ..., elementN};
C++ Program to Initialize an Array

// C++ Program to illustrate how to initialize an array
#include <iostream>
using namespace std;

int main()
{
    // Initialize an array using initializer list
    int arr[5] = { 10, 20, 30, 40, 50 };

    // Find the size of the array
    int size = sizeof(arr) / sizeof(arr[0]);

    // Print the elements of the array
    cout << "Array Initialized" << endl;

    cout << "Array Elements:";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }

    return 0;
}

Output
Array Initialized
Array Elements:10 20 30 40 50 

One Dimensional Array
In computer science, Array is a type of Data structure that is used to store elements of the same data type in 
continuous memory locations. Arrays let us store multiple values of the same data type in a single variable. 
Different types of arrays make it possible to store the values in various structures. One of the most common structures 
of an Array in which the values are stored is the One Dimensional Array Structure.

Definition
A One-Dimensional Array is the simplest form of an Array in which the elements are stored linearly and can be accessed 
individually by specifying the index value of each element stored in the array.
A One-Dimensional Array is a group of elements having the same data type which are stored in a linear arrangement 
under a single variable name.

One Dimensional Array
This is one of the simplest forms of Array. They are very easy to define and use in the programs. The values stored 
in a One Dimensional Array can be easily initialized and manipulated, making it a very feasible Data structure type.

Declaration Syntax
                    
data_type array_name [array_size] ;
where,

array_name = name of the 1D array

array_size = defines the number of elements in the array

Initialization Syntax

To Initialize the 1D Array, we simply add a list to the right side of the declaration syntax of the 1D Array. 
In simple terms, we assign values to the declared 1D Array as per the array size specified.
                    
data_type array_name [array_size] = {comma_separated_element_list};

int arr [10] ;      // Declaring a 1D array of size 10

int roll_no [5] =  {1, 2, 3, 4, 5} ;      // Initializing a 1D array of size 5

char names[30] = {"Raj, John, Krish"} ;   // Initializing a 1D array of type char


Direct Initialization
In this method, the elements are assigned during the declaration of the 1D Array.

Example
                    
int num [10] = {1, 3, 5, 7, 9, 2, 4, 6, 8, 10} ;
User Input Method
In this method, The user is asked to enter the array elements of his/her choice during the run-time of the program.

Example –
                    
#include <iostream>
using namespace std;
int main()
{
  int num [5] ;
  cout<<"Enter array elements : \n";
  for(int i = 0; i < 5 ; i++)
  {
    cin >> num[i] ;
  }
}
Output –
                    
Enter array elements :
1
3
5
7
9

1. Initialization of two-dimensional array
int test[2][3] = {2, 4, 5, 9, 0, 19};
The above method is not preferred. A better way to initialize this array with the same array elements is given below:

int  test[2][3] = { {2, 4, 5}, {9, 0, 19}};
This array has 2 rows and 3 columns, which is why we have two rows of elements with 3 elements each.

// C++ Program to display all elements
// of an initialised two dimensional array

#include <iostream>
using namespace std;

int main() {
    int test[3][2] = {{2, -5},
                      {4, 0},
                      {9, 1}};

    // use of nested for loop
    // access rows of the array
    for (int i = 0; i < 3; ++i) {

        // access columns of the array
        for (int j = 0; j < 2; ++j) {
            cout << "test[" << i << "][" << j << "] = " << test[i][j] << endl;
        }
    }

    return 0;
}

Output

test[0][0] = 2
test[0][1] = -5
test[1][0] = 4
test[1][1] = 0
test[2][0] = 9
test[2][1] = 1

4. Explain string operations and functions in C++.

The <string> library has many functions that allow you to perform tasks on strings.

Function	Description
at()	Returns an indexed character from a string
length()	Returns the length of a string
size()	Alias of length(). Returns the length of a string
max_size()	Returns the maximum length of a string
empty()	Checks wheter a string is empty or not
append()	Appends a string (or a part of a string) to another string
substr()	Returns a part of a string from a start index (position) and length
find()	Returns the index (position) of the first occurrence of a string or character
rfind()	Returns the index (position) of the last occurrence of a string or character
replace()	Replaces a part of a string with another string
insert()	Inserts a string at a specified index (position)
erase()	Removes characters from a string
compare()	Compares two strings


6. Introduction to Object-Oriented Programming
LAB EXERCISES:
1. Class for a Simple Calculator o Write a C++ program that defines a class Calculator with functions for addition, 
subtraction, multiplication, and division. Create objects to use these functions.

# include <iostream>
using namespace std;

int main() {

  char op;
  float num1, num2;

  cout << "Enter operator: +, -, *, /: ";
  cin >> op;

  cout << "Enter two operands: ";
  cin >> num1 >> num2;

  switch(op) {

    case '+':
      cout << num1 << " + " << num2 << " = " << num1 + num2;
      break;

    case '-':
      cout << num1 << " - " << num2 << " = " << num1 - num2;
      break;

    case '*':
      cout << num1 << " * " << num2 << " = " << num1 * num2;
      break;

    case '/':
      cout << num1 << " / " << num2 << " = " << num1 / num2;
      break;

    default:
      // If the operator is other than +, -, * or /, error message is shown
      cout << "Error! operator is not correct";
      break;
  }

  return 0;
}

Output

Enter operator: +, -, *, /: -    
Enter two operands: 3.4 8.4
3.4 - 8.4 = -5

o Objective: Introduce basic class structure

Structure of a C++ Class
A class is user-defined datatype which has data members and member functions. In C++, classes are divided into the 
following three sections:

1. Class Declaration Section
2. Member Function Section
3. Main Function Section

Class Declaration Section

You can declare class using the keyword class
You can add data members and member functions inside the class.
Accessing the data members and member functions depends solely on the access modifiers, i.e., public, private or protected.
A class always starts with { and ends with };

class Animal{
   string animalName;
   public:
   Animal(string name);
   void animalSound();
   void printName();
};

Member Function Section

Member functions are methods used to access data members of the class.
Definition of member functions can be inside the class or outside the class.
This section contains definition of the member functions that are declared inside the class.

void Animal :: 
   Animal(string name){
      animalName = name;
   }
   void Animal :: animalSound(){
      cout << "Woof Woof!" << endl;
   }
   void Animal :: printName(){
      cout << animalName << endl;
   }

Main Function Section

Execution of the code starts from main.
In this section, we can create an object of a class.
We can call the functions defined inside the class.

int main(){
   Animal a("Dog");
   a.printName();
   a.animalSound();
}

#include <iostream>     // Header files
using namespace std;

class Animal{    // class name
  string animalName;      // class data member
  public:
  Animal(string name);   // Animal constructor
  void animalSound();    // Member function declaration
  void printName();
};

Animal :: Animal(string name){   // function defintion
  animalName = name;
}
void Animal :: animalSound(){
  cout << "Woof Woof!" << endl;
}
void Animal :: printName(){
  cout << animalName << endl;
}

int main(){
  Animal a("Dog");    // creating object of class Animal
  a.printName();  // calling member function 
  a.animalSound();  // calling member function
}

2. Class for Bank Account o Create a class BankAccount with data members like balance and member functions like deposit 
and withdraw. Implement encapsulation by keeping the data members private.

# Python program to create Bankaccount class
# with both a deposit() and a withdraw() function
class Bank_Account:
	def __init__(self):
		self.balance=0
		print("Hello!!! Welcome to the Deposit & Withdrawal Machine")

	def deposit(self):
		amount=float(input("Enter amount to be Deposited: "))
		self.balance += amount
		print("\n Amount Deposited:",amount)

	def withdraw(self):
		amount = float(input("Enter amount to be Withdrawn: "))
		if self.balance>=amount:
			self.balance-=amount
			print("\n You Withdrew:", amount)
		else:
			print("\n Insufficient balance ")

	def display(self):
		print("\n Net Available Balance=",self.balance)

# Driver code

# creating an object of class
s = Bank_Account()

# Calling functions with that class object
s.deposit()
s.withdraw()
s.display()


Output: 
 

Hello !!! Welcome to Deposit&Withdrawal Machine
Enter amount to be deposited: 
 Amount Deposited: 1000.0
Enter amount to be withdrawn: 
 You Withdrew: 500.0

 Net Available Balance = 500.0

o Objective: Understand encapsulation in classes

Encapsulation in C++ is defined as the wrapping up of data and information in a single unit. In Object Oriented 
Programming, Encapsulation is defined as binding together the data and the functions that manipulate them.

The finance section handles all the financial transactions and keeps records of all the data related to finance.
Similarly, the sales section handles all the sales-related activities and keeps records of all the sales.

Two Important  property of Encapsulation 

Data Protection: Encapsulation protects the internal state of an object by keeping its data members private. 
Access to and modification of these data members is restricted to the class’s public methods, ensuring controlled and 
secure data manipulation.
Information Hiding: Encapsulation hides the internal implementation details of a class from external code. Only the 
public interface of the class is accessible, providing abstraction and simplifying the usage of the class while allowing 
the internal implementation to be modified without impacting external code.

#include <iostream>
using namespace std;
class temp{
     int a;
  int b;
  public:
  int solve(int input){
    a=input;
    b=a/2;
    return b;
  }
};

int main() {
  int n;
  cin>>n;
  temp half;
  int ans=half.solve(n);
  cout<<ans<<endl;
   
}

Features of Encapsulation
Below are the features of encapsulation:

We can not access any function from the class directly. We need an object to access that function that is using the 
member variables of that class. 
The function which we are making inside the class must use only member variables, only then it is called encapsulation.
If we don’t make a function inside the class which is using the member variable of the class then we don’t call it 
encapsulation.
Encapsulation improves readability, maintainability, and security by grouping data and methods together.
It helps to control the modification of our data members.

#include <iostream>
#include <string>

using namespace std;

class Person {
  private:
    string name;
    int age;
  public:
    Person(string name, int age) {
      this->name = name;
      this->age = age;
    }
    void setName(string name) {
      this->name = name;
    }
    string getName() {
      return name;
    }
    void setAge(int age) {
      this->age = age;
    }
    int getAge() {
      return age;
    }
};

int main() {
  Person person("John Doe", 30);

  cout << "Name: " << person.getName() << endl;
  cout << "Age: " << person.getAge() << endl;

  person.setName("Jane Doe");
  person.setAge(32);

  cout << "Name: " << person.getName() << endl;
  cout << "Age: " << person.getAge() << endl;

  return 0;
}

Output
Name: John Doe
Age: 30
Name: Jane Doe
Age: 32

Role of Access Specifiers in Encapsulation
Access specifiers facilitate Data Hiding in C++ programs by restricting access to the class member functions and data 
members. There are three types of access specifiers in C++:

Private: Private access specifier means that the member function or data member can only be accessed by other member 
functions of the same class.
Protected: A protected access specifier means that the member function or data member can be accessed by other member 
functions of the same class or by derived classes.
Public: Public access specifier means that the member function or data member can be accessed by any code.

3. Inheritance Example o Write a program that implements inheritance using a base class Person and derived classes 
Student and Teacher. Demonstrate reusability through inheritance. 

Example 1: Program to Demonstrate the Simple Inheritance of a Class

// C++ program to demonstrate how to inherit a class
#include <iostream>
using namespace std;

// Base class that is to be inherited
class Parent {
public:
    // base class members
    int id_p;
    void printID_p()
    {
        cout << "Base ID: " << id_p << endl;
    }
};

// Sub class or derived publicly inheriting from Base
// Class(Parent)
class Child : public Parent {
public:
    // derived class members
    int id_c;
    void printID_c()
    {
        cout << "Child ID: " << id_c << endl;
    }
};

// main function
int main()
{
    // creating a child class object
    Child obj1;

    // An object of class child has all data members
    // and member functions of class parent
    // so we try accessing the parents method and data from
    // the child class object.
    obj1.id_p = 7;
    obj1.printID_p();

    // finally accessing the child class methods and data
    // too
    obj1.id_c = 91;
    obj1.printID_c();

    return 0;
}

Output
Base ID: 7
Child ID: 91

Example 2: Access the Inherited Members of the Base Class in Derived Class

// C++ program to illustrate how to access the inherited
// members of the base class in derived class
#include <iostream>
using namespace std;

// Base class
class Base {
public:
    // data member
    int publicVar;

    // member method
    void display()
    {
        cout << "Value of publicVar: " << publicVar;
    }
};

// Derived class
class Derived : public Base {
public:
    // Function to display inherited member
    void displayMember()
    {
        // accessing public base class member method
        display();
    }

    // Function to modify inherited member
    void modifyMember(int pub)
    {
        // Directly modifying public member
        publicVar = pub;
    }
};

int main()
{
    // Create an object of Derived class
    Derived obj;

    // Display the initial values of inherited member
    obj.modifyMember(10);

    // Display the modified values of inherited member
    obj.displayMember();

    return 0;
}

Output
Value of publicVar: 10

Modes of Inheritance in C++
Mode of inheritance controls the access level of the inherited members of the base class in the derived class. 
In C++, there are 3 modes of inheritance:

Public Mode
Protected Mode
Private Mode

Types Of Inheritance in C++
The inheritance can be classified on the basis of the relationship between the derived class and the base class. 
In C++, we have 5 types of inheritances:

Single inheritance
Multilevel inheritance
Multiple inheritance
Hierarchical inheritance
Hybrid inheritance

1. Single Inheritance
In single inheritance, a class is allowed to inherit from only one class. i.e. one base class is inherited by one 
derived class only.

// C++ program to demonstrate how to implement the Single
// inheritance
#include <iostream>
using namespace std;

// base class
class Vehicle {
public:
    Vehicle() { cout << "This is a Vehicle\n"; }
};

// sub class derived from a single base classes
class Car : public Vehicle {
public:
    Car() { cout << "This Vehicle is Car\n"; }
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base classes
    Car obj;
    return 0;
}

Output
This is a Vehicle
This Vehicle is Car

2. Multiple Inheritance
Multiple Inheritance is a feature of C++ where a class can inherit from more than one class. i.e one subclass is 
inherited from more than one base class.

// C++ program to illustrate the multiple inheritance
#include <iostream>
using namespace std;

// first base class
class Vehicle {
public:
    Vehicle() { cout << "This is a Vehicle\n"; }
};

// second base class
class FourWheeler {
public:
    FourWheeler() { cout << "This is a 4 Wheeler\n"; }
};

// sub class derived from two base classes
class Car : public Vehicle, public FourWheeler {
  public:
    Car() { cout << "This 4 Wheeler Vehical is a Car\n"; }
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base classes.
    Car obj;
    return 0;
}

Output
This is a Vehicle
This is a 4 Wheeler
This 4 Wheeler Vehical is a Car

3. Multilevel Inheritance
In this type of inheritance, a derived class is created from another derived class and that derived class can be 
derived from a base class or any other derived class. There can be any number of levels.

// C++ program to implement Multilevel Inheritance
#include <iostream>
using namespace std;

// base class
class Vehicle {
public:
    Vehicle() { cout << "This is a Vehicle\n"; }
};

// first sub_class derived from class vehicle
class fourWheeler : public Vehicle {
public:
    fourWheeler() { cout << "4 Wheeler Vehicles\n"; }
};

// sub class derived from the derived base class fourWheeler
class Car : public fourWheeler {
public:
    Car() { cout << "This 4 Wheeler Vehical is a Car\n"; }
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base classes.
    Car obj;
    return 0;
}

Output
This is a Vehicle
4 Wheeler Vehicles
This 4 Wheeler Vehical is a Car

4. Hierarchical Inheritance
In this type of inheritance, more than one subclass is inherited from a single base class. i.e. more than one derived 
class is created from a single base class.

// C++ program to implement Hierarchical Inheritance
#include <iostream>
using namespace std;

// base class
class Vehicle {
public:
    Vehicle() { cout << "This is a Vehicle\n"; }
};

// first sub class
class Car : public Vehicle {
public:
    Car() { cout << "This Vehicle is Car\n"; }
};

// second sub class
class Bus : public Vehicle {
public:
    Bus() { cout << "This Vehicle is Bus\n"; }
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base class.
    Car obj1;
    Bus obj2;
    return 0;
}

Output
This is a Vehicle
This Vehicle is Car
This is a Vehicle
This Vehicle is Bus

5. Hybrid Inheritance
Hybrid Inheritance is implemented by combining more than one type of inheritance. For example: Combining Hierarchical 
inheritance and Multiple Inheritance will create hybrid inheritance in C++

// C++ program to illustrate the implementation of Hybrid Inheritance
#include <iostream>
using namespace std;

// base class
class Vehicle {
public:
    Vehicle() { cout << "This is a Vehicle\n"; }
};

// base class
class Fare {
public:
    Fare() { cout << "Fare of Vehicle\n"; }
};

// first sub class
class Car : public Vehicle {
  public:
  Car() { cout << "This Vehical is a Car\n"; }
};

// second sub class
class Bus : public Vehicle, public Fare {
  public:
  Bus() { cout << "This Vehicle is a Bus with Fare\n"; }
};

// main function
int main()
{
    // Creating object of sub class will
    // invoke the constructor of base class.
    Bus obj2;
    return 0;
}

Output
This is a Vehicle
Fare of Vehicle
This Vehicle is a Bus with Fare

o Objective: Learn the concept of inheritance.

// C++ program to demonstrate inheritance

#include <iostream>
using namespace std;

// base class
class Animal {

   public:
    void eat() {
        cout << "I can eat!" << endl;
    }

    void sleep() {
        cout << "I can sleep!" << endl;
    }
};

// derived class
class Dog : public Animal {
 
   public:
    void bark() {
        cout << "I can bark! Woof woof!!" << endl;
    }
};

int main() {
    // Create object of the Dog class
    Dog dog1;

    // Calling members of the base class
    dog1.eat();
    dog1.sleep();

    // Calling member of the derived class
    dog1.bark();

    return 0;
}

Output

I can eat!
I can sleep!
I can bark! Woof woof!!

THEORY EXERCISE:
1. Explain the key concepts of Object-Oriented Programming (OOP).

Object-oriented programming – As the name suggests uses objects in programming. Object-oriented programming aims to 
implement real-world entities like inheritance, hiding, polymorphism, etc. in programming. The main aim of OOP is to 
bind together the data and the functions that operate on them so that no other part of the code can access this data 
except that function.

There are some basic concepts that act as the building blocks of OOPs i.e.

Class
Object
Encapsulation
Abstraction
Polymorphism
Inheritance
Dynamic Binding
Message Passing

Class
The building block of C++ that leads to Object-Oriented programming is a Class. It is a user-defined data type, 
which holds its own data members and member functions, which can be accessed and used by creating an instance of that 
class. A class is like a blueprint for an object. For Example: Consider the Class of Cars. There may be many cars 
with different names and brands but all of them will share some common properties like all of them will have 4 wheels, 
Speed Limit, Mileage range, etc. So here, the Car is the class, and wheels, speed limits, and mileage are their properties.

A Class is a user-defined data type that has data members and member functions.
Data members are the data variables and member functions are the functions used to manipulate these variables together 
these data members and member functions define the properties and behavior of the objects in a Class.
In the above example of class Car, the data member will be speed limit, mileage, etc and member functions can apply brakes, 
increase speed, etc.

Object
An Object is an identifiable entity with some characteristics and behavior. An Object is an instance of a Class. 
When a class is defined, no memory is allocated but when it is instantiated (i.e. an object is created) memory is 
allocated.

// C++ Program to show the syntax/working of Objects as a
// part of Object Oriented PProgramming
#include <iostream>
using namespace std;

class person {
    char name[20];
    int id;

public:
    void getdetails() {}
};

int main()
{

    person p1; // p1 is a object
    return 0;
}

Encapsulation
In normal terms, Encapsulation is defined as wrapping up data and information under a single unit. In Object-Oriented 
Programming, Encapsulation is defined as binding together the data and the functions that manipulate them. Consider a 
real-life example of encapsulation, in a company, there are different sections like the accounts section, finance 
section, sales section, etc. The finance section handles all the financial transactions and keeps records of all the 
data related to finance. Similarly, the sales section handles all the sales-related activities and keeps records of all 
the sales. Now there may arise a situation when for some reason an official from the finance section needs all the 
data about sales in a particular month. In this case, he is not allowed to directly access the data of the sales section. 
He will first have to contact some other officer in the sales section and then request him to give the particular data. 
This is what encapsulation is. Here the data of the sales section and the employees that can manipulate them are wrapped 
under a single name “sales section”.

Abstraction
Data abstraction is one of the most essential and important features of object-oriented programming in C++. Abstraction 
means displaying only essential information and hiding the details. Data abstraction refers to providing only essential 
information about the data to the outside world, hiding the background details or implementation. Consider a real-life 
example of a man driving a car. The man only knows that pressing the accelerator will increase the speed of the car or 
applying brakes will stop the car but he does not know how on pressing the accelerator the speed is actually increasing, 
he does not know about the inner mechanism of the car or the implementation of an accelerator, brakes, etc. in the car.

Abstraction using Classes: We can implement Abstraction in C++ using classes. The class helps us to group data members 
and member functions using available access specifiers. A Class can decide which data member will be visible to the 
outside world and which is not.
Abstraction in Header files: One more type of abstraction in C++ can be header files. For example, consider the pow() 
method present in math.h header file. Whenever we need to calculate the power of a number, we simply call the function 
pow() present in the math.h header file and pass the numbers as arguments without knowing the underlying algorithm 
according to which the function is actually calculating the power of numbers.

Polymorphism
The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message 
to be displayed in more than one form. A person at the same time can have different characteristics. A man at the same 
time is a father, a husband, and an employee. So the same person possesses different behavior in different situations. 
This is called polymorphism. An operation may exhibit different behaviors in different instances. The behavior depends 
upon the types of data used in the operation. C++ supports operator overloading and function overloading.

Operator Overloading: The process of making an operator exhibit different behaviors in different instances is known as 
operator overloading.
Function Overloading: Function overloading is using a single function name to perform different types of tasks. 
Polymorphism is extensively used in implementing inheritance.

Inheritance
The capability of a class to derive properties and characteristics from another class is called Inheritance. 
Inheritance is one of the most important features of Object-Oriented Programming.

Sub Class: The class that inherits properties from another class is called Sub class or Derived Class.
Super Class: The class whose properties are inherited by a sub-class is called Base Class or Superclass.
Reusability: Inheritance supports the concept of “reusability”, i.e. when we want to create a new class and there is 
already a class that includes some of the code that we want, we can derive our new class from the existing class. 
By doing this, we are reusing the fields and methods of the existing class.

Dynamic Binding
In dynamic binding, the code to be executed in response to the function call is decided at runtime. C++ has virtual 
functions to support this. Because dynamic binding is flexible, it avoids the drawbacks of static binding, which 
connected the function call and definition at build time.

// C++ Program to Demonstrate the Concept of Dynamic Binding without virtual function
#include <iostream>
using namespace std;

class GFG {
public:
    void call_Function() // function that calls print
    {
        print();
    }
    void print() // the display function
    {
        cout << "Printing the Base class Content" << endl;
    }
};

class GFG2 : public GFG // GFG2 inherits publicly from GFG
{
public:
    void print() // GFG2's display
    {
        cout << "Printing the Derived class Content" << endl;
    }
};

int main()
{
    GFG* language = new GFG(); // Creating GFG's object using pointer
    language->call_Function(); // Calling call_Function

    GFG* language2 = new GFG2(); // creating GFG2 object using pointer
    language2->call_Function(); // calling call_Function for GFG2 object

    delete language;
    delete language2;

    return 0;
}

Output
Printing the Base class Content
Printing the Base class Content

Message Passing
Objects communicate with one another by sending and receiving information. A message for an object is a request for the 
execution of a procedure and therefore will invoke a function in the receiving object that generates the desired results. 
Message passing involves specifying the name of the object, the name of the function, and the information to be sent.

#include <iostream>
using namespace std;

// Define a Car class with a method to display its speed
class Car {
public:
    void displaySpeed(int speed) {
        cout << "The car is moving at " << speed << " km/h." << endl;
    }
};

int main() {
    // Create a Car object named myCar
    Car myCar;

    // Send a message to myCar to execute the displaySpeed method
    int currentSpeed = 100;
    myCar.displaySpeed(currentSpeed);

    return 0;
}

//this code is contributed by Md Nizamuddin

Advantage of OOPs over Procedure-oriented programming language
Here are key advantages of Object-Oriented Programming (OOP) over Procedure-Oriented Programming (POP):

Modularity and Reusability: OOP promotes modularity through classes and objects, allowing for code reusability.
Data Encapsulation: OOP encapsulates data within objects, enhancing data security and integrity.
Inheritance: OOP supports inheritance, reducing redundancy by reusing existing code.
Polymorphism: OOP allows polymorphism, enabling flexible and dynamic code through method overriding.
Abstraction: OOP enables abstraction, hiding complex details and exposing only essential features

2. What are classes and objects in C++? Provide an example

What is a Class in C++?
A class is a user-defined data type, which holds its own data members and member functions, which can be accessed and 
used by creating an instance of that class.

A Class is a user-defined data type that has data members and member functions.
Data members are the data variables and member functions are the functions used to manipulate these variables together, 
these data members and member functions define the properties and behaviour of the objects in a Class.
In the above example of class Car, the data member will be speed limit, mileage, etc, and member functions can be 
applying brakes, increasing speed, etc.

Defining Class in C++
A class is defined in C++ using the keyword class followed by the name of the class. The following is the syntax:

class ClassName {
     access_specifier:
     // Body of the class
};

Example

class ThisClass {
     public:
     int var;     // data member
     void print() {           // member method
          cout << "Hello";
      }
};

What is an Object in C++?
When a class is defined, only the specification for the object is defined; no memory or storage is allocated. To use 
the data and access functions defined in the class, you need to create objects.

Syntax to Create an Object
We can create an object of the given class in the same way we declare the variables of any other inbuilt data type.

ClassName ObjectName;
Example

MyClass obj;

Example of Class and Object in C++

// C++ program to illustrate how create a simple class and
// object
#include <iostream>
#include <string>

using namespace std;

// Define a class named 'Person'
class Person {
public:
    // Data members
    string name;
    int age;

    // Member function to introduce the person
    void introduce()
    {
        cout << "Hi, my name is " << name << " and I am "
             << age << " years old." << endl;
    }
};

int main()
{
    // Create an object of the Person class
    Person person1;

    // accessing data members
    person1.name = "Alice";
    person1.age = 30;

    // Call the introduce member method
    person1.introduce();

    return 0;
}

Output
Hi, my name is Alice and I am 30 years old.

3. What is inheritance in C++? Explain with an example

The capability of a class to derive properties and characteristics from another class is called Inheritance. Inheritance 
is one of the most important features of Object Oriented Programming in C++. In this article, we will learn about 
inheritance in C++, its modes and types along with the information about how it affects different properties of the class.

Syntax of Inheritance in C++
class  derived_class_name : access-specifier  base_class_name
{
       //    body ....
};

class: keyword to create a new class
derived_class_name: name of the new class, which will inherit the base class
access-specifier: Specifies the access mode which can be either of private, public or protected. If neither is specified, 
private is taken as default.
base-class-name: name of the base class.

Example:

class ABC : private XYZ {...}             //  private derivation
class ABC : public XYZ {...}              //  public derivation
class ABC : protected XYZ {...}       //  protected derivation
class ABC: XYZ {...}                          //  private derivation by default

// C++ program to demonstrate how to inherit a class
#include <iostream>
using namespace std;

// Base class that is to be inherited
class Parent {
public:
    // base class members
    int id_p;
    void printID_p()
    {
        cout << "Base ID: " << id_p << endl;
    }
};

// Sub class or derived publicly inheriting from Base
// Class(Parent)
class Child : public Parent {
public:
    // derived class members
    int id_c;
    void printID_c()
    {
        cout << "Child ID: " << id_c << endl;
    }
};

// main function
int main()
{
    // creating a child class object
    Child obj1;

    // An object of class child has all data members
    // and member functions of class parent
    // so we try accessing the parents method and data from
    // the child class object.
    obj1.id_p = 7;
    obj1.printID_p();

    // finally accessing the child class methods and data
    // too
    obj1.id_c = 91;
    obj1.printID_c();

    return 0;
}

Output
Base ID: 7
Child ID: 91

Modes of Inheritance in C++
Mode of inheritance controls the access level of the inherited members of the base class in the derived class. In C++, 
there are 3 modes of inheritance:

Public Mode
Protected Mode
Private Mode

Types Of Inheritance in C++
The inheritance can be classified on the basis of the relationship between the derived class and the base class. 
In C++, we have 5 types of inheritances:

Single inheritance
Multilevel inheritance
Multiple inheritance
Hierarchical inheritance
Hybrid inheritance

4. What is encapsulation in C++? How is it achieved in classes?

Encapsulation in C++ is defined as the wrapping up of data and information in a single unit. In Object Oriented 
Programming, Encapsulation is defined as binding together the data and the functions that manipulate them.

The finance section handles all the financial transactions and keeps records of all the data related to finance.
Similarly, the sales section handles all the sales-related activities and keeps records of all the sales.

This is what Encapsulation is. Here the data of the sales section and the employees that can manipulate them are wrapped 
under a single name “sales section”. 

Two Important  property of Encapsulation 

Data Protection: Encapsulation protects the internal state of an object by keeping its data members private. Access to 
and modification of these data members is restricted to the class’s public methods, ensuring controlled and secure data 
manipulation.
Information Hiding: Encapsulation hides the internal implementation details of a class from external code. Only the 
public interface of the class is accessible, providing abstraction and simplifying the usage of the class while allowing 
the internal implementation to be modified without impacting external code.

#include <iostream>
using namespace std;
class temp{
     int a;
  int b;
  public:
  int solve(int input){
    a=input;
    b=a/2;
    return b;
  }
};

int main() {
  int n;
  cin>>n;
  temp half;
  int ans=half.solve(n);
  cout<<ans<<endl;
   
}

Features of Encapsulation
Below are the features of encapsulation:

We can not access any function from the class directly. We need an object to access that function that is using the member 
variables of that class. 
The function which we are making inside the class must use only member variables, only then it is called encapsulation.
If we don’t make a function inside the class which is using the member variable of the class then we don’t call it 
encapsulation.
Encapsulation improves readability, maintainability, and security by grouping data and methods together.
It helps to control the modification of our data members.

#include <iostream>
#include <string>

using namespace std;

class Person {
  private:
    string name;
    int age;
  public:
    Person(string name, int age) {
      this->name = name;
      this->age = age;
    }
    void setName(string name) {
      this->name = name;
    }
    string getName() {
      return name;
    }
    void setAge(int age) {
      this->age = age;
    }
    int getAge() {
      return age;
    }
};

int main() {
  Person person("John Doe", 30);

  cout << "Name: " << person.getName() << endl;
  cout << "Age: " << person.getAge() << endl;

  person.setName("Jane Doe");
  person.setAge(32);

  cout << "Name: " << person.getName() << endl;
  cout << "Age: " << person.getAge() << endl;

  return 0;
}

Output
Name: John Doe
Age: 30
Name: Jane Doe
Age: 32

Role of Access Specifiers in Encapsulation
Access specifiers facilitate Data Hiding in C++ programs by restricting access to the class member functions and 
data members. There are three types of access specifiers in C++:

Private: Private access specifier means that the member function or data member can only be accessed by other member 
functions of the same class.
Protected: A protected access specifier means that the member function or data member can be accessed by other 
member functions of the same class or by derived classes.
Public: Public access specifier means that the member function or data member can be accessed by any code.

 