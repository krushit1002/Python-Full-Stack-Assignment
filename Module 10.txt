Module 10) 
Rest Framework
Introduction to APIs
Theory:
 What is an API (Application Programming Interface)?

An API (Application Programming Interface) is a set of rules and protocols that allow one software application to 
interact with another. It defines the methods and data formats that applications can use to request and exchange 
information.

Here are the key points to understand about APIs:

Interface for Communication: APIs enable different software systems or components to communicate with each other, 
often over the internet. For example, a mobile app may use an API to retrieve data from a server.

Request and Response: APIs typically work by sending requests from a client (like a web browser or mobile app) 
to a server. The server processes the request and sends a response back to the client. For instance, when you search 
for something on Google, your browser makes an API request to Google's servers, which then send back the search results.

End Points: APIs usually expose specific endpoints or URLs that define the specific actions you can perform. 
For example, one endpoint might allow you to get weather data, while another might let you post a new message on a 
social media platform.

Data Formats: When sending and receiving data, APIs often use standard formats like JSON (JavaScript Object Notation) or 
XML to structure the information in a way that can be easily understood by both systems.

Authentication and Security: Many APIs require authentication (like API keys, OAuth tokens, etc.) to ensure that only 
authorized users can access specific data or services.

Use Cases: APIs are used in various scenarios, such as integrating third-party services (like payment gateways), 
connecting to databases, automating workflows, or retrieving data from public sources (like weather data, news feeds, or 
social media platforms).

In essence, an API allows software systems to talk to each other in a standardized way, making it easier to integrate, 
share data, and add functionality.

 Types of APIs: REST, SOAP.

APIs (Application Programming Interfaces) are essential for enabling communication between different software systems. 
There are two widely used types of APIs: REST (Representational State Transfer) and SOAP (Simple Object Access Protocol). 
Here’s a comparison of these two types:

1. REST API (Representational State Transfer)
Protocol: REST is an architectural style, not a protocol. It usually works over HTTP/HTTPS.
Message Format: REST can support multiple formats such as JSON, XML, HTML, or Plain Text, with JSON being the most 
popular due to its lightweight nature.
Communication: REST uses standard HTTP methods like:
GET: Retrieve data
POST: Send data
PUT: Update data
DELETE: Remove data
Stateless: Each request from a client to the server must contain all the information necessary to understand and process 
the request. The server doesn't store any client context.
Performance: REST is typically faster and more efficient than SOAP due to its lightweight nature (especially when 
using JSON).
Scalability: REST APIs are generally more scalable and flexible, making them ideal for web services that require high 
scalability.
Use Cases: REST is widely used in modern web applications, mobile applications, and microservices architecture.
Example:

GET /users/123 → Retrieve user data with ID 123.
2. SOAP API (Simple Object Access Protocol)
Protocol: SOAP is a protocol that defines a strict set of rules for messaging and communication.
Message Format: SOAP messages are typically XML-based. This makes SOAP more verbose compared to REST.
Communication: SOAP uses HTTP, SMTP, TCP, or other protocols, but HTTP is most common.
Stateful: SOAP supports operations that may require maintaining state between calls, which means it can be used for 
complex transactions.
Security: SOAP has built-in security features (WS-Security) that support encryption, authentication, and message 
integrity, making it suitable for highly secure applications.
Reliability: SOAP has built-in error handling and can be used in environments that require reliable messaging.
Use Cases: SOAP is typically used in enterprise-level applications, banking services, and other applications requiring 
strong security and transactional reliability.
Example:

A SOAP message might look like this (XML format):
xml
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/"
                  xmlns:web="http://www.example.com/webservice">
   <soapenv:Header/>
   <soapenv:Body>
      <web:GetUserDetails>
         <web:userId>123</web:userId>
      </web:GetUserDetails>
   </soapenv:Body>
</soapenv:Envelope>
Key Differences:
Feature	REST	SOAP
Protocol	Architectural style (uses HTTP)	Strict protocol (XML-based)
Data Format	JSON, XML, HTML, Text	XML only
State	Stateless	Can be stateful
Security	Relies on underlying protocols (e.g., HTTPS)	Built-in security (WS-Security)
Complexity	Simpler, lightweight	More complex, heavier
Performance	Faster, especially with JSON	Slower due to XML overhead
Use Cases	Web apps, mobile apps, microservices	Enterprise apps, banking, payments
When to Use Each:
REST is typically preferred for web and mobile applications where performance, flexibility, and ease of use are key.
SOAP is chosen for enterprise systems that require strict security, high reliability, and transactional support, such as 
in banking or payment systems.

 Why are APIs important in web development?

APIs (Application Programming Interfaces) are crucial in web development for several reasons:

Data Integration: APIs enable web applications to access data and services from other platforms or systems. 
For example, a weather app might use an API to fetch weather data from an external service like OpenWeather.

Functionality Sharing: APIs allow web developers to add features or functionalities without needing to build them from 
scratch. For example, integrating payment gateways (like Stripe or PayPal) or social media sharing (like Facebook or 
Twitter) can be easily done via their APIs.

Separation of Concerns: APIs allow the backend and frontend of a web application to communicate without tightly 
coupling them. This separation makes it easier to scale, update, or modify one part of the application without 
disrupting the other.

Interoperability: APIs allow different software systems, often with different technologies and languages, to work 
together seamlessly. For example, a web app written in JavaScript can interact with a server running Python, as long as 
they communicate through APIs.

Efficiency: APIs help streamline the development process by enabling developers to reuse existing solutions rather than 
reinventing the wheel. This improves development speed and reduces the potential for errors.

Security: APIs can provide controlled access to a system's data or functionality. Through authentication methods like 
OAuth, developers can ensure only authorized users or systems can access certain features or data.

Scalability: APIs enable applications to scale effectively. Instead of maintaining all features within a single system, 
an app can rely on external services or microservices via APIs to distribute the load and scale as needed.

Mobile and Third-Party Integration: APIs allow mobile applications and third-party services to interact with your web app.
For example, a mobile app might connect to a server-side API to fetch or submit data, allowing for a seamless user 
experience across multiple platforms.

Real-time Communication: With the use of technologies like WebSockets or APIs offering real-time data (e.g., chat 
applications, live sports updates), APIs allow for continuous data transfer and a more dynamic user experience.

Overall, APIs are essential in modern web development because they enable flexibility, integration, and efficiency, 
allowing developers to build more powerful, scalable, and feature-rich web applications.

Lab:
 Write a Python program that consumes a simple public API (e.g., a joke API).

Here's a simple Python program that consumes a public joke API and prints a random joke. We'll use the requests library 
to make a GET request to the JokeAPI, which provides random jokes.

Requirements
Make sure you have the requests library installed. If you don't, you can install it by running:

bash
pip install requests
Python Code
python
import requests

def get_joke():
    # Joke API endpoint for random jokes
    url = "https://v2.jokeapi.dev/joke/Any"
    
    # Make a GET request to the API
    response = requests.get(url)
    
    if response.status_code == 200:
        joke_data = response.json()
        
        # Check if the joke is single or two-part (setup and delivery)
        if joke_data['type'] == 'single':
            print("Joke:", joke_data['joke'])
        elif joke_data['type'] == 'twopart':
            print("Setup:", joke_data['setup'])
            print("Delivery:", joke_data['delivery'])
    else:
        print("Failed to retrieve joke. Status code:", response.status_code)

if __name__ == "__main__":
    get_joke()
How It Works:
API URL: We use the https://v2.jokeapi.dev/joke/Any endpoint, which returns a random joke from various categories 
(general, programming, etc.).
HTTP Request: The requests.get(url) sends a GET request to the API to fetch a random joke.
JSON Response: If the request is successful (HTTP status 200), the JSON response is parsed. The program then checks if 
the joke is a "single" joke (just one line) or a "twopart" joke (setup and delivery).
Output: Depending on the joke type, it either prints the single joke or both parts (setup and delivery).
Sample Output
For a single joke:

vbnet
Joke: Why don't skeletons fight each other? They don't have the guts.
For a two-part joke:

vbnet
Setup: Why don't programmers like nature?
Delivery: It has too many bugs.

Practical Example:
1. Write a Python script to fetch a random joke from an API and display it on the console.

Here is a simple Python script that fetches a random joke from an API and displays it on the console:

python
import requests

# API URL for fetching a random joke
url = "https://official-joke-api.appspot.com/random_joke"

# Make a request to the API
response = requests.get(url)

# Check if the request was successful (status code 200)
if response.status_code == 200:
    joke = response.json()
    print("Here's a random joke for you!")
    print(f"Setup: {joke['setup']}")
    print(f"Punchline: {joke['punchline']}")
else:
    print("Sorry, couldn't fetch a joke at the moment.")
Explanation:
requests.get(url): This sends an HTTP GET request to the joke API.
response.json(): This converts the response content (JSON format) into a Python dictionary.
The script prints out the setup and punchline of the joke.
How to run:
Install the requests library (if not already installed) by running:
bash
pip install requests
Run the script in your Python environment, and it will display a random joke in the console.

2. Requirements for Web Development Projects
Theory:
 Understanding project requirements.

Understanding project requirements is a crucial step in the project management process. It involves gathering, analyzing, 
and documenting the specific needs and expectations of stakeholders to ensure the project aligns with desired outcomes. 
Here’s a breakdown of the key steps involved in understanding project requirements:

1. Identify Stakeholders
Who are the key stakeholders? These may include clients, customers, team members, managers, and external partners. 
Understanding their roles and perspectives helps in gathering comprehensive requirements.
2. Define Project Goals
What is the purpose of the project? Clarifying the project’s objectives helps in setting the scope and direction. 
These goals could be related to improving business processes, launching a new product, or meeting specific regulatory 
requirements.
3. Gather Requirements
Techniques for gathering requirements:
Interviews: Speak with stakeholders to gather insights.
Surveys/Questionnaires: Use to collect data from a larger group.
Focus Groups: Involve a select group of stakeholders in discussions.
Workshops: Facilitate collaborative sessions to define requirements.
Observation: Study the work environment to identify challenges and needs.
4. Document the Requirements
Create clear, comprehensive documentation that outlines the requirements. This can include:
Functional requirements: What the system or product should do.
Non-functional requirements: How the system should perform (e.g., speed, security, reliability).
Technical requirements: Specific technologies or platforms to be used.
Business requirements: The goals the business hopes to achieve.
5. Validate and Prioritize Requirements
Validation: Ensure that the requirements accurately reflect the stakeholders' needs.
Prioritization: Rank the requirements in order of importance to make sure critical needs are addressed first.
6. Define Scope
Establish the boundaries of the project by clarifying what is in scope (to be included) and out of scope (not to be 
included). This prevents scope creep during the project.
7. Assess Constraints and Assumptions
Constraints: Identify limitations (e.g., time, budget, resources).
Assumptions: Document assumptions made during the planning stage to help avoid misunderstandings later.
8. Create a Requirements Traceability Matrix (RTM)
This tool helps track and manage requirements throughout the project lifecycle. It ensures that every requirement is met 
and properly addressed.
9. Communicate with Stakeholders
Maintain regular communication with stakeholders to ensure that their expectations remain aligned with project goals and 
to address any changes to the requirements as the project progresses.
By following these steps, you can thoroughly understand the project requirements, laying the foundation for successful 
project execution and delivery.

 Setting up the environment and installing necessary packages.

Setting up an environment and installing necessary packages for a project depends on the specific project and the 
programming language you're using. Below, I'll outline the setup for Python, which is commonly used for various 
applications like data analysis, web development, machine learning, etc.

1. Setting up the environment (Python)
Step 1: Install Python
Download Python: Visit Python's official website to download the latest stable version of Python (ensure you download 
version 3.7 or later).
Install Python: Run the installer and ensure that the "Add Python to PATH" option is selected during installation. 
This allows you to run Python from the terminal/command line.
You can verify your installation by running:

bash
python --version
# or
python3 --version
Step 2: Set up a Virtual Environment
A virtual environment helps isolate dependencies for different projects. Here's how to set it up:

Navigate to your project directory (or create one):

bash
mkdir my_project
cd my_project
Create a virtual environment:

bash
python -m venv venv
Activate the virtual environment:

On Windows:
bash
.\venv\Scripts\activate
On macOS/Linux:
bash
source venv/bin/activate
When activated, your command line prompt will show (venv) at the beginning.

Step 3: Install Necessary Packages
To install the required packages for your project, you can use pip (Python’s package installer).

Install individual packages (for example, numpy, pandas, requests, etc.):

bash
pip install numpy pandas requests
Install packages from a requirements.txt file (if you're working in a team or using pre-defined dependencies):

First, create a requirements.txt file that lists all your project dependencies (e.g., numpy, flask, etc.).
Then, install them with:
bash
pip install -r requirements.txt
Step 4: Freeze the Environment’s Dependencies
Once you have installed the necessary packages, you may want to save the environment configuration to recreate the setup 
in the future. Use the following command to generate a requirements.txt:

bash
pip freeze > requirements.txt
2. Example of a requirements.txt
If you're working on a project that requires certain packages, your requirements.txt might look like this:

makefile
numpy==1.23.4
pandas==1.5.0
requests==2.28.0
flask==2.2.2
This file ensures that you can recreate the same environment on any machine using the pip install -r requirements.txt 
command.

3. Additional Setup (for Jupyter Notebooks, Machine Learning, etc.)
If you're working with Jupyter Notebooks or need specific libraries for data science, machine learning, or web 
development, you can install additional packages.

Install Jupyter Notebook:
bash
pip install notebook
To launch a Jupyter notebook, simply run:

bash
jupyter notebook
Machine Learning Libraries (e.g., scikit-learn, tensorflow, torch):
bash
pip install scikit-learn tensorflow torch
4. Using Docker for Environment Setup
If you want to create a consistent environment across different machines or teams, Docker is an excellent choice.

Create a Dockerfile: This is a configuration file that defines the setup of your environment.
Build Docker Image: Once your Dockerfile is set, you can build the Docker image and run containers with all your 
dependencies installed.
This approach is more advanced but useful for larger teams or complex projects.

Summary of Steps:
Install Python
Create a virtual environment
Install necessary packages using pip
Optionally use requirements.txt to manage dependencies
For specialized tasks (like Jupyter notebooks, machine learning), install the required libraries
Optionally, use Docker for a reproducible environment across different machines

Lab:
 Write a requirements.txt file for a Django project that includes all necessary dependencies.

To create a requirements.txt file for a Django project, you need to include the necessary dependencies for a typical 
Django setup. The contents of the file depend on the specific libraries and versions you are using, but here's a basic 
example:

txt
Django>=4.0,<5.0
djangorestframework>=3.14.0
psycopg2>=2.9,<3.0  # if you're using PostgreSQL
mysqlclient>=2.1.0  # if you're using MySQL
Pillow>=8.0.0  # for image handling
gunicorn>=20.1.0  # for running your application in production
celery>=5.2.3  # if using Celery for background tasks
redis>=4.0.0  # if using Redis as a broker for Celery
python-dotenv>=0.21.0  # for loading environment variables from a .env file
django-environ>=0.8.1  # alternative for environment variables management
pytest-django>=4.5.0  # for running Django tests with pytest
Breakdown of common dependencies:
Django: The core framework. You can specify a version range based on what you want, e.g., >=4.0,<5.0 for Django 4.x.
djangorestframework: If you're building APIs with Django Rest Framework (DRF).
psycopg2 or mysqlclient: For PostgreSQL or MySQL database support.
Pillow: A powerful library for working with images, often required in Django applications that handle image uploads.
gunicorn: A WSGI HTTP server for serving Django in production.
celery and redis: If you're working with background tasks (e.g., with Celery) and Redis as the message broker.
python-dotenv or django-environ: Tools for managing environment variables.
pytest-django: For running tests using the pytest framework.
To generate a requirements.txt for your current Django project:
Install all the necessary packages with pip.
Run the following command in the terminal to freeze the installed dependencies:
bash
pip freeze > requirements.txt
This will create a requirements.txt file with the exact versions of packages installed in your environment.

Example of what the requirements.txt might look like after using pip freeze:
txt
Django==4.2.5
djangorestframework==3.14.0
psycopg2==2.9.6
Pillow==9.2.0
gunicorn==20.1.0
celery==5.2.3
redis==4.3.4
python-dotenv==0.21.0
pytest-django==4.5.0
This will ensure that other developers or deployment environments can recreate the same environment using pip install -r 
requirements.txt.

Practical Example: 2) Write a Python script to set up a Django project and install packages like django, 
djangorestframework, requests, etc.

To set up a Django project and install the necessary packages (such as django, djangorestframework, requests, and others), follow the steps below. The Python script provided will automate most of the steps, such as creating a virtual environment, installing dependencies, and setting up the Django project.

Python Script to Set Up Django Project
python
import os
import subprocess
import sys

def create_virtualenv(env_name="myenv"):
    """Create a virtual environment."""
    print(f"Creating virtual environment: {env_name}")
    subprocess.check_call([sys.executable, "-m", "venv", env_name])

def install_packages(env_name="myenv"):
    """Install required packages using pip."""
    print("Installing packages...")
    requirements = [
        'django',
        'djangorestframework',
        'requests',
        # Add other packages as required
    ]
    # Activate the virtual environment and install packages
    pip_path = os.path.join(env_name, 'bin', 'pip') if os.name != 'nt' else os.path.join(env_name, 'Scripts', 'pip')
    subprocess.check_call([pip_path, 'install'] + requirements)

def start_django_project(project_name="myproject"):
    """Create a new Django project."""
    print(f"Creating Django project: {project_name}")
    subprocess.check_call([os.path.join("myenv", "bin", "django-admin") if os.name != 'nt' else os.path.join
("myenv", "Scripts", "django-admin"), "startproject", project_name])

def main():
    project_name = "myproject"
    env_name = "myenv"

    # Step 1: Create virtual environment
    create_virtualenv(env_name)

    # Step 2: Install required packages
    install_packages(env_name)

    # Step 3: Start Django project
    start_django_project(project_name)

    print(f"Project {project_name} created and packages installed successfully!")

if __name__ == "__main__":
    main()
Explanation of the Script
create_virtualenv(env_name="myenv"):

Creates a virtual environment named myenv (you can change the name by passing a different string as env_name).
install_packages(env_name="myenv"):

Installs the required packages (django, djangorestframework, requests, etc.) using pip within the created virtual 
environment.
It checks the platform (Windows or Unix-based) to determine the correct path for the pip executable.
start_django_project(project_name="myproject"):

Uses the django-admin command to start a new Django project with the name myproject. You can change the project name by 
passing a different string.
main():

This is the main function where the virtual environment is created, dependencies are installed, and the Django project is 
set up.
By default, it creates a virtual environment named myenv and a Django project named myproject.
How to Run the Script
Save the script as setup_django_project.py.
Open your terminal or command prompt.
Navigate to the directory where setup_django_project.py is located.
Run the script:
bash
python setup_django_project.py
The script will:
Create a virtual environment.
Install the required packages (django, djangorestframework, requests).
Create a Django project with the name myproject.
After running the script, you should have a new Django project with the specified packages installed in the myenv virtual 
environment.

3. Serialization in Django REST Framework
Theory:
 What is Serialization?

Serialization is the process of converting an object, data structure, or state into a format that can be easily stored, 
transmitted, or reconstructed later. This format could be a byte stream, text, or any other format that can be 
efficiently stored in a file, sent over a network, or saved in a database.

Key Points about Serialization:
Object to Data Format: Serialization involves transforming an object (which could be a complex data structure) into a 
linear format. This makes it possible to save the object to a file or transmit it over a network.

Deserialization: The reverse process of serialization is called deserialization. It involves taking the serialized data 
and reconstructing the original object or data structure.

Use Cases:

Storing Data: Serialization is commonly used to save the state of an object to a file so it can be restored later.
Data Transmission: When sending data over a network, objects need to be serialized into a standard format 
(like JSON, XML, or binary) for efficient transmission.
Persistence: In databases, serialized objects are often used to store complex data.
Formats: Common serialization formats include:

JSON: Human-readable, commonly used for web APIs.
XML: Markup language used in data exchange, though less common now.
Binary Serialization: For compact storage, used in situations where performance is crucial.
Protocol Buffers, Avro, and Thrift: Compact binary serialization formats used in large-scale systems.
Example in Programming:
In many programming languages, like Python, Java, and C#, serialization allows an object to be converted into a byte 
stream or string that can be saved to a file or sent over a network.

Python Example:
python
import pickle

# Serialize object
data = {"name": "Alice", "age": 30}
serialized_data = pickle.dumps(data)

# Deserialize object
deserialized_data = pickle.loads(serialized_data)
print(deserialized_data)
Importance:
Interoperability: Serialization allows different systems or platforms (e.g., a Python server and a Java client) to 
communicate by sharing data in a common serialized format.
Persistence: It makes it possible to save the state of an application for later use or to persist data beyond the 
lifetime of an application.
In summary, serialization is a fundamental concept in computer science, especially in data storage, transmission, and 
systems integration.

 Converting Django QuerySets to JSON.

To convert Django QuerySets to JSON, Django provides built-in tools to serialize the data. You can use 
django.core.serializers or Django REST Framework (DRF) to convert QuerySets into JSON format. Here’s how you can do it 
using both methods.

1. Using django.core.serializers
Django provides a simple serialization mechanism in the django.core.serializers module. To convert a QuerySet to JSON, 
you can use the serialize function.

Example:
python
from django.core import serializers
from myapp.models import MyModel

# Get a QuerySet
queryset = MyModel.objects.all()

# Serialize the queryset to JSON
json_data = serializers.serialize('json', queryset)

# The result is a JSON string representing the queryset
print(json_data)
This will generate a JSON string that includes information about the model fields, model names, and the data.

Example Output:
json
[
    {
        "model": "myapp.mymodel",
        "pk": 1,
        "fields": {
            "field1": "value1",
            "field2": "value2"
        }
    },
    {
        "model": "myapp.mymodel",
        "pk": 2,
        "fields": {
            "field1": "value3",
            "field2": "value4"
        }
    }
]
2. Using Django Rest Framework (DRF)
Django Rest Framework provides a more robust way to serialize data, especially if you need more control over the 
output or plan to work with APIs. You can use DRF's serializers to convert QuerySets to JSON.

Example:
Create a Serializer: First, define a serializer for your model.
python
from rest_framework import serializers
from myapp.models import MyModel

class MyModelSerializer(serializers.ModelSerializer):
    class Meta:
        model = MyModel
        fields = '__all__'  # Or specify the fields you want
Use the Serializer to Convert the QuerySet to JSON: After defining the serializer, you can use it to convert a QuerySet 
into JSON.
python
from rest_framework.renderers import JSONRenderer
from myapp.models import MyModel
from myapp.serializers import MyModelSerializer

# Get the QuerySet
queryset = MyModel.objects.all()

# Serialize the queryset
serializer = MyModelSerializer(queryset, many=True)

# Convert to JSON format
json_data = JSONRenderer().render(serializer.data)

# Print JSON data
print(json_data)
Example Output:
json
[
    {
        "id": 1,
        "field1": "value1",
        "field2": "value2"
    },
    {
        "id": 2,
        "field1": "value3",
        "field2": "value4"
    }
]
3. Using Django's JsonResponse
If you want to return the QuerySet as a JSON response in a Django view, you can use JsonResponse, which automatically 
converts data into JSON format.

python
from django.http import JsonResponse
from myapp.models import MyModel

def my_view(request):
    queryset = MyModel.objects.all()
    data = list(queryset.values())  # Converts QuerySet to a list of dicts
    return JsonResponse(data, safe=False)  # 'safe=False' is required when returning a list

 Using serializers in Django REST Framework (DRF).

In Django REST Framework (DRF), serializers are used to convert complex data types such as Django model instances or 
querysets into native Python data types like dictionaries, lists, and then render them as JSON, XML, or other content 
types. This also allows you to convert JSON or other formats back into complex data types, so that they can be processed 
and saved to the database.

Key Features of Serializers in DRF:
Serialization: Convert Django models or querysets into JSON or other formats.
Deserialization: Convert incoming data (e.g., JSON from a client) back into Python data structures that can be validated 
and saved into the database.
Validation: Ensure that data meets certain criteria before saving it to the database.
Types of Serializers in DRF:
Serializer: A basic serializer used for simple data validation and conversion.
ModelSerializer: A subclass of Serializer that automatically generates fields based on Django models.
Using Serializers in DRF:
1. Creating a Basic Serializer
A basic serializer in DRF is just a class that inherits from serializers.Serializer and defines fields.

python
from rest_framework import serializers

class BookSerializer(serializers.Serializer):
    title = serializers.CharField(max_length=100)
    author = serializers.CharField(max_length=100)
    published_date = serializers.DateField()
    isbn = serializers.CharField(max_length=13)
This serializer class defines four fields: title, author, published_date, and isbn.

CharField is used for string-based fields.
DateField is used for dates.
IntegerField, BooleanField, EmailField, and other field types can also be used depending on your data.
2. Creating a ModelSerializer
The ModelSerializer automatically generates fields based on the model fields, making it a more powerful and less manual 
way to create serializers for Django models.

Consider the following model:

python
from django.db import models

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=100)
    published_date = models.DateField()
    isbn = models.CharField(max_length=13)
Now, we can create a serializer for the Book model using ModelSerializer:

python
from rest_framework import serializers
from .models import Book

class BookModelSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = ['title', 'author', 'published_date', 'isbn']
Meta Class: The Meta class inside the serializer specifies which model to use and which fields to include.
3. Using Serializers for Serialization (Converting Querysets to JSON)
Serializers are often used in views to serialize data and send it as a response.

Example in a DRF view:

python
from rest_framework.response import Response
from rest_framework.decorators import api_view
from .models import Book
from .serializers import BookModelSerializer

@api_view(['GET'])
def book_list(request):
    books = Book.objects.all()  # Retrieve all books
    serializer = BookModelSerializer(books, many=True)  # many=True to handle multiple objects
    return Response(serializer.data)  # Return serialized data as JSON
many=True is required when you are serializing multiple objects, like a queryset.
The Response object is used to return a JSON response.
4. Using Serializers for Deserialization (Validating and Saving Data)
When accepting data from the client (e.g., via POST), you use deserialization to validate and save it to the database.

Example of deserialization in a view:

python
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status
from .serializers import BookModelSerializer

@api_view(['POST'])
def add_book(request):
    serializer = BookModelSerializer(data=request.data)
    if serializer.is_valid():  # Check if the data is valid
        serializer.save()  # Save the data to the database
        return Response(serializer.data, status=status.HTTP_201_CREATED)
    return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
request.data contains the incoming data (usually JSON).
serializer.is_valid() checks if the data is valid based on the serializer's field definitions and validation rules.
If valid, serializer.save() saves the instance to the database.
5. Custom Validation in Serializers
You can define custom validation logic within a serializer by overriding the validate method or creating custom 
field-level validation methods.

Example of custom validation for isbn:

python
class BookModelSerializer(serializers.ModelSerializer):
    class Meta:
        model = Book
        fields = ['title', 'author', 'published_date', 'isbn']

    def validate_isbn(self, value):
        if len(value) != 13:
            raise serializers.ValidationError("ISBN must be 13 characters long.")
        return value
The validate_<field_name> method is called for field-specific validation.
6. Nested Serializers
In DRF, you can create nested serializers to represent relationships between models (e.g., ForeignKey, OneToOne).

Example with a Publisher model related to Book via a ForeignKey:

python
class Publisher(models.Model):
    name = models.CharField(max_length=100)

class Book(models.Model):
    title = models.CharField(max_length=100)
    author = models.CharField(max_length=100)
    publisher = models.ForeignKey(Publisher, on_delete=models.CASCADE)
Now, you can create a nested serializer for the Publisher model:

python
class PublisherSerializer(serializers.ModelSerializer):
    class Meta:
        model = Publisher
        fields = ['name']

class BookModelSerializer(serializers.ModelSerializer):
    publisher = PublisherSerializer()  # Nested serializer

    class Meta:
        model = Book
        fields = ['title', 'author', 'publisher']
This will serialize the publisher field in the Book serializer as a nested JSON object.

7. Serializer Fields Options
Here are a few commonly used options for serializer fields:

read_only: If set to True, this field is not writable and will be excluded from deserialization.

python
title = serializers.CharField(read_only=True)
write_only: If set to True, the field is excluded from serialization (response) but can still be used for deserialization 
(request).

python
password = serializers.CharField(write_only=True)
required: You can make a field required or optional.

python
title = serializers.CharField(required=True)
Conclusion
Serializers in Django REST Framework are essential for converting data between Python objects and JSON (or other formats). 
By using serializers, you ensure proper validation, transformation, and deserialization of data to and from your models. 
The ModelSerializer is a powerful and convenient tool for working with Django models, while the basic Serializer class 
allows you to handle custom data structures.

Lab:
 Create a Django REST API with serialization for a Doctor model.

To create a Django REST API with serialization for a Doctor model, follow these steps:

Step 1: Set up a Django Project
Install Django and Django REST Framework (DRF):

If you haven't already set up a Django project, first install Django and DRF:

bash
pip install django
pip install djangorestframework
Create a Django Project:

Create a new Django project:

bash
django-admin startproject doctor_api
cd doctor_api
Create a Django App:

Create a new Django app where you'll define the Doctor model:

bash
python manage.py startapp doctors
Add rest_framework and the doctors app to INSTALLED_APPS:

Open doctor_api/settings.py and add 'rest_framework' and 'doctors' to INSTALLED_APPS:

python
INSTALLED_APPS = [
    # Other apps...
    'rest_framework',
    'doctors',
]
Step 2: Create the Doctor Model
Define the Doctor model in doctors/models.py:

Here's an example model for Doctor:

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15, blank=True, null=True)
    email = models.EmailField(unique=True)
    date_of_birth = models.DateField()
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    def __str__(self):
        return f"{self.first_name} {self.last_name} ({self.specialty})"
Migrate the database:

Run the following commands to create the table in the database:

bash
python manage.py makemigrations
python manage.py migrate
Step 3: Create the Serializer for the Doctor Model
Create a serializers.py file in the doctors app directory:

In doctors/serializers.py, create a serializer for the Doctor model:

python
from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = ['id', 'first_name', 'last_name', 'specialty', 'phone_number', 'email', 'date_of_birth', 'created_at', 'updated_at']
Step 4: Create the Views for the API
Create views in doctors/views.py:

We can use Django REST Framework's generic views or viewsets. Here's an example using a ModelViewSet:

python
from rest_framework import viewsets
from .models import Doctor
from .serializers import DoctorSerializer

class DoctorViewSet(viewsets.ModelViewSet):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
Step 5: Define the URL Routing
Set up URL routing in doctors/urls.py:

In doctors/urls.py, define the URL patterns for the API:

python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DoctorViewSet

router = DefaultRouter()
router.register(r'doctors', DoctorViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
Include the doctors app URLs in the main urls.py:

Open doctor_api/urls.py and include the app’s URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('doctors.urls')),  # Include the doctor's API urls
]
Step 6: Run the Development Server
Create a superuser to access the Django admin interface (optional but useful for adding data to the database):

bash
python manage.py createsuperuser
Run the server:

Start the Django development server:

bash
python manage.py runserver
Access the API:

You can now access the API at http://127.0.0.1:8000/api/doctors/. This should give you a list of doctors or allow you 
to add, update, or delete doctor records.

You can test the API using any API client (like Postman) or a browser (for GET requests).

Step 7: (Optional) Test the API with Django Admin
Access the Django Admin Interface:

Visit http://127.0.0.1:8000/admin/ and log in with the superuser credentials.

Add Doctor Data:

You can add, edit, or delete doctor records through the admin interface.

Practical Example: 3) Write a Django REST API to serialize a Doctor model with fields like name, specialty, and contact 
details.

To create a Django REST API that serializes a Doctor model with fields like name, specialty, and contact_details, 
you'll need to follow these steps:

1. Setup Django Project
If you don't have a Django project yet, create a new Django project and app:

bash
django-admin startproject doctor_project
cd doctor_project
python manage.py startapp doctors
2. Install Django REST Framework
Install Django REST Framework (DRF) to enable API functionality:

bash
pip install djangorestframework
Then, add 'rest_framework' and your app ('doctors') to INSTALLED_APPS in the settings.py file of your project:

python
# doctor_project/settings.py

INSTALLED_APPS = [
    ...
    'rest_framework',
    'doctors',
]
3. Define the Doctor Model
In the models.py file of the doctors app, define the Doctor model:

python
# doctors/models.py
from django.db import models

class Doctor(models.Model):
    name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    contact_details = models.CharField(max_length=200)

    def __str__(self):
        return self.name
4. Create a Serializer
Create a serializer for the Doctor model. This will define how data is converted to and from JSON format.

Create a new file called serializers.py in the doctors app and define the serializer:

python
# doctors/serializers.py
from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = ['id', 'name', 'specialty', 'contact_details']
5. Create Views
Now, create views to handle HTTP requests for the Doctor model. You can use APIView or ViewSets provided by Django 
REST Framework. Here's how to create a simple ListCreateAPIView to handle GET and POST requests:

python
# doctors/views.py
from rest_framework import generics
from .models import Doctor
from .serializers import DoctorSerializer

class DoctorListCreateAPIView(generics.ListCreateAPIView):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
6. Configure URLs
Set up URL routing to link the view to a URL endpoint. In doctors/urls.py, define the URL patterns for the API:

python
# doctors/urls.py
from django.urls import path
from .views import DoctorListCreateAPIView

urlpatterns = [
    path('doctors/', DoctorListCreateAPIView.as_view(), name='doctor-list-create'),
]
Then, include the doctors URLs in the main project’s urls.py:

python
# doctor_project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('doctors.urls')),
]
7. Migrate the Database
Run the migrations to create the Doctor model table in the database:

bash
python manage.py makemigrations doctors
python manage.py migrate
8. Testing the API
Now, you can test your API. You can use the Django shell or a tool like Postman to test it.

GET Request: To fetch the list of doctors:

URL: http://localhost:8000/api/doctors/
Method: GET
POST Request: To create a new doctor:

URL: http://localhost:8000/api/doctors/
Method: POST
Body (JSON):
json
{
  "name": "Dr. John Doe",
  "specialty": "Cardiology",
  "contact_details": "123-456-7890"
}
9. Start the Server
Run the Django development server:

bash
python manage.py runserver
Final Project Structure
Your final project structure should look like this:

markdown
doctor_project/
├── doctors/
│   ├── migrations/
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── models.py
│   ├── serializers.py
│   ├── tests.py
│   └── views.py
├── doctor_project/
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   ├── asgi.py
│   ├── wsgi.py
├── manage.py
This structure ensures that your API is up and running, and you can perform GET and POST operations on the Doctor model.

4. Requests and Responses in Django REST Framework
Theory:
 HTTP request methods (GET, POST, PUT, DELETE).

HTTP request methods are a set of standardized operations used to interact with web servers and APIs. These methods 
determine what kind of action is to be performed on the server. Here are the four most common HTTP request methods:

1. GET
Purpose: Retrieves data from the server.
Usage: Used to request data from a specified resource (like a webpage or an API endpoint).
Characteristics:
Safe: Does not modify any data on the server.
Idempotent: Multiple identical GET requests will produce the same result.
Cacheable: Responses can be cached by browsers or other intermediaries.
Example:
Request: GET /users/123 (This would retrieve information for user 123).
2. POST
Purpose: Submits data to be processed by the server (usually for creating a new resource or performing an action).
Usage: Used when sending data (like form submissions, file uploads, or creating a new resource in a database).
Characteristics:
Not idempotent: Repeated POST requests may have different effects (e.g., creating multiple resources).
Not cacheable: Responses to POST requests are typically not cached.
Example:
Request: POST /users with a payload like {"name": "John", "email": "john@example.com"} (This would create a new user).
3. PUT
Purpose: Updates an existing resource with the provided data.
Usage: Used when you want to replace the resource or update it completely.
Characteristics:
Idempotent: Multiple identical PUT requests will always produce the same result.
Not typically cacheable: PUT responses are often not cached.
Example:
Request: PUT /users/123 with a payload like {"name": "John Doe", "email": "john.doe@example.com"} (This would update 
user 123’s information).
4. DELETE
Purpose: Removes a resource from the server.
Usage: Used to delete a resource identified by a URI.
Characteristics:
Idempotent: Sending the DELETE request multiple times will have the same effect (the resource will be deleted after 
the first request).
Not cacheable: Responses to DELETE requests are generally not cached.
Example:
Request: DELETE /users/123 (This would delete user 123).
Summary Table:
Method	Purpose	Idempotent	Safe	Example Request
GET	Retrieve data from the server	Yes	Yes	GET /users/123
POST	Submit data to create or process a resource	No	No	POST /users with data
PUT	Update an existing resource	Yes	No	PUT /users/123 with updated data
DELETE	Remove a resource	Yes	No	DELETE /users/123
Each HTTP method is designed for a specific type of interaction with a server, whether it's retrieving, submitting, 
updating, or deleting data.

 Sending and receiving responses in DRF.

In Django Rest Framework (DRF), sending and receiving responses are done through views and serializers, making it easy 
to handle API requests and responses. Below is a breakdown of how to handle both sending and receiving responses in DRF.

1. Receiving Requests (Request Handling)
When an API endpoint receives a request, DRF automatically parses the request data based on the HTTP method 
(GET, POST, PUT, DELETE, etc.).

Request data can be received in various formats:
Query parameters for GET requests (request.GET).
JSON or form data for POST or PUT requests (request.data).
Headers for authentication or other meta-information (request.headers).
Example: Receiving Request Data in a DRF View
python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

class SampleView(APIView):
    def get(self, request):
        # Access query parameters
        param = request.GET.get('param', 'default_value')
        return Response({"message": "GET request received", "param": param}, status=status.HTTP_200_OK)

    def post(self, request):
        # Access the data sent in the request body (usually JSON or form data)
        data = request.data
        return Response({"message": "POST request received", "data": data}, status=status.HTTP_201_CREATED)
2. Sending Responses (Response Handling)
To send a response from the view, you use DRF's Response class. This allows you to format the response in JSON and 
return an appropriate HTTP status code.

Response Object: The Response class automatically serializes Python dictionaries to JSON.
Custom Status Codes: DRF allows you to set custom HTTP status codes in the response.
Example: Sending a Response in DRF
python
from rest_framework.response import Response
from rest_framework import status

def some_view(request):
    data = {'message': 'Hello, world!'}
    return Response(data, status=status.HTTP_200_OK)  # Returns a 200 OK response with JSON data
Common Response Codes:
200 OK: Successful request (commonly used for GET and PUT).
201 CREATED: Successfully created resource (typically used for POST requests).
400 BAD REQUEST: Invalid request, often used when validation fails.
401 UNAUTHORIZED: Missing or invalid authentication.
404 NOT FOUND: Resource not found.
500 INTERNAL SERVER ERROR: Server error.
3. Sending Responses with Serializers
In DRF, serializers are used to convert complex data (like Django model instances) into Python data types that can be 
easily rendered into JSON, XML, or other content types. To return serialized data in a response, you need to use 
serializers.

Serializer Example:
python
from rest_framework import serializers

class UserSerializer(serializers.Serializer):
    id = serializers.IntegerField()
    username = serializers.CharField(max_length=100)
    email = serializers.EmailField()
Using Serializer in View:
python
Copy code
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status
from .models import User
from .serializers import UserSerializer

class UserListView(APIView):
    def get(self, request):
        users = User.objects.all()
        serializer = UserSerializer(users, many=True)  # Serializing a queryset
        return Response(serializer.data, status=status.HTTP_200_OK)
In this example:

UserSerializer is used to serialize a queryset of User model instances.
The many=True argument indicates that multiple user objects are being serialized.
4. Customizing Response Headers
You can also add custom headers in the response. For example, adding an authorization token or any other metadata in the 
response headers:

python
from rest_framework.response import Response

def custom_response(request):
    response = Response({"message": "Custom headers example"})
    response['X-Custom-Header'] = 'Custom Value'  # Adding a custom header
    return response
5. Error Handling
You can handle errors and send appropriate responses using the Response object and custom exceptions. DRF provides 
built-in exceptions like NotFound, ValidationError, etc.

Example:

python
from rest_framework.exceptions import NotFound

class SampleView(APIView):
    def get(self, request):
        try:
            data = fetch_data_from_db()  # Simulated data fetch
            if not data:
                raise NotFound("Data not found")
            return Response({"data": data}, status=status.HTTP_200_OK)
        except NotFound as e:
            return Response({"error": str(e)}, status=status.HTTP_404_NOT_FOUND)
Summary
Receiving requests: You can handle GET, POST, PUT, DELETE requests and access data through request.GET, request.data, 
and request.headers.
Sending responses: Use the Response class to return serialized data and status codes.
Serializer: Serialize complex data into a JSON format for easy response handling.
Custom Headers: You can customize headers in the response as needed.

Lab:
 Create a Django REST API that accepts POST requests to add new doctor profiles.

To create a Django REST API that accepts POST requests to add new doctor profiles, you need to follow several steps to 
set up your project, create the model for the doctor profile, create a serializer, and configure the view to accept 
POST requests. Below is a step-by-step guide on how to implement this.

Step 1: Install Django and Django REST Framework
If you haven't already installed Django and Django REST Framework, you can do so by running:

bash
pip install django
pip install djangorestframework
Step 2: Create a New Django Project and Application
Create a new Django project and an app for managing doctor profiles.

bash
django-admin startproject doctor_profiles
cd doctor_profiles
django-admin startapp profiles
Step 3: Update settings.py
In the doctor_profiles/settings.py, add 'rest_framework' and 'profiles' to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    # Default apps
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    
    # Third-party apps
    'rest_framework',  # Add this for Django REST framework

    # Your app
    'profiles',  # Add this for the profiles app
]
Step 4: Create a Model for Doctor Profiles
In the profiles/models.py file, define a model for storing doctor profile information:

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15, blank=True)
    email = models.EmailField(unique=True)
    address = models.TextField(blank=True)

    def __str__(self):
        return f"{self.first_name} {self.last_name} - {self.specialty}"
Step 5: Create a Serializer for the Doctor Model
In the profiles/serializers.py file, define a serializer for the Doctor model to convert the data between JSON and 
Django model instances.

python
from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = ['id', 'first_name', 'last_name', 'specialty', 'phone_number', 'email', 'address']
Step 6: Create a View to Handle POST Requests
In the profiles/views.py file, create a view that handles POST requests to create new doctor profiles.

python
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import Doctor
from .serializers import DoctorSerializer

@api_view(['POST'])
def add_doctor(request):
    if request.method == 'POST':
        serializer = DoctorSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()  # Save the doctor profile to the database
            return Response(serializer.data, status=status.HTTP_201_CREATED)  # Return success response
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)  # Return error if serializer is invalid
Step 7: Define URL Patterns
In the profiles/urls.py file, define the URL routing for your API:

python
from django.urls import path
from .views import add_doctor

urlpatterns = [
    path('add/', add_doctor, name='add_doctor'),
]
Now, include the profiles.urls in your project's urls.py file:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/doctors/', include('profiles.urls')),  # Add this line to include your app's URLs
]
Step 8: Migrate the Database
Since we’ve defined a new model, run the migrations to create the corresponding database table.

bash
python manage.py makemigrations
python manage.py migrate
Step 9: Test the API
Now that everything is set up, you can test the API. Start the Django development server:

bash
python manage.py runserver
You can test the API using a tool like Postman or curl. To create a new doctor profile, send a POST request to 
http://127.0.0.1:8000/api/doctors/add/ with the following JSON data:

json
{
    "first_name": "John",
    "last_name": "Doe",
    "specialty": "Cardiology",
    "phone_number": "1234567890",
    "email": "john.doe@example.com",
    "address": "123 Health St, Medical City"
}
If successful, you should receive a response like this:

json
{
    "id": 1,
    "first_name": "John",
    "last_name": "Doe",
    "specialty": "Cardiology",
    "phone_number": "1234567890",
    "email": "john.doe@example.com",
    "address": "123 Health St, Medical City"
}

Practical Example: 4) Write a Django project where the API accepts a POST request to add a doctor’s details to the 
database.

To create a Django project where the API accepts a POST request to add a doctor's details to the database, follow these 
steps:

Step 1: Set Up Django Project
Install Django if you haven't already:

bash
pip install django
Create a new Django project:

bash
django-admin startproject doctor_project
cd doctor_project
Create a new Django app to handle doctor-related logic:

bash
python manage.py startapp doctors
Add the app to the INSTALLED_APPS in doctor_project/settings.py:

python
INSTALLED_APPS = [
    ...
    'doctors',
    'rest_framework',  # if you are using Django REST Framework for the API
]
Install Django REST Framework (DRF):

bash
pip install djangorestframework
Step 2: Set Up Models
In the doctors app, define the model for a doctor in doctors/models.py:

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=15)
    hospital = models.CharField(max_length=255)

    def __str__(self):
        return f"Dr. {self.first_name} {self.last_name}"
Run migrations to create the database table:

bash
python manage.py makemigrations
python manage.py migrate
Step 3: Create Serializers
Create a serializer for the Doctor model to convert the model instances into JSON format. In doctors/serializers.py, 
add:

python
from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = '__all__'
Step 4: Create Views for the API
In doctors/views.py, create a view to handle the POST request to add a new doctor:

python
Copy code
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import Doctor
from .serializers import DoctorSerializer

@api_view(['POST'])
def add_doctor(request):
    if request.method == 'POST':
        serializer = DoctorSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()  # Save the new doctor to the database
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
Step 5: Set Up URL Routing
In doctors/urls.py, define the URL endpoint for the POST request:

python
from django.urls import path
from . import views

urlpatterns = [
    path('add/', views.add_doctor, name='add_doctor'),
]
In the doctor_project/urls.py, include the doctors app's URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/doctors/', include('doctors.urls')),  # Add this line to include the doctor URLs
]
Step 6: Test the API
Run the development server:

bash
python manage.py runserver
Test the POST API using Postman or curl by sending a POST request to:

ruby
http://127.0.0.1:8000/api/doctors/add/
Example request body (in JSON format):

json
{
    "first_name": "John",
    "last_name": "Doe",
    "specialty": "Cardiology",
    "email": "john.doe@example.com",
    "phone_number": "1234567890",
    "hospital": "City Hospital"
}
The response should be:

json
{
    "id": 1,
    "first_name": "John",
    "last_name": "Doe",
    "specialty": "Cardiology",
    "email": "john.doe@example.com",
    "phone_number": "1234567890",
    "hospital": "City Hospital"
}
Step 7: (Optional) Add Permissions and Authentication
To secure the API, you can add authentication and permissions. For example, to require authentication, modify your 
view in doctors/views.py:

python
from rest_framework.permissions import IsAuthenticated

@api_view(['POST'])
@permission_classes([IsAuthenticated])
def add_doctor(request):
    if request.method == 'POST':
        serializer = DoctorSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()  # Save the new doctor to the database
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

5. Views in Django REST Framework
Theory:
 Understanding views in DRF: Function-based views vs Class-based views.

In Django Rest Framework (DRF), views handle the HTTP requests and return appropriate responses. Two primary ways of 
defining views are Function-Based Views (FBVs) and Class-Based Views (CBVs). Both serve the same purpose, but they 
differ in structure, flexibility, and ease of use. Let's explore the differences between them.

1. Function-Based Views (FBVs)
Function-based views are the traditional way to define views in Django, including DRF. They are simple functions that 
receive HTTP requests and return HTTP responses.

Example of FBV in DRF:
python
from rest_framework.decorators import api_view
from rest_framework.response import Response
from rest_framework import status

@api_view(['GET'])
def my_view(request):
    data = {"message": "Hello, world!"}
    return Response(data, status=status.HTTP_200_OK)
Key Characteristics of FBVs:
Simplicity: FBVs are easy to understand and implement. They consist of a single function that handles HTTP methods.
Explicitness: All logic is contained within the view function, making it clear and straightforward.
Less Boilerplate: Since it’s a single function, there is less structure or overhead to set up.
Manual Handling of HTTP Methods: You have to manually check for the request type (GET, POST, PUT, etc.) and handle each 
case.
Pros:
Easy to write and understand for small applications.
Offers fine control over the logic, which can be more flexible for simpler use cases.
Cons:
As your application grows, FBVs can become harder to maintain because the logic can grow large and unwieldy in a single 
function.
Reusability can be limited as more custom logic needs to be written for different HTTP methods.
2. Class-Based Views (CBVs)
Class-based views are a more structured and object-oriented approach. DRF offers a range of generic class-based views to 
simplify the process of handling various HTTP methods and common operations like list, create, retrieve, update, and 
delete (CRUD).

Example of CBV in DRF:
python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework import status

class MyView(APIView):
    def get(self, request):
        data = {"message": "Hello, world!"}
        return Response(data, status=status.HTTP_200_OK)
Key Characteristics of CBVs:
Structured and Reusable: CBVs are organized into classes, which promote code reuse and can be more maintainable for 
larger applications.
Separation of Concerns: CBVs separate different HTTP methods (GET, POST, etc.) into different methods, making the code 
clearer and more modular.
Extensible: CBVs are highly extensible, allowing you to inherit and override specific behavior. DRF offers many built-in 
generic views and mixins that simplify common operations.
Common DRF Generic Views:
ListAPIView: Handles listing objects.
CreateAPIView: Handles creating new objects.
RetrieveAPIView: Handles retrieving a single object.
UpdateAPIView: Handles updating an existing object.
DestroyAPIView: Handles deleting an object.
ModelViewSet: Combines all CRUD operations into a single class.
Example with Generic Views:
python
from rest_framework.generics import ListAPIView
from myapp.models import MyModel
from myapp.serializers import MyModelSerializer

class MyModelListView(ListAPIView):
    queryset = MyModel.objects.all()
    serializer_class = MyModelSerializer
Pros:
Reusability: CBVs allow you to reuse common view patterns without having to rewrite logic.
Cleaner and More Organized Code: Especially in larger applications, CBVs help in organizing code logically.
DRF Built-in Views: DRF provides several generic views that make it easy to implement common functionality with less code.
Cons:
Learning Curve: The object-oriented approach and abstractions can be harder to understand for beginners.
Less Flexibility: Overriding certain methods might not always be straightforward, especially when dealing with complex 
behavior.
Comparison: FBVs vs. CBVs
Feature	Function-Based Views (FBVs)	Class-Based Views (CBVs)
Structure	Single function that handles HTTP methods.	Object-oriented, with methods for HTTP actions.
Complexity	Simple and direct.	More structured, with higher initial complexity.
Customization	Can be customized easily, but all in one place.	Highly customizable through class inheritance.
Code Reusability	Less reusable across different views.	High reusability, especially with DRF generic views.
Maintainability	Can become hard to maintain as the project grows.	Easier to maintain, especially in large apps.
Best Use Case	Simple views with minimal logic.	Complex views or when common CRUD actions are needed.
When to Use FBVs:
When your views are simple and don’t require much logic.
If you prefer a more explicit and straightforward approach.
In smaller projects or for prototyping.
When to Use CBVs:
For more complex applications with larger codebases.
When you need to reuse or extend the behavior of views.
If you want to take advantage of DRF's generic views to reduce boilerplate.
In practice, you can mix and match FBVs and CBVs depending on the needs of your project. For example, for simple views, 
you might use FBVs, while for more complex views, CBVs might be more suitable.

Lab:
 Implement a class-based view in DRF for managing doctor profiles.

In Django Rest Framework (DRF), class-based views (CBVs) provide a powerful and organized way to manage API endpoints. 
Here's how you can implement a class-based view for managing doctor profiles.

Steps to Implement:
Create a Doctor model: Define a model to store the doctor profiles.
Create a serializer: Create a DRF serializer to transform the doctor model data into JSON and vice versa.
Create the view: Implement a class-based view to handle CRUD operations (Create, Read, Update, Delete).
Define URLs: Set up the URL patterns to map the API endpoints.
1. Define the Doctor Model
First, create a Doctor model in models.py that holds the doctor’s profile information:

python
# models.py
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=15, null=True, blank=True)
    specialty = models.CharField(max_length=100)
    years_of_experience = models.PositiveIntegerField()
    bio = models.TextField(null=True, blank=True)

    def __str__(self):
        return f'{self.first_name} {self.last_name} ({self.specialty})'
2. Create a Serializer
Now, create a serializer to convert the Doctor model into a JSON response and handle the incoming data.

python
# serializers.py
from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = '__all__'  # Include all fields from the Doctor model
3. Create the Class-Based View
We can use DRF's ListCreateAPIView and RetrieveUpdateDestroyAPIView for the GET, POST, PUT, and DELETE operations.

python
# views.py
from rest_framework import generics
from .models import Doctor
from .serializers import DoctorSerializer

# List and Create view for Doctor profiles
class DoctorListCreateView(generics.ListCreateAPIView):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer

    def perform_create(self, serializer):
        # Optionally, you can add custom logic here when creating a doctor
        serializer.save()

# Retrieve, Update and Delete view for a single Doctor profile
class DoctorRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
DoctorListCreateView allows for listing all doctors (GET) and creating a new doctor (POST).
DoctorRetrieveUpdateDestroyView handles retrieving a specific doctor by ID (GET), updating a doctor (PUT), and deleting a 
doctor (DELETE).
4. Define URLs
Finally, create URLs to route the requests to the appropriate views.

python
# urls.py
from django.urls import path
from .views import DoctorListCreateView, DoctorRetrieveUpdateDestroyView

urlpatterns = [
    path('doctors/', DoctorListCreateView.as_view(), name='doctor-list-create'),
    path('doctors/<int:pk>/', DoctorRetrieveUpdateDestroyView.as_view(), name='doctor-retrieve-update-destroy'),
]
Explanation:
/doctors/: This endpoint will list all doctors (GET) and allow the creation of a new doctor profile (POST).
/doctors/<int:pk>/: This endpoint handles retrieving (GET), updating (PUT), or deleting (DELETE) a specific doctor based 
on the primary key (pk).
5. Optional: Permissions and Authentication
You may want to secure the endpoints with permissions and authentication. For example, if only authenticated users should 
be able to modify doctor profiles, you can add the IsAuthenticated permission:

python
Copy code
# views.py (add to the view classes)
from rest_framework.permissions import IsAuthenticated

class DoctorListCreateView(generics.ListCreateAPIView):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
    permission_classes = [IsAuthenticated]  # Restrict access to authenticated users

class DoctorRetrieveUpdateDestroyView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
    permission_classes = [IsAuthenticated]  # Restrict access to authenticated users
6. Migrate the Database
After defining the model, run the following commands to create the table in the database:

bash
python manage.py makemigrations
python manage.py migrate
Conclusion:
With the above steps, you now have a DRF-based class-based view to manage doctor profiles. The two main views are:

List and Create: List all doctors and create a new one.
Retrieve, Update, and Destroy: Retrieve a single doctor, update their information, or delete their profile.

Practical Example: 5) Write a Django project that implements a class-based view to handle doctor profile creation, 
reading, updating, and deletion (CRUD operations).

To create a Django project that implements CRUD operations for a doctor's profile using class-based views (CBVs), 
we need to follow these steps:

Create the Django project and app.
Define a model for the doctor profile.
Create class-based views to handle CRUD operations.
Configure URLs.
Create forms for the doctor profile (optional, but recommended for handling form submissions).
Create templates for rendering the views.
Here’s the full code structure for this Django project:

Step 1: Create a Django Project and App
First, make sure you have Django installed, and then create a new project and an app:

bash
django-admin startproject doctor_profile
cd doctor_profile
python manage.py startapp profiles
Step 2: Define the Doctor Profile Model
In profiles/models.py, define a model to represent the doctor profile:

python
from django.db import models

class DoctorProfile(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialization = models.CharField(max_length=200)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()
    bio = models.TextField()
    address = models.TextField()

    def __str__(self):
        return f"Dr. {self.first_name} {self.last_name}"
Step 3: Create Forms for Doctor Profile (Optional)
In profiles/forms.py, create a form to handle doctor profile creation and updates:

python
from django import forms
from .models import DoctorProfile

class DoctorProfileForm(forms.ModelForm):
    class Meta:
        model = DoctorProfile
        fields = ['first_name', 'last_name', 'specialization', 'phone_number', 'email', 'bio', 'address']
Step 4: Create Class-Based Views (CBVs) for CRUD Operations
In profiles/views.py, create the following class-based views:

CreateView: To create a new doctor profile.
ListView: To display a list of all doctor profiles.
DetailView: To show detailed information of a specific doctor.
UpdateView: To update an existing doctor profile.
DeleteView: To delete a doctor profile.
python
Copy code
from django.urls import reverse_lazy
from django.views.generic import ListView, DetailView, CreateView, UpdateView, DeleteView
from .models import DoctorProfile
from .forms import DoctorProfileForm

# ListView to display all doctor profiles
class DoctorProfileListView(ListView):
    model = DoctorProfile
    template_name = 'profiles/doctor_profile_list.html'
    context_object_name = 'doctor_profiles'

# DetailView to display a single doctor profile
class DoctorProfileDetailView(DetailView):
    model = DoctorProfile
    template_name = 'profiles/doctor_profile_detail.html'
    context_object_name = 'doctor_profile'

# CreateView to create a new doctor profile
class DoctorProfileCreateView(CreateView):
    model = DoctorProfile
    form_class = DoctorProfileForm
    template_name = 'profiles/doctor_profile_form.html'
    success_url = reverse_lazy('doctor_profile_list')  # Redirect after successful creation

# UpdateView to update an existing doctor profile
class DoctorProfileUpdateView(UpdateView):
    model = DoctorProfile
    form_class = DoctorProfileForm
    template_name = 'profiles/doctor_profile_form.html'
    success_url = reverse_lazy('doctor_profile_list')  # Redirect after successful update

# DeleteView to delete a doctor profile
class DoctorProfileDeleteView(DeleteView):
    model = DoctorProfile
    template_name = 'profiles/doctor_profile_confirm_delete.html'
    success_url = reverse_lazy('doctor_profile_list')  # Redirect after successful deletion
Step 5: Configure URLs
In profiles/urls.py, map the views to URLs:

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.DoctorProfileListView.as_view(), name='doctor_profile_list'),
    path('doctor/<int:pk>/', views.DoctorProfileDetailView.as_view(), name='doctor_profile_detail'),
    path('doctor/new/', views.DoctorProfileCreateView.as_view(), name='doctor_profile_create'),
    path('doctor/<int:pk>/edit/', views.DoctorProfileUpdateView.as_view(), name='doctor_profile_edit'),
    path('doctor/<int:pk>/delete/', views.DoctorProfileDeleteView.as_view(), name='doctor_profile_delete'),
]
In doctor_profile/urls.py, include the profiles app URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('profiles/', include('profiles.urls')),
]
Step 6: Create Templates for Rendering Views
You’ll need to create the templates to render the views. Below are the basic templates:

templates/profiles/doctor_profile_list.html (to list all doctor profiles)
html
<h1>Doctor Profiles</h1>
<ul>
    {% for profile in doctor_profiles %}
        <li><a href="{% url 'doctor_profile_detail' profile.pk %}">{{ profile.first_name }} {{ profile.last_name }}</a></li>
    {% endfor %}
</ul>
<a href="{% url 'doctor_profile_create' %}">Create a New Profile</a>
templates/profiles/doctor_profile_detail.html (to show detailed info of a specific doctor)
html
<h1>{{ doctor_profile.first_name }} {{ doctor_profile.last_name }}</h1>
<p>Specialization: {{ doctor_profile.specialization }}</p>
<p>Phone: {{ doctor_profile.phone_number }}</p>
<p>Email: {{ doctor_profile.email }}</p>
<p>Bio: {{ doctor_profile.bio }}</p>
<p>Address: {{ doctor_profile.address }}</p>

<a href="{% url 'doctor_profile_edit' doctor_profile.pk %}">Edit</a>
<a href="{% url 'doctor_profile_delete' doctor_profile.pk %}">Delete</a>
templates/profiles/doctor_profile_form.html (for the Create and Update forms)
html
<h1>{% if form.instance.pk %}Edit{% else %}Create{% endif %} Doctor Profile</h1>
<form method="post">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Save</button>
</form>
templates/profiles/doctor_profile_confirm_delete.html (to confirm deletion)
html
<h1>Are you sure you want to delete this doctor profile?</h1>
<form method="post">
    {% csrf_token %}
    <button type="submit">Confirm Delete</button>
    <a href="{% url 'doctor_profile_list' %}">Cancel</a>
</form>
Step 7: Migrate the Database
Run the following commands to apply the migrations and create the necessary database tables:

bash
python manage.py makemigrations
python manage.py migrate
Step 8: Create an Admin Interface (Optional)
In profiles/admin.py, you can register the model to manage doctor profiles via the Django admin interface:

python
from django.contrib import admin
from .models import DoctorProfile

admin.site.register(DoctorProfile)
Step 9: Run the Development Server
Finally, run the development server:

bash
python manage.py runserver
Now, you can go to http://127.0.0.1:8000/profiles/ in your browser to view the doctor profiles, create new profiles, edit,
and delete existing ones.

6. URL Routing in Django REST Framework
Theory:
 Defining URLs and linking them to views.

In web development, particularly in frameworks like Django (for Python) or Flask, URLs are defined and linked to views to 
route HTTP requests to the appropriate functionality in the application. Here's an overview of how this works:

1. Defining URLs and Linking them to Views (Django Example)
In Django, URLs are defined in the urls.py file and are mapped to specific views, which handle the request and generate 
a response. Here's how you can define URLs and link them to views:

Steps:
Create Views: Views are Python functions or classes that handle HTTP requests and return responses. These can be located 
in the views.py file.

Define URLs: You define URLs in the urls.py file and link them to views using path() or re_path() (for regular 
expressions).

Configure URL Patterns: The URL patterns list in urls.py matches the requested URL and links it to the appropriate view.

Example:
Step 1: Create Views in views.py
python
# views.py
from django.http import HttpResponse
from django.shortcuts import render

# A simple view function that returns a plain text response
def home(request):
    return HttpResponse("Welcome to the Home Page!")

# A view that renders a template
def about(request):
    return render(request, 'about.html')  # Render a template
Step 2: Define URL Patterns in urls.py
python
# urls.py
from django.urls import path
from . import views  # Import views from the current directory

urlpatterns = [
    # Mapping the URL path to the home view
    path('', views.home, name='home'),  # Empty string ('') represents the homepage

    # Mapping the URL path to the about view
    path('about/', views.about, name='about'),  # The 'about/' URL
]
Explanation:
The path() function is used to define the URLs. The first argument is the URL pattern, the second argument is the 
view function (such as views.home or views.about), and the optional third argument is the name of the URL (which can be 
useful for reversing URLs).
In the example, home() returns a simple HTTP response, while about() renders an HTML template.
2. Defining URLs and Linking them to Views (Flask Example)
In Flask, the URL routing system is similarly used to map URLs to views. Here's a basic example using Flask:

Step 1: Create Views in app.py
python
# app.py
from flask import Flask, render_template

app = Flask(__name__)

# Home view function
@app.route('/')
def home():
    return "Welcome to the Home Page!"

# About view function
@app.route('/about')
def about():
    return render_template('about.html')  # Render an HTML template

if __name__ == '__main__':
    app.run(debug=True)
Explanation:
In Flask, the @app.route() decorator is used to link URLs to view functions.
The home() function is linked to the / URL, while the about() function is linked to /about.
3. Advanced Concepts
URL Parameters: You can also define dynamic URLs by including parameters in the URL and passing them to the views.

Django Example:

python
# urls.py
path('item/<int:id>/', views.item_detail, name='item_detail')
Here, <int:id> captures an integer as a parameter and passes it to the item_detail view.

Flask Example:

python
@app.route('/item/<int:id>')
def item_detail(id):
    return f"Item ID: {id}"
Regular Expressions: In Django, you can use re_path() for more complex patterns.

Summary
Django: URL patterns are defined in the urls.py file and mapped to views using the path() or re_path() functions.
Flask: URL patterns are linked to views using the @app.route() decorator.
Both frameworks allow you to link specific URLs to views, whether those views return plain text, render templates, or 
handle dynamic parameters in the URL.

Lab:
 Set up URL routing in a Django project to link to CRUD API endpoints for doctors.

To set up URL routing in a Django project for linking CRUD (Create, Read, Update, Delete) API endpoints for doctors, 
you'll need to follow these steps. I'll guide you through creating the views, serializing the data, and setting up the 
routing.

1. Create a Doctor Model
Start by defining a model for the Doctor in your models.py file.

python
# models.py
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()

    def __str__(self):
        return f"Dr. {self.first_name} {self.last_name}"
2. Create a Serializer
Next, create a serializer for the Doctor model using Django REST Framework. This will allow you to serialize and 
deserialize the data for API requests and responses.

python
# serializers.py
from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = '__all__'
3. Create Views for CRUD Operations
Use Django REST Framework's APIView or ModelViewSet to create the views for handling CRUD operations. Below is an 
example of using ModelViewSet, which provides the basic CRUD functionality out of the box.

python
# views.py
from rest_framework import viewsets
from .models import Doctor
from .serializers import DoctorSerializer

class DoctorViewSet(viewsets.ModelViewSet):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
4. Set Up URL Routing
In Django, you need to set up routing for the views. You can use the DefaultRouter provided by Django REST Framework to 
automatically generate routes for the viewset.

First, you need to import the viewset and router in your urls.py file.

python
# urls.py
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DoctorViewSet

router = DefaultRouter()
router.register(r'doctors', DoctorViewSet)

urlpatterns = [
    path('api/', include(router.urls)),
]
This will create the following API endpoints for the Doctor model:

GET /api/doctors/: List all doctors.
POST /api/doctors/: Create a new doctor.
GET /api/doctors/{id}/: Retrieve a specific doctor.
PUT /api/doctors/{id}/: Update a specific doctor.
DELETE /api/doctors/{id}/: Delete a specific doctor.
5. Include REST Framework in Settings
If you haven't done so already, make sure you've added Django REST Framework to your installed apps in settings.py.

python
# settings.py
INSTALLED_APPS = [
    # other apps
    'rest_framework',
]
6. Migrate the Database
Run migrations to create the Doctor model in the database.

bash
python manage.py makemigrations
python manage.py migrate
7. Testing the API
You can now test your API using tools like Postman, or by running the Django development server and visiting the endpoints.

bash
python manage.py runserver
The CRUD endpoints for managing doctors will be accessible at:

GET /api/doctors/ (list all doctors)
POST /api/doctors/ (create a new doctor)
GET /api/doctors/{id}/ (retrieve a specific doctor)
PUT /api/doctors/{id}/ (update a specific doctor)
DELETE /api/doctors/{id}/ (delete a specific doctor)
8. Optional: Customize Views (Authentication, Permissions)
You can also add authentication and permission classes if needed to restrict access to certain API endpoints. For example:

python
# views.py
from rest_framework.permissions import IsAuthenticated

class DoctorViewSet(viewsets.ModelViewSet):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
    permission_classes = [IsAuthenticated]
This ensures that only authenticated users can access the doctor API endpoints.

With these steps, you've successfully set up URL routing for CRUD API endpoints to manage doctors in a Django project.

Practical Example: 6) Write a Django project that routes URLs to the views handling doctor CRUD operations 
(/doctors, /doctors/<id>).

To create a Django project that routes URLs to views handling CRUD (Create, Read, Update, Delete) operations for doctors, 
follow the steps below. This includes creating models, views, templates, forms, and routing.

1. Create a Django Project and App
1.1. Install Django (if not installed yet)
bash
pip install django
1.2. Create a Django project and an app:
bash
django-admin startproject hospital
cd hospital
django-admin startapp doctors
1.3. Add the doctors app to settings.py:
In hospital/settings.py, add 'doctors' to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    ...
    'doctors',
    ...
]
2. Create the Doctor Model
In doctors/models.py, define the Doctor model:

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()

    def __str__(self):
        return f"{self.first_name} {self.last_name}"
2.1. Apply migrations
Run migrations to create the database table for the Doctor model:

bash
python manage.py makemigrations
python manage.py migrate
3. Create Forms for Doctor CRUD Operations
In doctors/forms.py, create a form to handle doctor data input:

python
from django import forms
from .models import Doctor

class DoctorForm(forms.ModelForm):
    class Meta:
        model = Doctor
        fields = ['first_name', 'last_name', 'specialty', 'phone_number', 'email']
4. Define Views for CRUD Operations
In doctors/views.py, define views for creating, viewing, updating, and deleting doctors:

python
from django.shortcuts import render, redirect, get_object_or_404
from .models import Doctor
from .forms import DoctorForm

# View all doctors
def doctor_list(request):
    doctors = Doctor.objects.all()
    return render(request, 'doctors/doctor_list.html', {'doctors': doctors})

# View a single doctor
def doctor_detail(request, id):
    doctor = get_object_or_404(Doctor, id=id)
    return render(request, 'doctors/doctor_detail.html', {'doctor': doctor})

# Create a new doctor
def doctor_create(request):
    if request.method == 'POST':
        form = DoctorForm(request.POST)
        if form.is_valid():
            form.save()
            return redirect('doctor_list')
    else:
        form = DoctorForm()
    return render(request, 'doctors/doctor_form.html', {'form': form})

# Update an existing doctor
def doctor_update(request, id):
    doctor = get_object_or_404(Doctor, id=id)
    if request.method == 'POST':
        form = DoctorForm(request.POST, instance=doctor)
        if form.is_valid():
            form.save()
            return redirect('doctor_detail', id=doctor.id)
    else:
        form = DoctorForm(instance=doctor)
    return render(request, 'doctors/doctor_form.html', {'form': form})

# Delete a doctor
def doctor_delete(request, id):
    doctor = get_object_or_404(Doctor, id=id)
    if request.method == 'POST':
        doctor.delete()
        return redirect('doctor_list')
    return render(request, 'doctors/doctor_confirm_delete.html', {'doctor': doctor})
5. Create URLs for Routing
In doctors/urls.py, define the URL routing for the CRUD views:

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.doctor_list, name='doctor_list'),
    path('doctors/<int:id>/', views.doctor_detail, name='doctor_detail'),
    path('doctors/create/', views.doctor_create, name='doctor_create'),
    path('doctors/<int:id>/update/', views.doctor_update, name='doctor_update'),
    path('doctors/<int:id>/delete/', views.doctor_delete, name='doctor_delete'),
]
Then, in the project's urls.py (i.e., hospital/urls.py), include the doctors URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('doctors.urls')),
]
6. Create HTML Templates
In doctors/templates/doctors/, create the following HTML templates for each view:

6.1. doctor_list.html
html
<!DOCTYPE html>
<html>
<head>
    <title>Doctor List</title>
</head>
<body>
    <h1>Doctors</h1>
    <a href="{% url 'doctor_create' %}">Add a new doctor</a>
    <ul>
        {% for doctor in doctors %}
            <li>
                <a href="{% url 'doctor_detail' doctor.id %}">{{ doctor.first_name }} {{ doctor.last_name }}</a> - 
                <a href="{% url 'doctor_update' doctor.id %}">Edit</a> - 
                <a href="{% url 'doctor_delete' doctor.id %}">Delete</a>
            </li>
        {% endfor %}
    </ul>
</body>
</html>
6.2. doctor_detail.html
html
<!DOCTYPE html>
<html>
<head>
    <title>{{ doctor.first_name }} {{ doctor.last_name }}</title>
</head>
<body>
    <h1>{{ doctor.first_name }} {{ doctor.last_name }}</h1>
    <p><strong>Specialty:</strong> {{ doctor.specialty }}</p>
    <p><strong>Phone:</strong> {{ doctor.phone_number }}</p>
    <p><strong>Email:</strong> {{ doctor.email }}</p>
    <a href="{% url 'doctor_update' doctor.id %}">Edit</a>
    <a href="{% url 'doctor_delete' doctor.id %}">Delete</a>
    <a href="{% url 'doctor_list' %}">Back to list</a>
</body>
</html>
6.3. doctor_form.html
html
<!DOCTYPE html>
<html>
<head>
    <title>Doctor Form</title>
</head>
<body>
    <h1>Create/Update Doctor</h1>
    <form method="post">
        {% csrf_token %}
        {{ form.as_p }}
        <button type="submit">Save</button>
    </form>
    <a href="{% url 'doctor_list' %}">Cancel</a>
</body>
</html>
6.4. doctor_confirm_delete.html
html
<!DOCTYPE html>
<html>
<head>
    <title>Delete Doctor</title>
</head>
<body>
    <h1>Are you sure you want to delete {{ doctor.first_name }} {{ doctor.last_name }}?</h1>
    <form method="post">
        {% csrf_token %}
        <button type="submit">Confirm</button>
    </form>
    <a href="{% url 'doctor_list' %}">Cancel</a>
</body>
</html>
7. Run the Django Project
Finally, run the server to check everything works:

bash
python manage.py runserver
Now, you can visit:

http://127.0.0.1:8000/ to view the list of doctors
http://127.0.0.1:8000/doctors/create/ to add a new doctor
http://127.0.0.1:8000/doctors/<id>/ to view a doctor's details
http://127.0.0.1:8000/doctors/<id>/update/ to update a doctor's details
http://127.0.0.1:8000/doctors/<id>/delete/ to delete a doctor
This sets up a simple CRUD functionality for managing doctors in your Django project!

7. Pagination in Django REST Framework
Theory:
 Adding pagination to APIs to handle large data sets.

Adding pagination to APIs is a common technique used to manage large datasets by splitting the data into smaller, more 
manageable chunks or pages. This is particularly useful for improving performance, as it reduces the amount of data sent 
over the network in a single request. Here's a general guide on how to add pagination to an API.

Key Concepts
Page Numbering: Pagination typically uses a system where clients request specific pages of data (e.g., "page 1", "page 2").
Limit/Offset: Another common approach is using a limit (number of records per page) and offset (the starting point for 
data).
Cursor-based Pagination: A more advanced and efficient method, where the server provides a cursor (usually a unique 
identifier) to help the client request the next set of results starting from that point.
Steps to Implement Pagination
1. Decide the Pagination Strategy
Page-based Pagination: Clients request a specific page number and the number of records per page (e.g., page=1&limit=10).
Cursor-based Pagination: The server provides a cursor (e.g., next_cursor=abc123) to keep track of the current page's 
position.
2. Modify Your API Endpoint
Let's look at two approaches:

1. Page-based Pagination (Limit/Offset)
For an API endpoint that fetches data from a database, you'll typically want to add query parameters for the page number 
and the number of items per page.

Example:
Request URL: /api/items?page=1&limit=10

Backend Logic:

Parse page and limit query parameters.
Calculate the offset as (page - 1) * limit.
Query the database with these parameters to fetch the right subset of records.
Sample API Response:
json
{
  "data": [
    { "id": 1, "name": "Item 1" },
    { "id": 2, "name": "Item 2" },
    { "id": 3, "name": "Item 3" },
    ...
  ],
  "pagination": {
    "current_page": 1,
    "total_pages": 10,
    "total_items": 100,
    "limit": 10,
    "next_page": 2,
    "previous_page": null
  }
}
2. Cursor-based Pagination
This method involves returning a cursor that the client can use for subsequent requests to get the next page of data. 
It avoids issues with changing datasets (such as items being added or removed between requests).

Example:
Request URL: /api/items?cursor=abc123&limit=10

Backend Logic:

The server stores a cursor (often a unique ID) for each page of results.
The cursor identifies the last item of the current page.
When the client makes the next request, it provides the cursor to get the next set of records.
Sample API Response:
json
{
  "data": [
    { "id": 1, "name": "Item 1" },
    { "id": 2, "name": "Item 2" },
    { "id": 3, "name": "Item 3" }
  ],
  "pagination": {
    "next_cursor": "abc123",
    "previous_cursor": "xyz789"
  }
}
3. Handling Edge Cases
When implementing pagination, there are a few edge cases and considerations:

Empty results: Ensure your API returns an empty array or null if no results match the query parameters.
Invalid parameters: Handle invalid page, limit, or cursor values by returning a proper error message.
Consistency: With offset-based pagination, results might change between requests (e.g., items added or deleted), so 
cursor-based pagination might be more reliable.
4. Best Practices for Pagination
Limit the maximum page size: To prevent clients from requesting too much data at once, set a maximum limit 
(e.g., limit=100).
Include total records in the response: Provide the client with the total number of records available, the total number of 
pages, and the current page, so they can navigate through the pages.
Ensure Sorting: If you're using pagination with a dataset that is dynamically changing, ensure the data is sorted 
consistently (e.g., by created_at or id).
Handle edge cases: For large datasets, handle pagination with proper bounds and ensure that the last page correctly 
returns no more results.
Example in Code (Using Python and Flask):
Here’s a simplified example of adding pagination to an API in Python using Flask and SQLAlchemy.

python
from flask import Flask, request, jsonify
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Item  # Assuming you have an Item model

app = Flask(__name__)

# Database connection setup
engine = create_engine('sqlite:///database.db')
Session = sessionmaker(bind=engine)
session = Session()

@app.route('/api/items', methods=['GET'])
def get_items():
    # Get pagination parameters from query string
    page = int(request.args.get('page', 1))
    limit = int(request.args.get('limit', 10))
    
    # Calculate offset and limit
    offset = (page - 1) * limit
    
    # Query the database with pagination
    items = session.query(Item).limit(limit).offset(offset).all()
    
    # Total number of items (for pagination)
    total_items = session.query(Item).count()
    total_pages = (total_items + limit - 1) // limit  # Calculate total pages
    
    # Prepare the response
    data = [{"id": item.id, "name": item.name} for item in items]
    
    pagination = {
        "current_page": page,
        "total_pages": total_pages,
        "total_items": total_items,
        "limit": limit,
        "next_page": page + 1 if page < total_pages else None,
        "previous_page": page - 1 if page > 1 else None
    }
    
    return jsonify({"data": data, "pagination": pagination})

if __name__ == '__main__':
    app.run(debug=True)

Lab:
 Implement pagination in a Django REST API for fetching doctor profiles.

To implement pagination in a Django REST API for fetching doctor profiles, you can use Django REST Framework's built-in 
pagination classes. Pagination helps limit the number of results returned in a single response, which is useful when the 
dataset is large and you want to split the data into pages.

Here’s how you can implement pagination for doctor profiles:

1. Install Django REST Framework
If you haven't already, make sure you have Django REST Framework installed in your Django project.

bash
pip install djangorestframework
Then, add it to your INSTALLED_APPS in settings.py:

python
INSTALLED_APPS = [
    # Other installed apps
    'rest_framework',
]
2. Configure Pagination in settings.py
You can configure global pagination in your settings.py file. Django REST Framework provides several types of pagination, 
such as PageNumberPagination, LimitOffsetPagination, and CursorPagination. Here’s how you can use PageNumberPagination:

python
# settings.py

REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,  # Number of items per page
}
This configuration sets the pagination to return 10 doctor profiles per page. You can adjust the PAGE_SIZE to any number 
you need.

3. Define Your Model
Let’s assume you have a DoctorProfile model that contains the details of doctors. Here’s an example:

python
# models.py

from django.db import models

class DoctorProfile(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialization = models.CharField(max_length=100)
    email = models.EmailField()
    phone_number = models.CharField(max_length=15)
    
    def __str__(self):
        return f"{self.first_name} {self.last_name}"
4. Create a Serializer
Next, create a serializer for the DoctorProfile model:

python
# serializers.py

from rest_framework import serializers
from .models import DoctorProfile

class DoctorProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = DoctorProfile
        fields = '__all__'
5. Create a View to Fetch Doctor Profiles
Now, let’s create a view using Django REST Framework's APIView or ViewSet. If you want to apply pagination, you can use a 
ListAPIView or ModelViewSet for fetching doctor profiles.

Using a ListAPIView:

python
# views.py

from rest_framework.generics import ListAPIView
from .models import DoctorProfile
from .serializers import DoctorProfileSerializer

class DoctorProfileListView(ListAPIView):
    queryset = DoctorProfile.objects.all()
    serializer_class = DoctorProfileSerializer
6. Add URL Routing
Now, add the URL routing for the view in your urls.py:

python
# urls.py

from django.urls import path
from .views import DoctorProfileListView

urlpatterns = [
    path('doctor-profiles/', DoctorProfileListView.as_view(), name='doctor-profile-list'),
]
7. Test Pagination
Once everything is set up, you can test the pagination in your API. If you visit /doctor-profiles/, you will see a 
paginated response, like this:

json
{
    "count": 100,  # Total number of doctor profiles
    "next": "http://example.com/doctor-profiles/?page=2",  # Link to the next page
    "previous": null,  # Link to the previous page (null for the first page)
    "results": [
        {
            "id": 1,
            "first_name": "John",
            "last_name": "Doe",
            "specialization": "Cardiologist",
            "email": "john.doe@example.com",
            "phone_number": "123456789"
        },
        {
            "id": 2,
            "first_name": "Jane",
            "last_name": "Smith",
            "specialization": "Dermatologist",
            "email": "jane.smith@example.com",
            "phone_number": "987654321"
        }
        // More doctor profiles...
    ]
}
count: The total number of doctor profiles available in the database.
next: The URL to get the next page of results.
previous: The URL to get the previous page of results (if applicable).
results: The list of doctor profiles for the current page.
8. Optional: Customizing Pagination
If you want to customize the pagination further (for example, by changing the pagination style or using a custom 
pagination class), you can subclass a pagination class like this:

python
# pagination.py

from rest_framework.pagination import PageNumberPagination

class CustomPageNumberPagination(PageNumberPagination):
    page_size = 10  # Default page size
    page_size_query_param = 'page_size'  # Allows user to set custom page size
    max_page_size = 100  # Max limit for page size
Then, use this custom pagination class in your views.py:

python
# views.py

from rest_framework.generics import ListAPIView
from .models import DoctorProfile
from .serializers import DoctorProfileSerializer
from .pagination import CustomPageNumberPagination

class DoctorProfileListView(ListAPIView):
    queryset = DoctorProfile.objects.all()
    serializer_class = DoctorProfileSerializer
    pagination_class = CustomPageNumberPagination

Practical Example: 7) Write a Django API that returns paginated results for a list of doctors.

To create a Django API that returns paginated results for a list of doctors, you will need to follow these steps:

Set up a Django project (if you don’t have one already).
Create a model to represent a Doctor.
Create a view that handles the pagination logic.
Create a serializer to convert doctor objects to JSON.
Set up URL routing to access the API endpoint.
Below is an implementation of these steps:

1. Install Django and Django REST Framework
First, if you haven't already, install Django and Django REST Framework:

bash
pip install django djangorestframework
2. Set up the Django project and app
Create a new Django project and app if you don't have one already:

bash
django-admin startproject doctorapi
cd doctorapi
python manage.py startapp doctors
3. Update settings.py
Add rest_framework and the app doctors to the INSTALLED_APPS list in doctorapi/settings.py:

python
INSTALLED_APPS = [
    # other apps
    'rest_framework',
    'doctors',
]
4. Define the Doctor Model
In doctors/models.py, define the Doctor model:

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialization = models.CharField(max_length=200)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()

    def __str__(self):
        return f"{self.first_name} {self.last_name}"
5. Create a Serializer for Doctor Model
In doctors/serializers.py, create a serializer to convert the Doctor objects into JSON format:

python
from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = ['id', 'first_name', 'last_name', 'specialization', 'phone_number', 'email']
6. Create the Paginated API View
In doctors/views.py, create a view that uses pagination to return a list of doctors:

python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.pagination import PageNumberPagination
from .models import Doctor
from .serializers import DoctorSerializer

class DoctorPagination(PageNumberPagination):
    page_size = 10  # Adjust this number to change the number of doctors per page
    page_size_query_param = 'page_size'
    max_page_size = 100

class DoctorListView(APIView):
    def get(self, request):
        doctors = Doctor.objects.all()  # Get all doctors
        paginator = DoctorPagination()  # Use the pagination class
        paginated_doctors = paginator.paginate_queryset(doctors, request)
        serializer = DoctorSerializer(paginated_doctors, many=True)
        return paginator.get_paginated_response(serializer.data)
7. Set up URLs
In doctors/urls.py, set up the URL to access the doctor list view:

python
from django.urls import path
from .views import DoctorListView

urlpatterns = [
    path('doctors/', DoctorListView.as_view(), name='doctor-list'),
]
In the main urls.py file (doctorapi/urls.py), include the app's URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('doctors.urls')),  # Include the doctors' URLs
]
8. Migrate the Database
Run the migrations to create the Doctor model in the database:

bash
python manage.py makemigrations
python manage.py migrate
9. Create Some Doctor Records (Optional)
You can create doctor records using Django admin or the Django shell:

bash
python manage.py shell
Then, create some Doctor instances:

python
from doctors.models import Doctor
Doctor.objects.create(first_name="John", last_name="Doe", specialization="Cardiology", phone_number="123-456-7890", 
email="john.doe@example.com")
Doctor.objects.create(first_name="Jane", last_name="Smith", specialization="Neurology", phone_number="987-654-3210", 
email="jane.smith@example.com")
10. Test the API
Now, you can run the Django development server:

bash
python manage.py runserver
Visit the following URL in your browser or use Postman:

ruby
http://127.0.0.1:8000/api/doctors/?page=1
This will return a paginated list of doctors, with page_size and page parameters to control pagination.

For example, the response may look like:

json
{
    "count": 50,
    "next": "http://127.0.0.1:8000/api/doctors/?page=2",
    "previous": null,
    "results": [
        {
            "id": 1,
            "first_name": "John",
            "last_name": "Doe",
            "specialization": "Cardiology",
            "phone_number": "123-456-7890",
            "email": "john.doe@example.com"
        },
        {
            "id": 2,
            "first_name": "Jane",
            "last_name": "Smith",
            "specialization": "Neurology",
            "phone_number": "987-654-3210",
            "email": "jane.smith@example.com"
        }
    ]
}

8. Settings Configuration in Django
Theory:
 Configuring Django settings for database, static files, and API keys.

To configure Django settings for database, static files, and API keys, you need to make adjustments in the settings.py 
file of your Django project. Below are the steps and examples on how to configure each of these elements:

1. Configuring the Database
In Django, the database settings are configured using the DATABASES setting in settings.py. You can configure the 
database connection to different databases like SQLite (default), PostgreSQL, MySQL, etc.

Example for PostgreSQL database configuration:

python
# settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',  # Use PostgreSQL
        'NAME': 'your_db_name',  # Database name
        'USER': 'your_db_user',  # Database user
        'PASSWORD': 'your_db_password',  # Database password
        'HOST': 'localhost',  # Database host
        'PORT': '5432',  # Database port (default PostgreSQL port)
    }
}
For SQLite (default configuration):

python
# settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
Make sure to install the necessary database driver (e.g., psycopg2 for PostgreSQL):

bash
pip install psycopg2
2. Configuring Static Files
Static files in Django are files like CSS, JavaScript, and images that are served to the client. To configure static 
files, you need to set the STATIC_URL, STATICFILES_DIRS, and STATIC_ROOT settings in settings.py.

STATIC_URL: The URL to use when referring to static files.
STATICFILES_DIRS: A list of directories where Django will look for static files during development.
STATIC_ROOT: The absolute path to the directory where collectstatic will collect static files for production.
Example configuration:

python
# settings.py

STATIC_URL = '/static/'  # URL for static files

# For development: Add directories where your static files reside
STATICFILES_DIRS = [
    BASE_DIR / "static",  # Example: Add a "static" directory at the root of your project
]

# For production: Set the location where static files will be collected
STATIC_ROOT = BASE_DIR / 'staticfiles'  # Directory where collectstatic will place all static files
In production, run python manage.py collectstatic to collect all static files into the STATIC_ROOT directory for serving 
by the web server.

3. Configuring API Keys
API keys should not be hardcoded in your settings.py file. It's safer to load them from environment variables or a .env 
file to keep your API keys secure and private.

Install the python-decouple library to easily manage environment variables:

bash
pip install python-decouple
Now, you can configure API keys by storing them in an environment file (.env) and loading them into settings.py using 
Config from decouple.

Create a .env file in your project root (same level as manage.py) with the API key(s):
env
# .env file
API_KEY="your_api_key_here"
Modify settings.py to load the key using decouple:
python
# settings.py

from decouple import Config

config = Config()

# Load the API key from the .env file
API_KEY = config('API_KEY')  # Replace 'API_KEY' with the name of your actual API key
4. Additional Settings
Debug Mode: Make sure DEBUG is set to True in development and False in production:
python
# settings.py

DEBUG = config('DEBUG', default=True, cast=bool)  # Default to True, but can be overridden in .env
Allowed Hosts: To prevent unauthorized domains from accessing your site, set ALLOWED_HOSTS:
python
Copy code
# settings.py

ALLOWED_HOSTS = config('ALLOWED_HOSTS', default='localhost', cast=lambda v: [s.strip() for s in v.split(',')])
Secret Key: It's important to keep your Django SECRET_KEY safe by loading it from an environment variable.
python
# settings.py

SECRET_KEY = config('SECRET_KEY')  # Load from .env
In your .env file:

env
SECRET_KEY="your-secret-key-here"
Final Example Configuration for settings.py
python
# settings.py

import os
from decouple import Config, Csv

config = Config()

# Database Configuration
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': config('DB_NAME'),
        'USER': config('DB_USER'),
        'PASSWORD': config('DB_PASSWORD'),
        'HOST': config('DB_HOST', default='localhost'),
        'PORT': config('DB_PORT', default=5432),
    }
}

# Static Files Configuration
STATIC_URL = '/static/'
STATICFILES_DIRS = [BASE_DIR / 'static']
STATIC_ROOT = BASE_DIR / 'staticfiles'

# API Key Configuration
API_KEY = config('API_KEY')

# Debug Configuration
DEBUG = config('DEBUG', default=True, cast=bool)

# Allowed Hosts
ALLOWED_HOSTS = config('ALLOWED_HOSTS', default='localhost', cast=Csv())
Security Tips:
Never push your .env file to a public repository (use .gitignore to exclude it).
Use environment-specific .env files for production, staging, and development settings.
This should give you a good foundation for configuring the database, static files, and API keys in Django.

Lab:
 Modify settings.py to connect Django to a MySQL or SQLite database.

To connect Django to either a MySQL or SQLite database, you will need to modify the settings.py file in your Django 
project. The database settings are located in the DATABASES section of settings.py.

For SQLite (Default Database in Django):
SQLite is the default database backend in Django, so if you are happy to use SQLite, no changes are needed unless you 
want to configure it further. Here's the default configuration:

python
# settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',  # SQLite backend
        'NAME': BASE_DIR / 'db.sqlite3',         # Database file location
    }
}
SQLite stores the database in a file on your system, and the BASE_DIR / 'db.sqlite3' defines the path to this file.

For MySQL:
To use MySQL as your database backend, you'll need to modify the DATABASES setting and ensure that you have the 
mysqlclient package installed.

Install MySQL Client:

First, install the mysqlclient package, which Django uses to interact with MySQL databases:

bash
pip install mysqlclient
Modify settings.py for MySQL:

Update the DATABASES setting in settings.py to use MySQL. You will need to provide the database name, user, password, 
host, and port.

python
# settings.py

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # MySQL backend
        'NAME': 'your_database_name',          # The name of your database
        'USER': 'your_mysql_user',             # Your MySQL username
        'PASSWORD': 'your_mysql_password',     # Your MySQL password
        'HOST': 'localhost',                   # MySQL server (use 'localhost' for local setup)
        'PORT': '3306',                        # MySQL default port (use '3306')
    }
}
Replace your_database_name, your_mysql_user, and your_mysql_password with the actual values for your MySQL setup.
If you're connecting to a remote MySQL server, replace 'localhost' with the IP address or domain name of the server.
Additional Steps for MySQL (Optional):
If you haven’t already created the database, you need to create it in MySQL:
bash
mysql -u root -p
CREATE DATABASE your_database_name;
If you want Django to automatically create the database tables, run the migrations after you’ve configured the database:
bash
python manage.py migrate
Final Steps:
After modifying settings.py, ensure your MySQL server is running (if using MySQL).
Run the following command to check that Django can connect to the database and perform the necessary migrations:
bash
python manage.py migrate
That's it! You've successfully connected Django to either an SQLite or MySQL database.

Practical Example: 8) Write a Django project that connects to an SQLite database and stores doctor profiles.

To create a Django project that connects to an SQLite database and stores doctor profiles, follow these steps:

Step 1: Install Django
If you haven't installed Django yet, you can install it using pip. Open a terminal and run:

bash
pip install django
Step 2: Create a Django Project
Create the Django project: In your terminal, run the following command to create a new Django project called 
doctor_profiles:

bash
django-admin startproject doctor_profiles
Navigate into the project directory:

bash
cd doctor_profiles
Create a Django app: Now create an app where the doctor profile functionality will reside. We'll call the app doctors.

bash
python manage.py startapp doctors
Add the app to INSTALLED_APPS: Open the settings.py file in the doctor_profiles folder and add 'doctors' to the 
INSTALLED_APPS list:

python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'doctors',  # Add this line
]
Step 3: Create the Model for Doctor Profile
In the doctors app folder, open the models.py file and define the Doctor model. This model will store the doctor's profile information such as name, specialization, contact details, etc.

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialization = models.CharField(max_length=200)
    contact_number = models.CharField(max_length=15)
    email = models.EmailField()
    address = models.TextField()

    def __str__(self):
        return f"Dr. {self.first_name} {self.last_name} - {self.specialization}"
Step 4: Create and Apply Migrations
After defining the model, run the following commands to create and apply the migrations:

Create migrations: This will create the SQL files required to create the table in the SQLite database.

bash
python manage.py makemigrations
Apply migrations: This will apply the migrations to the SQLite database.

bash
python manage.py migrate
Step 5: Create an Admin Interface to Manage Doctor Profiles
To make it easier to add, update, and delete doctor profiles, we can use Django's built-in admin interface.

Open the admin.py file in the doctors app and register the Doctor model.

python
from django.contrib import admin
from .models import Doctor

admin.site.register(Doctor)
Step 6: Set Up URLs
Open the doctors/urls.py file (if it doesn't exist, create it) and set up the URL for viewing doctor profiles.

python
from django.urls import path
from . import views

urlpatterns = [
    path('doctors/', views.doctor_list, name='doctor_list'),
]
Now, include these URLs in the main urls.py file located in the doctor_profiles folder. Open doctor_profiles/urls.py and 
modify it like this:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('doctors.urls')),  # Add this line to include doctors app URLs
]
Step 7: Create Views to Display Doctor Profiles
In the doctors/views.py file, create a view to display a list of doctors.

python
from django.shortcuts import render
from .models import Doctor

def doctor_list(request):
    doctors = Doctor.objects.all()
    return render(request, 'doctor_profiles/doctor_list.html', {'doctors': doctors})
Step 8: Create Templates
Inside the doctors app, create a folder called templates/doctor_profiles and then create a file called doctor_list.html 
inside it.

Add the following content to display the list of doctors:

html
Copy code
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Profiles</title>
</head>
<body>
    <h1>Doctor Profiles</h1>
    <ul>
        {% for doctor in doctors %}
            <li>
                <strong>{{ doctor.first_name }} {{ doctor.last_name }}</strong> - {{ doctor.specialization }}<br>
                Contact: {{ doctor.contact_number }}<br>
                Email: {{ doctor.email }}<br>
                Address: {{ doctor.address }}
            </li>
        {% endfor %}
    </ul>
</body>
</html>
Step 9: Run the Development Server
Finally, start the Django development server to test everything:

bash
python manage.py runserver
Now, open your browser and go to http://127.0.0.1:8000/ to see the list of doctor profiles. You can also access the 
Django admin interface at http://127.0.0.1:8000/admin/ to add doctor profiles manually.

Step 10: Adding Doctor Profiles via Admin
Go to http://127.0.0.1:8000/admin/ in your browser.
Log in using the superuser credentials (you need to create a superuser by running python manage.py createsuperuser).
Add doctor profiles via the admin interface.

9. Project Setup
Theory:
 Setting up a Django REST Framework project.

Setting up a Django REST Framework (DRF) project involves a few steps, including installing dependencies, setting up 
the project, configuring Django to use REST Framework, and creating API endpoints. Here's a step-by-step guide to 
help you get started.

Step 1: Install Python and Django
Ensure you have Python installed on your system. Django and Django REST Framework both require Python 3.x. You can 
check if Python is installed by running:

bash
python --version
or

bash
python3 --version
Step 2: Create a Virtual Environment
It’s a good practice to create a virtual environment to manage project dependencies. Run the following commands:

bash
# Create a project folder
mkdir my_project
cd my_project

# Create a virtual environment
python3 -m venv env

# Activate the virtual environment
# On Windows
env\Scripts\activate
# On Mac/Linux
source env/bin/activate
Step 3: Install Django and Django REST Framework
With your virtual environment activated, you can install Django and DRF using pip:

bash
pip install django
pip install djangorestframework
Step 4: Create a Django Project
Create a new Django project using the django-admin command:

bash
django-admin startproject myproject
cd myproject
Step 5: Create a Django App
Next, create an app within the project. Apps are the modular components of a Django project.

bash
python manage.py startapp myapp
Step 6: Configure Django to Use REST Framework
Add the rest_framework app to your INSTALLED_APPS in the settings.py file.

Open myproject/settings.py.
Find the INSTALLED_APPS list and add 'rest_framework' to it:
python
INSTALLED_APPS = [
    # Other apps...
    'rest_framework',
    'myapp',
]
Step 7: Create a Simple API View
Now let's create a simple API endpoint using Django REST Framework.

In the myapp directory, create a file called serializers.py to define the serialization of data.
python
# myapp/serializers.py

from rest_framework import serializers

class HelloWorldSerializer(serializers.Serializer):
    message = serializers.CharField(max_length=100)
In views.py, create a view that will return some data using the serializer.
python
# myapp/views.py

from rest_framework.views import APIView
from rest_framework.response import Response
from .serializers import HelloWorldSerializer

class HelloWorld(APIView):
    def get(self, request):
        data = {'message': 'Hello, world!'}
        serializer = HelloWorldSerializer(data)
        return Response(serializer.data)
In urls.py, create a URL route to link this view to an endpoint.
python
# myapp/urls.py

from django.urls import path
from .views import HelloWorld

urlpatterns = [
    path('hello/', HelloWorld.as_view(), name='hello_world'),
]
Now, link this urls.py to the main project URL configuration in myproject/urls.py.
python
# myproject/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('myapp.urls')),  # Include app URLs
]
Step 8: Run Migrations
Before running the server, you need to apply the initial database migrations:

bash
python manage.py migrate
Step 9: Start the Development Server
Now, you can start the development server:

bash
python manage.py runserver
Step 10: Access the API Endpoint
Open a web browser or use a tool like Postman or curl to access your newly created API endpoint:

ruby
http://127.0.0.1:8000/api/hello/
You should see the following response:

json
{
    "message": "Hello, world!"
}
Step 11: Add Additional Functionality (Optional)
You can add more complex API views, models, and serializers to create full-fledged REST APIs. For example, you could 
add model-based views, authentication, pagination, and permissions. DRF provides various tools to make this process 
easier, such as:

Viewsets and Routers for automated URL routing
Authentication for securing APIs
Permissions for controlling access to endpoints
Here's a quick example of using a ModelViewSet and a router:

Define a model in models.py:
python
# myapp/models.py

from django.db import models

class Item(models.Model):
    name = models.CharField(max_length=100)
    description = models.TextField()

    def __str__(self):
        return self.name
Create a serializer for the model:
python
# myapp/serializers.py

from rest_framework import serializers
from .models import Item

class ItemSerializer(serializers.ModelSerializer):
    class Meta:
        model = Item
        fields = '__all__'
Create a ModelViewSet in views.py:
python
# myapp/views.py

from rest_framework import viewsets
from .models import Item
from .serializers import ItemSerializer

class ItemViewSet(viewsets.ModelViewSet):
    queryset = Item.objects.all()
    serializer_class = ItemSerializer
Set up a router in urls.py:
python
# myapp/urls.py

from rest_framework.routers import DefaultRouter
from .views import ItemViewSet

router = DefaultRouter()
router.register(r'items', ItemViewSet)

urlpatterns = router.urls
Now, your API will have automatic CRUD functionality for the Item model at the /api/items/ endpoint.

Lab:
 Create a new Django project and app for managing doctor profiles.

To create a new Django project and app for managing doctor profiles, follow these steps. This guide assumes you 
already have Python and Django installed. If not, please install them first.

Step 1: Install Django (if not installed)
First, you need to install Django. If you haven't installed it yet, you can do so with the following command:

bash
pip install django
Step 2: Create a Django Project
Once Django is installed, you can create a new project using the django-admin command.

Open your terminal or command prompt.
Run the following command to create a new Django project:
bash
django-admin startproject doctor_profiles
This will create a new directory called doctor_profiles, which contains the basic structure of a Django project.

Navigate into the project directory:
bash
cd doctor_profiles
Step 3: Create a Django App for Managing Doctor Profiles
A Django project consists of one or more apps. You can create an app to handle doctor profiles.

To create the app, run the following command within your project directory:
bash
python manage.py startapp profiles
This will create a new directory called profiles inside the doctor_profiles project directory, which will contain 
all the necessary files for your app.

Step 4: Add the App to Installed Apps
To make Django recognize the new app, you need to add it to the INSTALLED_APPS setting.

Open the settings.py file located in the doctor_profiles directory.
Find the INSTALLED_APPS list and add 'profiles' to the list, like this:
python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'profiles',  # Add this line
]
Step 5: Define Doctor Profile Model
Now that the app is created, you can define a model for the doctor profile.

Open the models.py file inside the profiles directory.
Define a model for the doctor profile:
python
from django.db import models

class DoctorProfile(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField(unique=True)
    bio = models.TextField()
    profile_picture = models.ImageField(upload_to='doctor_profiles/', null=True, blank=True)
    
    def __str__(self):
        return f"Dr. {self.first_name} {self.last_name} ({self.specialty})"
Step 6: Create Database Migrations
To create the database table for the DoctorProfile model, you'll need to create and apply migrations.

Run the following command to create migrations for the profiles app:
bash
python manage.py makemigrations profiles
Apply the migrations to create the table in the database:
bash
python manage.py migrate
Step 7: Create Admin Interface (Optional)
To manage doctor profiles through Django's built-in admin interface, you'll need to register the model in admin.py.

Open admin.py in the profiles directory.
Register the DoctorProfile model:
python
from django.contrib import admin
from .models import DoctorProfile

admin.site.register(DoctorProfile)
Step 8: Run the Development Server
Now that everything is set up, you can start the Django development server to see the project in action.

Run the following command:
bash
python manage.py runserver
Open your browser and go to http://127.0.0.1:8000/admin. You can log in with the superuser account.
If you don't have a superuser account yet, create one by running:

bash
python manage.py createsuperuser
Then, log in to the admin panel and start managing doctor profiles!

Step 9: Optional - Create Views and Templates (for public access)
If you want to display doctor profiles to the public, you can create views and templates.

Open views.py inside the profiles app and add a view for listing doctors:
python
from django.shortcuts import render
from .models import DoctorProfile

def doctor_list(request):
    doctors = DoctorProfile.objects.all()
    return render(request, 'profiles/doctor_list.html', {'doctors': doctors})
Create a urls.py file in the profiles directory and add the URL pattern:
python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.doctor_list, name='doctor_list'),
]
Include the profiles URLs in the urls.py of the project (doctor_profiles/urls.py):
python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('doctors/', include('profiles.urls')),
]
Create a template for listing doctors (e.g., profiles/templates/profiles/doctor_list.html):
html
<!DOCTYPE html>
<html>
<head>
    <title>Doctor Profiles</title>
</head>
<body>
    <h1>Doctors</h1>
    <ul>
        {% for doctor in doctors %}
            <li>
                <strong>{{ doctor.first_name }} {{ doctor.last_name }}</strong><br>
                Specialty: {{ doctor.specialty }}<br>
                Phone: {{ doctor.phone_number }}<br>
                Email: {{ doctor.email }}<br>
                Bio: {{ doctor.bio }}<br>
                {% if doctor.profile_picture %}
                    <img src="{{ doctor.profile_picture.url }}" alt="{{ doctor.first_name }} {{ doctor.last_name }}">
                {% endif %}
            </li>
        {% endfor %}
    </ul>
</body>
</html>
Step 10: Test the Application
Now, navigate to http://127.0.0.1:8000/doctors/ in your browser to see the list of doctors you have added through the 
admin panel.

That's it! You've created a Django project and app for managing doctor profiles.

Practical Example: 9) Write a Django project to set up a new app called doctor_finder
and create models, serializers, and views.

To create a Django project with an app called doctor_finder, we will go through the steps of setting up the project, 
creating the app, defining models, creating serializers, and creating views to handle HTTP requests. I'll walk you 
through this in detail, and I'll provide code snippets to guide you.

Step-by-step Guide to Create a Django Project with the doctor_finder App:
1. Set up the Django Project
First, ensure you have Django installed. If you don't, install it via pip:

bash
pip install django
Create a new Django project:

bash
django-admin startproject doctor_project
cd doctor_project
Create a new Django app called doctor_finder:

bash
python manage.py startapp doctor_finder
Now, you will have the following structure:

markdown
doctor_project/
    doctor_finder/
        __init__.py
        admin.py
        apps.py
        models.py
        views.py
        tests.py
        urls.py
    doctor_project/
        __init__.py
        settings.py
        urls.py
        wsgi.py
    manage.py
2. Define Models for the doctor_finder App
In the doctor_finder/models.py file, define models for doctors and their specialties. Here's an example:

python
from django.db import models

class Specialty(models.Model):
    name = models.CharField(max_length=100)

    def __str__(self):
        return self.name

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.ForeignKey(Specialty, related_name='doctors', on_delete=models.CASCADE)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()
    available = models.BooleanField(default=True)

    def __str__(self):
        return f"{self.first_name} {self.last_name} - {self.specialty.name}"
Here, we define two models:

Specialty: Represents the medical specialty (e.g., Cardiology, Neurology).
Doctor: Represents a doctor, with fields for their name, specialty, contact info, and availability.
3. Create and Run Migrations
After defining the models, you need to make migrations and apply them to the database:

bash
python manage.py makemigrations
python manage.py migrate
4. Create Serializers
Serializers are needed to convert model instances to JSON and vice versa. Create a serializers.py file inside the 
doctor_finder app:

python
from rest_framework import serializers
from .models import Doctor, Specialty

class SpecialtySerializer(serializers.ModelSerializer):
    class Meta:
        model = Specialty
        fields = '__all__'

class DoctorSerializer(serializers.ModelSerializer):
    specialty = SpecialtySerializer()

    class Meta:
        model = Doctor
        fields = '__all__'
Here, we create two serializers:

SpecialtySerializer: Converts the Specialty model to JSON.
DoctorSerializer: Converts the Doctor model to JSON, including the Specialty serializer to show the doctor's specialty 
details.
5. Create Views
Next, we need to create views to handle requests. In the doctor_finder/views.py file, you can define the views using 
Django REST Framework's APIView or ViewSet. We'll use a ViewSet to handle CRUD operations for doctors:

python
from rest_framework import viewsets
from .models import Doctor
from .serializers import DoctorSerializer

class DoctorViewSet(viewsets.ModelViewSet):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
The DoctorViewSet allows CRUD operations on the Doctor model. It uses the DoctorSerializer to serialize the data.

6. Register the View in urls.py
You need to wire up the view to a URL in doctor_finder/urls.py. If this file does not exist, create it:

python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DoctorViewSet

router = DefaultRouter()
router.register(r'doctors', DoctorViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
Here, we are using a DefaultRouter from the Django REST framework to automatically generate routes for the DoctorViewSet.

7. Update the Main Project urls.py
In doctor_project/urls.py, include the doctor_finder app’s URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('doctor_finder.urls')),
]
This tells Django to route requests to api/ to the doctor_finder app.

8. Configure Django REST Framework in settings.py
Install Django REST Framework if you haven’t already:

bash
pip install djangorestframework
Add rest_framework and doctor_finder to the INSTALLED_APPS list in doctor_project/settings.py:

python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'doctor_finder',
]
9. Run the Server
Now, you can run the development server:

bash
python manage.py runserver
Your API should now be accessible at:

ruby
http://127.0.0.1:8000/api/doctors/
You can use tools like Postman or cURL to make GET, POST, PUT, and DELETE requests to interact with the Doctor model 
via the API.

10. Test the API
You can now test the endpoints using GET, POST, PUT, and DELETE methods.

For example:

GET /api/doctors/ – List all doctors.
POST /api/doctors/ – Create a new doctor.
PUT /api/doctors/{id}/ – Update an existing doctor.
DELETE /api/doctors/{id}/ – Delete a doctor.

10. Social Authentication, Email, and OTP Sending API
Theory:
 Implementing social authentication (e.g., Google, Facebook) in Django.

Implementing social authentication (such as Google or Facebook login) in Django is a popular method for allowing users to 
log in to your site using their social media accounts. To integrate social authentication, you typically use a 
third-party Django package such as django-allauth or social-auth-app-django. Below is a step-by-step guide on how to set 
up social authentication using django-allauth for both Google and Facebook.

1. Install Required Packages
First, install django-allauth and its dependencies:

bash
pip install django-allauth
2. Add allauth to Installed Apps
In your settings.py, add the following apps to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    # Other apps...
    'django.contrib.sites',  # Required by django-allauth
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',  # For Google authentication
    'allauth.socialaccount.providers.facebook',  # For Facebook authentication
]
3. Update Authentication Backends
Next, add the allauth authentication backend to the AUTHENTICATION_BACKENDS setting in settings.py:

python
AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend',  # Default Django backend
    'allauth.account.auth_backends.AuthenticationBackend',  # allauth backend
)
4. Configure Site ID
Django Allauth uses a Site model to manage different sites for authentication. Add the following to your settings.py:

python
SITE_ID = 1  # Typically, for a single site project, this is 1
5. Configure Social Authentication Settings
Add the required settings for django-allauth in settings.py:

python
# Redirect URLs after login/logout
LOGIN_REDIRECT_URL = '/'  # Adjust according to your app's URL structure
LOGOUT_REDIRECT_URL = '/'

# Optional allauth settings
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_EMAIL_VERIFICATION = "mandatory"
ACCOUNT_AUTHENTICATED_REDIRECT_URL = "/home/"  # After successful login
6. Add Social Authentication Keys for Google and Facebook
For Google and Facebook authentication, you'll need to obtain API keys and secrets from their respective developer 
platforms.

Google API
Go to Google Developer Console.
Create a new project.
Enable the "Google+ API" and "OAuth 2.0 Client IDs".
Configure your OAuth consent screen.
Create OAuth credentials and note the client ID and client secret.
Facebook API
Go to Facebook Developer Console.
Create a new app.
Set up Facebook Login and get the App ID and App Secret.
Add these API credentials to your settings.py:

python
SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = 'your-google-client-id'
SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = 'your-google-client-secret'

SOCIAL_AUTH_FACEBOOK_KEY = 'your-facebook-app-id'
SOCIAL_AUTH_FACEBOOK_SECRET = 'your-facebook-app-secret'
7. URLs Configuration
In your project's urls.py, include django-allauth's URLs:

python
from django.urls import path, include

urlpatterns = [
    # Your other URL patterns
    path('accounts/', include('allauth.urls')),  # allauth URLs
]
8. Migrate Database
Run the migrations to create the necessary tables for django-allauth:

bash
python manage.py migrate
9. Create Social Accounts in Admin
After running migrations, go to the Django admin panel (/admin) and create a Social Application for both Google and 
Facebook under the Social Accounts section.

For Google, create a Social Application and select Google as the provider. Add your app's site (which you configured as 
SITE_ID = 1).
For Facebook, create a Social Application and select Facebook as the provider.
10. Add Templates for Social Authentication (Optional)
You can add templates for social login (e.g., login buttons) in your app. django-allauth provides default templates, 
but you can override them if necessary.

For example, if you want to customize the login page, create the following in your app:

html
{% extends "base_generic.html" %}

{% block content %}
  <h1>Login</h1>
  <a href="{% provider_login_url 'google' %}">Login with Google</a>
  <a href="{% provider_login_url 'facebook' %}">Login with Facebook</a>
{% endblock %}
11. Test the Authentication Flow
Once everything is set up, navigate to /accounts/login/ on your website. You should see options to log in with 
Google or Facebook. Clicking on them will redirect to the respective authentication provider, and upon successful 
authentication, the user will be logged into your site.

 Sending emails and OTPs using third-party APIs like Twilio, SendGrid.

Sending emails and OTPs (One-Time Passwords) through third-party APIs like Twilio (for SMS/OTP) and SendGrid (for email) 
is a common practice for many applications to ensure secure, reliable, and scalable communication.

Here’s a brief overview of how you can use both APIs:

1. Twilio for Sending OTPs via SMS
Twilio provides services to send SMS, make calls, and send OTPs for user authentication. It’s simple to integrate and 
is widely used for SMS-based communication.

Steps to send OTP via Twilio:
Sign up for Twilio:

Go to Twilio's website and create an account.
After signing up, you will get a Twilio phone number and API credentials (Account SID and Auth Token).
Install Twilio SDK:

You can install the Twilio SDK in your project using pip (for Python) or through other language-specific methods.
For Python:

bash
pip install twilio
Send OTP via Twilio: Here’s an example in Python:

python
from twilio.rest import Client
import random

# Twilio API credentials
account_sid = 'your_account_sid'
auth_token = 'your_auth_token'

# Initialize Twilio Client
client = Client(account_sid, auth_token)

# Generate a random OTP (6 digits)
otp = random.randint(100000, 999999)

# Send SMS
message = client.messages.create(
    body=f"Your OTP is: {otp}",
    from_='+1xxxxxxxxxx',  # Your Twilio phone number
    to='+91xxxxxxxxxx'     # Receiver's phone number
)

print(f"OTP sent: {otp}")
Replace 'your_account_sid', 'your_auth_token', and phone numbers with your actual details.
Twilio will send an SMS with the OTP to the specified phone number.
2. SendGrid for Sending Emails
SendGrid is used for sending transactional emails such as registration confirmation, password resets, and OTP emails.

Steps to send email via SendGrid:
Sign up for SendGrid:

Go to SendGrid's website and create an account.
After signing up, you will get API Key and can create a verified sender identity (i.e., the email address you'll be 
sending from).
Install SendGrid SDK: You can install the SendGrid SDK in your project.

For Python:

bash
pip install sendgrid
Send email via SendGrid: Here’s an example of sending an email using Python and SendGrid:

python
import sendgrid
from sendgrid.helpers.mail import Mail, Email, To, Content

# SendGrid API Key
sendgrid_api_key = 'your_sendgrid_api_key'

# Initialize SendGrid client
sg = sendgrid.SendGridAPIClient(api_key=sendgrid_api_key)

# Compose email
from_email = Email("your-email@example.com")  # Verified sender email
to_email = To("recipient-email@example.com")  # Recipient email
subject = "Your OTP Code"
content = Content("text/plain", "Your OTP code is: 123456")

# Create email object
mail = Mail(from_email, to_email, subject, content)

# Send email
response = sg.send(mail)

# Print status
print(response.status_code)
print(response.body)
print(response.headers)
Replace 'your_sendgrid_api_key', 'your-email@example.com', and 'recipient-email@example.com' with actual details.
This will send an email with the OTP code to the specified recipient.
Key Differences:
Twilio is used for SMS communication, typically for sending OTPs for authentication.
SendGrid is used for email communication, suitable for sending OTPs via email and other transactional email notifications.
Best Practices:
Use Environment Variables for storing sensitive information like API keys (instead of hardcoding them in your source code).
Rate Limiting: Be mindful of the API limits and costs associated with sending messages through these services.
Two-Factor Authentication (2FA): OTPs should be used in a secure, time-sensitive manner for authentication purposes.
Both services offer excellent documentation and SDKs for various programming languages to simplify integration into your 
application.

Lab:
 Add Google login to a Django project using django-allauth.

To add Google login to a Django project using django-allauth, you need to follow several steps. django-allauth is a 
popular authentication system that supports third-party logins like Google, Facebook, GitHub, and others. Here's how 
you can integrate Google login into your Django project:

Step 1: Install Required Packages
First, make sure you have the necessary packages installed:

django-allauth – to handle social authentication.
requests – a required dependency for API calls to Google.
You can install these with pip:

bash
pip install django-allauth requests
Step 2: Add Allauth to INSTALLED_APPS
In your settings.py file, add the required apps for django-allauth:

python
INSTALLED_APPS = [
    # Other apps
    'django.contrib.sites',  # Required for django-allauth
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',  # Google login provider
]
Make sure you also have 'django.contrib.sites' included, as django-allauth uses the Django Sites framework.

Step 3: Configure Authentication Backends
Still in your settings.py, configure the authentication backends. Add the following to the AUTHENTICATION_BACKENDS 
setting:

python
AUTHENTICATION_BACKENDS = (
    'allauth.account.auth_backends.AuthenticationBackend',
)
Step 4: Set Site ID
You will need to specify the SITE_ID to link the application with the Django Sites framework. Set it to 1 for the 
default site.

python
SITE_ID = 1
Step 5: Configure Google OAuth2 Credentials
You need to create OAuth2 credentials for Google login. Follow these steps:

Go to the Google Developer Console.
Create a new project (or use an existing project).
Navigate to APIs & Services > Credentials.
Click on Create Credentials and select OAuth 2.0 Client IDs.
Set the application type to Web Application.
Under Authorized redirect URIs, add the redirect URI:
ruby
http://localhost:8000/accounts/google/login/callback/
After creating the credentials, note down the Client ID and Client Secret.
Step 6: Add Google OAuth2 Credentials to Django Settings
Now, you need to add these credentials in your settings.py:

python
SOCIAL_AUTH_GOOGLE_OAUTH2_KEY = '<YOUR_GOOGLE_CLIENT_ID>'
SOCIAL_AUTH_GOOGLE_OAUTH2_SECRET = '<YOUR_GOOGLE_CLIENT_SECRET>'
Step 7: Add URL Patterns
In your urls.py, include the allauth URLs for authentication:

python
from django.urls import path, include

urlpatterns = [
    path('accounts/', include('allauth.urls')),  # Allauth URLs
]
This will handle the routes for login, logout, registration, and social login.

Step 8: Configure Templates (Optional)
django-allauth provides default templates for authentication, but you can override them to customize the appearance. 
Add the following to your settings.py if you want to use your custom templates:

python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],  # Your templates directory
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'allauth.account.context_processors.account',
                'allauth.socialaccount.context_processors.socialaccount',
            ],
        },
    },
]
Create a templates/account directory and override the necessary templates, such as login.html and signup.html, if needed.

Step 9: Migrate Database
Run migrations to set up the necessary tables for django-allauth:

bash
python manage.py migrate
Step 10: Test Google Login
Start the development server:

bash
python manage.py runserver
Visit http://localhost:8000/accounts/login/ in your browser. You should see the Google login button there. When you 
click it, you will be redirected to Google's login page. After logging in, you'll be redirected back to your site and 
logged in with your Google account.

Additional Configuration
If you want to enable additional features, like email verification, configure django-allauth in the settings.py file. 
For instance, to require email verification:
python
ACCOUNT_EMAIL_VERIFICATION = 'mandatory'
ACCOUNT_EMAIL_REQUIRED = True
You can also configure the login/logout redirection by setting:
python
LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/'
This will redirect users to the homepage after logging in or logging out.

Practical Example: 10) Write a Django project that integrates Google login and sends OTPs to users using Twilio.

To build a Django project that integrates Google login and sends OTPs to users using Twilio, we'll go through several 
steps. The project will consist of:

Setting up a Django project.
Integrating Google login with django-allauth.
Sending OTPs using Twilio.
Handling OTP verification.
Let's break this down:

Step 1: Setting up the Django Project
First, create a new Django project if you haven't already:

bash
# Create and activate a virtual environment
python3 -m venv env
source env/bin/activate  # On Windows use `env\Scripts\activate`

# Install Django
pip install django

# Create a new Django project
django-admin startproject google_otp_project

# Move into the project directory
cd google_otp_project

# Create a Django app
python manage.py startapp users

# Install required packages for Google login and Twilio
pip install django-allauth twilio
Now, add the necessary apps and configurations in settings.py:

python
# settings.py

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'users',  # Your app
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',  # Google login provider
]

AUTHENTICATION_BACKENDS = (
    'allauth.account.auth_backends.AuthenticationBackend',
)

# Configure allauth
SITE_ID = 1
LOGIN_REDIRECT_URL = '/'  # Where to redirect after successful login

# Twilio settings (you'll replace these with your own credentials)
TWILIO_PHONE_NUMBER = 'your_twilio_phone_number'
TWILIO_ACCOUNT_SID = 'your_twilio_account_sid'
TWILIO_AUTH_TOKEN = 'your_twilio_auth_token'
Step 2: Integrating Google Login
In urls.py, you need to add paths for Google login:

python
# google_otp_project/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('allauth.urls')),  # Allauth URLs for authentication
]
Next, configure your Google login credentials in the Google Developer Console. You will need to create a new OAuth 2.0 
client ID for your project and set up the redirect URIs. After that, add the credentials to the Django settings:

python
# settings.py

SOCIAL_AUTH_GOOGLE_CLIENT_ID = 'your-client-id.apps.googleusercontent.com'
SOCIAL_AUTH_GOOGLE_SECRET = 'your-client-secret'
Once this is done, you can now navigate to /accounts/login/ in your browser, and you should see the option to log in 
via Google.

Step 3: Sending OTPs using Twilio
Create a utility function to send OTPs via Twilio. First, you need to configure Twilio in your views.py or a separate 
file:

python
# utils.py
from twilio.rest import Client
import random

def send_otp(phone_number):
    otp = random.randint(1000, 9999)
    
    # Twilio client setup
    client = Client('your_twilio_account_sid', 'your_twilio_auth_token')
    
    message = client.messages.create(
        body=f"Your OTP is {otp}",
        from_='your_twilio_phone_number',
        to=phone_number
    )
    
    return otp  # Return the OTP for verification purposes
Now, you can use this function to send OTPs when a user registers or logs in via Google.

Step 4: Handling OTP Verification
Create a view that will handle OTP verification and store the OTP temporarily (you can use the session for simplicity). 
Here is an example of how to handle OTP verification:

python
# views.py
from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from .utils import send_otp
from django.contrib import messages

@login_required
def send_otp_view(request):
    if request.method == 'POST':
        phone_number = request.POST.get('phone_number')
        otp = send_otp(phone_number)
        
        # Store OTP in session for verification
        request.session['otp'] = otp
        request.session['phone_number'] = phone_number
        
        messages.success(request, "OTP sent successfully.")
        return redirect('verify_otp')

    return render(request, 'send_otp.html')


@login_required
def verify_otp_view(request):
    if request.method == 'POST':
        user_otp = request.POST.get('otp')
        stored_otp = request.session.get('otp')
        
        if str(user_otp) == str(stored_otp):
            messages.success(request, "OTP verified successfully.")
            return redirect('home')  # Redirect to home or profile
        else:
            messages.error(request, "Invalid OTP. Please try again.")
    
    return render(request, 'verify_otp.html')
Step 5: Templates for OTP Pages
Create templates send_otp.html and verify_otp.html to handle OTP submission and verification.

send_otp.html:
html
<form method="POST">
    {% csrf_token %}
    <label for="phone_number">Phone Number:</label>
    <input type="text" name="phone_number" id="phone_number" required>
    <button type="submit">Send OTP</button>
</form>
verify_otp.html:
html
<form method="POST">
    {% csrf_token %}
    <label for="otp">Enter OTP:</label>
    <input type="text" name="otp" id="otp" required>
    <button type="submit">Verify OTP</button>
</form>
Step 6: Testing the Application
Run the Django development server:

bash
python manage.py runserver
Visit /accounts/login/ to log in with Google.
After logging in, visit /send-otp/ to send an OTP to your phone.
Enter the OTP at /verify-otp/ to verify it.

11. RESTful API Design
Theory:
 REST principles: statelessness, resource-based URLs, and using HTTP methods for CRUD operations.

REST (Representational State Transfer) is an architectural style for designing networked applications, typically using 
HTTP for communication. It is based on a set of principles that enable scalability, simplicity, and performance in 
web services. Here’s a breakdown of the key REST principles you mentioned:

1. Statelessness
Definition: In REST, the server does not store any state of the client between requests. Every request from the client to 
the server must contain all the information needed to understand and process the request.
Implication: Each request is independent, and the server does not rely on any prior request from the client. 
This ensures that the system is scalable and can handle a large number of requests since no session information needs to be maintained between requests.
Example: If a client needs to access a resource, it must include all the necessary information (e.g., authentication 
credentials, request data) in the request. The server will process it as if it's a new, independent request.
2. Resource-Based URLs
Definition: In REST, resources (like data or objects) are identified by URLs (Uniform Resource Locators). 
Each resource should have a unique URL, and these URLs should be designed to represent the entities of the system.
Implication: The URL structure should be simple, intuitive, and represent the object model in a hierarchical way. 
The focus is on the resource itself, not the actions to be performed on it.
Example:
/users: Represents a collection of user resources.
/users/{id}: Represents a specific user resource identified by id.
/products/{id}/reviews: Represents the reviews associated with a specific product.
3. Using HTTP Methods for CRUD Operations
Definition: REST uses standard HTTP methods to perform CRUD (Create, Read, Update, Delete) operations on resources. 
These methods map directly to the basic operations that can be performed on resources.
GET: Retrieve data from the server (Read operation).
POST: Send data to the server to create a new resource (Create operation).
PUT: Update an existing resource with new data (Update operation).
DELETE: Remove a resource from the server (Delete operation).
Implication: The client and server communicate using standard HTTP methods, which are self-explanatory and widely 
understood, promoting interoperability and simplicity.
Example:
GET /users/123: Retrieves the user with ID 123.
POST /users: Creates a new user resource.
PUT /users/123: Updates the user with ID 123.
DELETE /users/123: Deletes the user with ID 123.
Summary of REST Principles
Statelessness: Each request is independent and self-contained.
Resource-Based URLs: Resources are uniquely identified by URLs, and the URLs should reflect the structure of the data.
HTTP Methods for CRUD: REST uses HTTP methods (GET, POST, PUT, DELETE) to perform CRUD operations on resources.
These principles make RESTful APIs scalable, easy to understand, and efficient to use across different platforms and 
systems.

Lab:
 Design a REST API for managing doctor profiles using Django REST Framework.

Designing a REST API for managing doctor profiles using Django REST Framework (DRF) involves several steps. Below is a 
step-by-step guide to help you design the API, which includes creating models, serializers, views, and URLs.

Step 1: Setting Up the Django Project
First, ensure that you have Django and Django REST Framework installed. If not, you can install them via pip:

bash
pip install django djangorestframework
Create a new Django project:
bash
django-admin startproject doctor_management
cd doctor_management
Create a new Django app for managing doctor profiles:
bash
python manage.py startapp doctors
Add rest_framework and the doctors app to INSTALLED_APPS in your settings.py:
python
INSTALLED_APPS = [
    ...
    'rest_framework',
    'doctors',
]
Step 2: Create the Doctor Model
In your doctors/models.py, define a model for the doctor profile:

python
from django.db import models

class Doctor(models.Model):
    SPECIALIZATION_CHOICES = [
        ('GP', 'General Practitioner'),
        ('CARD', 'Cardiologist'),
        ('DERM', 'Dermatologist'),
        ('NEURO', 'Neurologist'),
        ('ORTHO', 'Orthopedist'),
        # Add more specializations as needed
    ]
    
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    email = models.EmailField(unique=True)
    phone_number = models.CharField(max_length=15)
    specialization = models.CharField(max_length=10, choices=SPECIALIZATION_CHOICES)
    experience_years = models.IntegerField()
    bio = models.TextField()
    profile_picture = models.ImageField(upload_to='doctor_profiles/', null=True, blank=True)

    def __str__(self):
        return f"{self.first_name} {self.last_name}"
This model contains the following fields:

first_name and last_name: The doctor's name.
email: The email address of the doctor, which should be unique.
phone_number: Contact number for the doctor.
specialization: The field to specify the doctor's area of expertise.
experience_years: Number of years the doctor has been practicing.
bio: A text field to store the doctor's biography or description.
profile_picture: An optional field for uploading a profile image.
Step 3: Create the Serializer
In Django REST Framework, serializers convert model instances to JSON format. Create a serializer for the Doctor 
model in doctors/serializers.py:

python
from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = ['id', 'first_name', 'last_name', 'email', 'phone_number', 'specialization', 'experience_years', 'bio', 
'profile_picture']
This serializer will convert the Doctor model data to and from JSON format.

Step 4: Create Views
In this step, we will create the views that handle the API requests for CRUD operations (Create, Read, Update, Delete).

In doctors/views.py, create the following views:

python
from rest_framework import generics
from .models import Doctor
from .serializers import DoctorSerializer

# List all doctors or create a new one
class DoctorListCreateView(generics.ListCreateAPIView):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer

# Retrieve, update, or delete a specific doctor
class DoctorDetailView(generics.RetrieveUpdateDestroyAPIView):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
DoctorListCreateView: This view handles GET (list all doctors) and POST (create a new doctor) requests.
DoctorDetailView: This view handles GET (retrieve a doctor), PUT/PATCH (update a doctor), and DELETE (delete a doctor) 
requests.
Step 5: Define the URLs
Now, define the URLs for your views in doctors/urls.py. This file will include the API endpoint routes.

python
from django.urls import path
from .views import DoctorListCreateView, DoctorDetailView

urlpatterns = [
    path('doctors/', DoctorListCreateView.as_view(), name='doctor-list-create'),
    path('doctors/<int:pk>/', DoctorDetailView.as_view(), name='doctor-detail'),
]
doctors/: Handles listing and creating doctors.
doctors/<int:pk>/: Handles retrieving, updating, and deleting a specific doctor.
Step 6: Add the App URLs to the Main Project URLs
In doctor_management/urls.py, include the doctors app URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('doctors.urls')),  # Add the doctors app URLs
]
Step 7: Migrate the Database
Run the migrations to create the database tables for the Doctor model:

bash
python manage.py makemigrations
python manage.py migrate
Step 8: Test the API
You can now run the Django development server:

bash
python manage.py runserver
You can use tools like Postman or Curl to test the following API endpoints:

GET /api/doctors/: List all doctors.
POST /api/doctors/: Create a new doctor profile. You need to send a JSON body with doctor details.
GET /api/doctors/{id}/: Get details of a specific doctor by ID.
PUT/PATCH /api/doctors/{id}/: Update the details of a specific doctor.
DELETE /api/doctors/{id}/: Delete a specific doctor profile.
Example of a JSON request to create a new doctor (POST /api/doctors/):
json
{
    "first_name": "John",
    "last_name": "Doe",
    "email": "john.doe@example.com",
    "phone_number": "+1234567890",
    "specialization": "CARD",
    "experience_years": 10,
    "bio": "Dr. John Doe is a highly experienced cardiologist.",
    "profile_picture": "http://example.com/path/to/profile.jpg"
}
Optional Enhancements
Authentication and Permissions: You can add authentication (e.g., Token-based or JWT) and permissions to protect 
access to the API.
Pagination: Implement pagination in the DoctorListCreateView to limit the number of doctors shown per page.
Search and Filters: You can add filtering capabilities to search for doctors by specialization, name, etc.
File Handling: Use django-rest-framework's support for file uploads if the profile_picture is uploaded with a 
multipart/form-data request.

Practical Example: 11) Write a Django REST API with endpoints for creating, reading, updating, and deleting doctors.

To create a simple Django REST API for managing doctors (with CRUD operations: Create, Read, Update, and Delete), 
you will need to follow these steps:

Install Django and Django REST Framework (DRF): If you haven't already installed Django and DRF, you can install them 
via pip:

bash
pip install django djangorestframework
Create a Django Project: If you haven't created a Django project yet, create one using the following command:

bash
django-admin startproject doctorapi
Create a Django App for Doctors: Inside your project folder (doctorapi), create an app for managing doctors:

bash
cd doctorapi
python manage.py startapp doctors
Set Up Models for Doctor: In the doctors app, create a Doctor model to represent the data structure for doctors. 
Edit the models.py in the doctors app:

python
# doctors/models.py

from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()

    def __str__(self):
        return f"{self.first_name} {self.last_name}"
Migrate the Database: Apply the migration to create the database table for the Doctor model:

bash
python manage.py makemigrations
python manage.py migrate
Create a Serializer: Next, create a serializer for the Doctor model in the doctors app. The serializer will define 
how to convert model instances into JSON format (for API responses) and how to handle incoming data for creating and 
updating objects.

Create a new file serializers.py inside the doctors app:

python
# doctors/serializers.py

from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = '__all__'
Create Views for CRUD Operations: Now, create views to handle CRUD operations using Django REST Framework's APIView or 
ViewSet. Here, we'll use a ViewSet for convenience, as it supports all CRUD operations automatically.

Edit the views.py in the doctors app:

python
# doctors/views.py

from rest_framework import viewsets
from .models import Doctor
from .serializers import DoctorSerializer

class DoctorViewSet(viewsets.ModelViewSet):
    queryset = Doctor.objects.all()
    serializer_class = DoctorSerializer
The DoctorViewSet automatically provides methods for handling create, retrieve, update, and delete actions based on 
the ModelViewSet.
Set Up URLs: Set up the URL routing to expose the DoctorViewSet via the API. In the doctors app, create a urls.py file:

python
# doctors/urls.py

from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DoctorViewSet

router = DefaultRouter()
router.register(r'doctors', DoctorViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
Then, include these URLs in the project's main urls.py:

python
# doctorapi/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('doctors.urls')),  # Include the doctors API URLs
]
Enable Django REST Framework: Add 'rest_framework' and 'doctors' to the INSTALLED_APPS in settings.py:

python
# doctorapi/settings.py

INSTALLED_APPS = [
    # Other apps
    'rest_framework',
    'doctors',
]
Run the Server: Now, run the Django development server:

bash
python manage.py runserver
The API will be available at http://127.0.0.1:8000/api/doctors/.

API Endpoints
With the above setup, the following CRUD operations are automatically available:

Create: POST /api/doctors/ — Create a new doctor.
Read: GET /api/doctors/ — List all doctors.
Read (Single): GET /api/doctors/{id}/ — Retrieve a single doctor by ID.
Update: PUT /api/doctors/{id}/ — Update a doctor by ID.
Delete: DELETE /api/doctors/{id}/ — Delete a doctor by ID.
Example API Requests
Create a Doctor (POST request to /api/doctors/):

json
{
    "first_name": "John",
    "last_name": "Doe",
    "specialty": "Cardiology",
    "phone_number": "1234567890",
    "email": "john.doe@example.com"
}
Update a Doctor (PUT request to /api/doctors/{id}/):

json
{
    "first_name": "John",
    "last_name": "Doe",
    "specialty": "Neurology",
    "phone_number": "0987654321",
    "email": "john.doe@example.com"
}

12. CRUD API (Create, Read, Update, Delete)
Theory:
 What is CRUD, and why is it fundamental to backend development?

What is CRUD?
CRUD stands for Create, Read, Update, and Delete. These are the four basic operations that are performed on data in 
most database systems or data storage applications. Here's a breakdown of each operation:

Create: This operation is used to insert new data into a database. It is responsible for adding records (rows) to a table 
or a collection.

Read: This operation involves retrieving or fetching data from the database. It allows for querying the data to view or 
display specific information.

Update: This operation modifies existing data in the database. It is used to change specific attributes or fields of a 
record.

Delete: This operation removes data from the database, either by deleting a single record or a group of records.

Why is CRUD Fundamental to Backend Development?
CRUD is fundamental to backend development for several reasons:

Core of Data Management: Every application that stores or processes data needs to handle these four operations. 
Without CRUD, an application wouldn't be able to perform basic actions like saving user information, displaying content, 
or making updates to records.

Interacts with Databases: Backend development often revolves around interacting with databases, and CRUD operations are 
the foundation for this interaction. Whether it's a relational database (SQL) or a NoSQL database, CRUD is essential for 
managing data.

RESTful API Design: In the context of building REST APIs, CRUD operations map directly to HTTP methods:

Create corresponds to POST
Read corresponds to GET
Update corresponds to PUT or PATCH
Delete corresponds to DELETE
Understanding CRUD allows developers to design and structure RESTful APIs effectively.

Data Integrity and Structure: CRUD ensures that data is managed systematically, ensuring that records can be added, 
viewed, changed, or removed based on user interactions. This systematic approach helps maintain data integrity.

Scalability and Flexibility: A well-implemented CRUD system enables scaling an application easily. It is easier to extend 
an application when CRUD operations are well defined, especially when handling large datasets or adding new features.

Simplicity in Testing and Maintenance: When CRUD operations are clearly defined, the backend system is more 
straightforward to test and maintain. These operations form the basic structure for more complex functionalities, 
making debugging and upgrades easier.

In summary, CRUD operations are the backbone of data management in backend development. Understanding and implementing 
them effectively is crucial for creating efficient, maintainable, and scalable applications.

Lab:
 Implement a CRUD API using Django REST Framework for doctor profiles.

To implement a CRUD (Create, Read, Update, Delete) API for doctor profiles using Django REST Framework (DRF), 
follow these steps:

Step 1: Set Up Your Django Project
First, make sure you have Django and Django REST Framework installed. You can install them using pip:

bash
pip install django djangorestframework
Now, create a new Django project and a new app for the doctor profiles.

bash
django-admin startproject doctor_profiles_project
cd doctor_profiles_project
django-admin startapp profiles
Step 2: Add rest_framework and the profiles App to INSTALLED_APPS
In your settings.py, add rest_framework and profiles to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    # Other default apps
    'rest_framework',
    'profiles',  # Your app
]
Step 3: Define the Doctor Model
In profiles/models.py, define the DoctorProfile model:

python
from django.db import models

class DoctorProfile(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialty = models.CharField(max_length=100)
    phone_number = models.CharField(max_length=15)
    email = models.EmailField()
    bio = models.TextField()
    experience_years = models.IntegerField()

    def __str__(self):
        return f"Dr. {self.first_name} {self.last_name} ({self.specialty})"
Step 4: Create and Apply Migrations
Generate and apply migrations for your DoctorProfile model:

bash
python manage.py makemigrations
python manage.py migrate
Step 5: Create a Serializer
In profiles/serializers.py, create a serializer for the DoctorProfile model:

python
from rest_framework import serializers
from .models import DoctorProfile

class DoctorProfileSerializer(serializers.ModelSerializer):
    class Meta:
        model = DoctorProfile
        fields = ['id', 'first_name', 'last_name', 'specialty', 'phone_number', 'email', 'bio', 'experience_years']
Step 6: Create Views for CRUD Operations
In profiles/views.py, create views for CRUD operations using DRF’s APIView or viewsets. Here’s an example using 
ModelViewSet to handle all CRUD operations.

python
from rest_framework import viewsets
from .models import DoctorProfile
from .serializers import DoctorProfileSerializer

class DoctorProfileViewSet(viewsets.ModelViewSet):
    queryset = DoctorProfile.objects.all()
    serializer_class = DoctorProfileSerializer
Step 7: Configure URLs
In profiles/urls.py, create the routes for the DoctorProfileViewSet.

python
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import DoctorProfileViewSet

router = DefaultRouter()
router.register(r'doctors', DoctorProfileViewSet)

urlpatterns = [
    path('', include(router.urls)),
]
Step 8: Add the Profiles URLs to the Main URL Configuration
In your project’s urls.py, include the profiles app URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('profiles.urls')),  # API endpoint
]
Step 9: Test the API
Now you can test the CRUD operations using the Django development server.

bash
python manage.py runserver
Your API will be available at http://127.0.0.1:8000/api/doctors/. The available HTTP methods for each endpoint will be:

GET: List all doctor profiles or retrieve a specific doctor profile by ID.
POST: Create a new doctor profile.
PUT/PATCH: Update an existing doctor profile.
DELETE: Delete a doctor profile.
Example cURL Commands to Test the API
Create a new doctor profile (POST):
bash
curl -X POST http://127.0.0.1:8000/api/doctors/ \
    -H "Content-Type: application/json" \
    -d '{"first_name": "John", "last_name": "Doe", "specialty": "Cardiology", "phone_number": "123-456-7890", "email": 
"johndoe@example.com", "bio": "Experienced cardiologist.", "experience_years": 10}'
Get all doctor profiles (GET):
bash
curl http://127.0.0.1:8000/api/doctors/
Get a specific doctor profile by ID (GET):
bash
curl http://127.0.0.1:8000/api/doctors/1/
Update a doctor profile (PUT):
bash
curl -X PUT http://127.0.0.1:8000/api/doctors/1/ \
    -H "Content-Type: application/json" \
    -d '{"first_name": "John", "last_name": "Doe", "specialty": "Cardiology", "phone_number": "123-456-7890", 
"email": "john_doe_updated@example.com", "bio": "Experienced cardiologist with 15 years.", "experience_years": 15}'
Delete a doctor profile (DELETE):
bash
curl -X DELETE http://127.0.0.1:8000/api/doctors/1/
Step 10: Optional - Permissions and Authentication
If you need to add authentication and permissions (e.g., only authenticated users can access or modify the profiles), 
you can modify your views by adding DRF permissions:

python
from rest_framework.permissions import IsAuthenticated

class DoctorProfileViewSet(viewsets.ModelViewSet):
    queryset = DoctorProfile.objects.all()
    serializer_class = DoctorProfileSerializer
    permission_classes = [IsAuthenticated]
This will require the user to authenticate before interacting with the API.

Practical Example: 12) Write a Django project that allows users to create, read, update, and delete doctor profiles 
using API endpoints.

Creating a Django project that allows users to create, read, update, and delete doctor profiles using API endpoints 
involves several steps. We will use Django Rest Framework (DRF) to handle the API endpoints. Here’s a step-by-step 
guide on how to build this project.

Step 1: Install Dependencies
First, we need to install Django and Django Rest Framework.

bash
pip install django djangorestframework
Step 2: Create a Django Project
Now, create a new Django project and a new app to handle doctor profiles.

bash
django-admin startproject doctor_profiles
cd doctor_profiles
python manage.py startapp doctors
Step 3: Add the App and Rest Framework to Installed Apps
In the doctor_profiles/settings.py file, add rest_framework and doctors to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',
    'doctors',  # Add the doctors app
]
Step 4: Create the Doctor Model
In the doctors/models.py file, define a model for the doctor profile:

python
from django.db import models

class Doctor(models.Model):
    first_name = models.CharField(max_length=100)
    last_name = models.CharField(max_length=100)
    specialization = models.CharField(max_length=100)
    contact_number = models.CharField(max_length=15)
    email = models.EmailField(unique=True)
    bio = models.TextField()

    def __str__(self):
        return f"{self.first_name} {self.last_name} ({self.specialization})"
Step 5: Create and Run Migrations
Create the database tables by running migrations.

bash
python manage.py makemigrations
python manage.py migrate
Step 6: Create a Serializer
In the doctors/serializers.py file, create a serializer for the Doctor model. This will convert model instances into 
JSON format for API responses and validate incoming data.

python
from rest_framework import serializers
from .models import Doctor

class DoctorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Doctor
        fields = '__all__'  # Include all fields in the serialization
Step 7: Create Views for API Endpoints
In the doctors/views.py file, create views that handle the CRUD operations (Create, Read, Update, and Delete).

python
from rest_framework import status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from .models import Doctor
from .serializers import DoctorSerializer

# Create Doctor
@api_view(['POST'])
def create_doctor(request):
    if request.method == 'POST':
        serializer = DoctorSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

# Get Doctor by ID
@api_view(['GET'])
def get_doctor(request, pk):
    try:
        doctor = Doctor.objects.get(pk=pk)
    except Doctor.DoesNotExist:
        return Response({'message': 'Doctor not found'}, status=status.HTTP_404_NOT_FOUND)
    
    if request.method == 'GET':
        serializer = DoctorSerializer(doctor)
        return Response(serializer.data)

# Update Doctor
@api_view(['PUT'])
def update_doctor(request, pk):
    try:
        doctor = Doctor.objects.get(pk=pk)
    except Doctor.DoesNotExist:
        return Response({'message': 'Doctor not found'}, status=status.HTTP_404_NOT_FOUND)

    if request.method == 'PUT':
        serializer = DoctorSerializer(doctor, data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

# Delete Doctor
@api_view(['DELETE'])
def delete_doctor(request, pk):
    try:
        doctor = Doctor.objects.get(pk=pk)
    except Doctor.DoesNotExist:
        return Response({'message': 'Doctor not found'}, status=status.HTTP_404_NOT_FOUND)
    
    if request.method == 'DELETE':
        doctor.delete()
        return Response({'message': 'Doctor profile deleted successfully'}, status=status.HTTP_204_NO_CONTENT)

# Get All Doctors
@api_view(['GET'])
def list_doctors(request):
    if request.method == 'GET':
        doctors = Doctor.objects.all()
        serializer = DoctorSerializer(doctors, many=True)
        return Response(serializer.data)
Step 8: Configure URLs
In the doctors/urls.py file, define URL patterns for each API endpoint.

python
from django.urls import path
from . import views

urlpatterns = [
    path('doctors/', views.list_doctors, name='list_doctors'),
    path('doctors/<int:pk>/', views.get_doctor, name='get_doctor'),
    path('doctors/create/', views.create_doctor, name='create_doctor'),
    path('doctors/<int:pk>/update/', views.update_doctor, name='update_doctor'),
    path('doctors/<int:pk>/delete/', views.delete_doctor, name='delete_doctor'),
]
In the main doctor_profiles/urls.py, include the doctors app URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('doctors.urls')),
]
Step 9: Set Up the Django Admin (Optional)
To make it easier to manage doctor profiles via the Django admin interface, register the Doctor model in 
doctors/admin.py.

python
from django.contrib import admin
from .models import Doctor

admin.site.register(Doctor)
Step 10: Run the Django Development Server
Now, you can run the development server.

bash
python manage.py runserver
The API endpoints should now be available at:

List all doctors: GET /api/doctors/
Get doctor by ID: GET /api/doctors/<id>/
Create a new doctor: POST /api/doctors/create/
Update a doctor: PUT /api/doctors/<id>/update/
Delete a doctor: DELETE /api/doctors/<id>/delete/
Step 11: Test the API Endpoints
You can test the API endpoints using tools like Postman or cURL. You can also use Django’s built-in admin interface 
to add, update, or delete doctors manually.

Example API Requests:
Create a doctor:

Method: POST
URL: /api/doctors/create/
Body:
json
{
  "first_name": "John",
  "last_name": "Doe",
  "specialization": "Cardiologist",
  "contact_number": "1234567890",
  "email": "john.doe@example.com",
  "bio": "Experienced cardiologist with a focus on heart diseases."
}
Get all doctors:

Method: GET
URL: /api/doctors/
Get a doctor by ID:

Method: GET
URL: /api/doctors/<id>/
Update a doctor:

Method: PUT
URL: /api/doctors/<id>/update/
Body (updated data):
json
{
  "first_name": "John",
  "last_name": "Doe",
  "specialization": "Neurologist",
  "contact_number": "0987654321",
  "email": "john.doe@newemail.com",
  "bio": "Expert neurologist specializing in brain disorders."
}
Delete a doctor:

Method: DELETE
URL: /api/doctors/<id>/delete/

13. Authentication and Authorization API
Theory:
 Difference between authentication and authorization.

Authentication and Authorization are two essential concepts in computer security, but they serve different purposes. 
Here's a breakdown of their differences:

Authentication:
Definition: Authentication is the process of verifying the identity of a user or system. It ensures that the entity accessing a system is who they claim to be.
Goal: To confirm that the user or system is legitimate.
How it's done:
Common methods include passwords, biometrics (fingerprint, facial recognition), security tokens, smart cards, and 
multi-factor authentication (MFA).
When you log in to a system (e.g., website or app), you're typically asked to provide credentials (username and password) 
to prove your identity.
Example: Logging into your email account with your username and password.
Authorization:
Definition: Authorization is the process of determining whether an authenticated user has permission to access specific 
resources or perform certain actions within a system.
Goal: To control and restrict access to resources based on user roles and permissions.
How it's done:
After authentication, the system checks the user's role (e.g., admin, user, guest) and permissions (e.g., read, write, 
execute) to decide what actions they can perform or which data they can access.
Example: After logging into your email, you may only be allowed to read messages but not delete them, depending on 
your role in the system.
Key Differences:
Aspect	Authentication	Authorization
Purpose	Verifies identity of the user/system.	Determines what resources the authenticated user can access.
Focus	Who are you?	What are you allowed to do?
Occurs	First, before authorization.	After authentication.
Methods	Username, password, biometrics, security tokens, MFA.	Role-based access control, permission settings, 
ACLs (Access Control Lists).
Example	Entering a password to log in.	Deciding if a user can view or edit certain files.
Example Scenario:
Authentication: When you enter your username and password on a website, the system verifies your identity (e.g., 
matching your credentials to a stored database).
Authorization: After you've logged in, the system checks your role and grants or restricts access to certain features, 
like whether you can access admin settings or only your personal profile page.
In short:

Authentication = Who are you?
Authorization = What can you do?

 Implementing authentication using Django REST Framework’s token-based system.

To implement authentication using Django REST Framework's (DRF) token-based system, follow these steps:

Step 1: Install required packages
You need to install djangorestframework and djangorestframework-simplejwt (for JWT authentication) or just 
djangorestframework if you're using DRF's default token-based authentication.

bash
pip install djangorestframework djangorestframework-simplejwt
Or for the default token authentication system:

bash
pip install djangorestframework
Step 2: Update INSTALLED_APPS
Add the necessary apps to the INSTALLED_APPS list in your settings.py:

python
INSTALLED_APPS = [
    ...
    'rest_framework',
    'rest_framework.authtoken',  # Only required if using DRF's token authentication system
    ...
]
If you are using JWT for token authentication (djangorestframework-simplejwt), no need for rest_framework.authtoken.

Step 3: Migrate the database
For DRF's token-based authentication, you need to create the necessary tables in the database. Run the following 
commands:

bash
python manage.py migrate
This will create a table for storing tokens if you're using DRF's built-in token authentication.

Step 4: Set up Authentication in settings.py
In your settings.py, configure the DEFAULT_AUTHENTICATION_CLASSES in the REST_FRAMEWORK settings.

For DRF’s token authentication:
python
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.TokenAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}
For JWT authentication (if using simplejwt):
python
from datetime import timedelta

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=15),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': True,
}
Step 5: Create the Authentication Views
For DRF Token Authentication:
You can use DRF's built-in views to obtain a token.

In your urls.py, add the token obtain and authenticate views:

python
from rest_framework.authtoken.views import obtain_auth_token
from django.urls import path

urlpatterns = [
    path('api-token-auth/', obtain_auth_token, name='api_token_auth'),
    # Your other urls
]
This will provide an endpoint (/api-token-auth/) where users can authenticate by providing their username and password, 
and in return, they'll get a token.

For JWT Authentication (with simplejwt):
Add the following URLs in your urls.py to use JWT authentication endpoints:

python
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)

urlpatterns = [
    path('api/token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('api/token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),
    # Your other urls
]
TokenObtainPairView: Issues a new access token and refresh token.
TokenRefreshView: Allows the user to refresh their token using the refresh token.
Step 6: Protect API Views with Authentication
In your API views, you can now restrict access to authenticated users by using the IsAuthenticated permission.

Example of a protected view:

python
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.permissions import IsAuthenticated

class MyProtectedView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        return Response({"message": "This is a protected view!"})
Step 7: Test the Authentication System
Now, you can test the token-based authentication system using tools like Postman or curl.

Obtain the token (for DRF token authentication):

Send a POST request to /api-token-auth/ with the username and password in the body.
The response will contain the token.
Example using curl:

bash
curl -X POST http://127.0.0.1:8000/api-token-auth/ -d "username=yourusername&password=yourpassword"
You will get a response like:

json
{
  "token": "yourgeneratedtoken"
}
Access protected endpoints:

To access protected API endpoints, include the token in the Authorization header in your requests.
Example using curl:

bash
curl -H "Authorization: Token yourgeneratedtoken" http://127.0.0.1:8000/protected-api/
For JWT, you would use the access token similarly in the Authorization header:

bash
curl -H "Authorization: Bearer youraccesstoken" http://127.0.0.1:8000/protected-api/
Final Thoughts
Now you have successfully implemented token-based authentication using Django REST Framework. You can enhance this 
system by handling token expiry, implementing refresh tokens, and customizing the authentication flow as per your 
project's needs.

Lab:
 Implement user login, logout, and registration APIs in a Django project.

To implement user login, logout, and registration APIs in a Django project, follow these steps:

Step 1: Set up the Django project
If you haven't already, create a new Django project and a new app where you'll implement the authentication functionality.

Create a Django Project:

bash
django-admin startproject user_auth
cd user_auth
Create an App for Authentication:

bash
python manage.py startapp accounts
Add the app to the INSTALLED_APPS in settings.py:

Open user_auth/settings.py and add 'accounts' to the INSTALLED_APPS list.

python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'accounts',
]
Install djangorestframework for API functionality (if not already installed):

bash
pip install djangorestframework
Add rest_framework to the INSTALLED_APPS in settings.py:

python
INSTALLED_APPS = [
    # ... other apps
    'rest_framework',
]
Step 2: Create Models (Optional for Registration)
If you want to add custom fields to the User model, you can extend AbstractUser. But, for this example, we'll use 
the default User model.

python
# accounts/models.py

from django.contrib.auth.models import AbstractUser
from django.db import models

class CustomUser(AbstractUser):
    pass  # Add custom fields here if needed
If you decide to use a custom user model, make sure to set it in settings.py:

python
# user_auth/settings.py
AUTH_USER_MODEL = 'accounts.CustomUser'
Step 3: Create Serializers
Create serializers for user registration, login, and logout.

User Serializer:
python
# accounts/serializers.py

from django.contrib.auth.models import User
from rest_framework import serializers

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('username', 'email', 'first_name', 'last_name')
Registration Serializer:
python
# accounts/serializers.py

from django.contrib.auth.models import User
from rest_framework import serializers

class RegisterSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ('username', 'password', 'email')

    def create(self, validated_data):
        user = User.objects.create_user(
            username=validated_data['username'],
            password=validated_data['password'],
            email=validated_data['email']
        )
        return user
Login Serializer:
python
# accounts/serializers.py

from rest_framework import serializers

class LoginSerializer(serializers.Serializer):
    username = serializers.CharField()
    password = serializers.CharField()
Step 4: Create Views for Registration, Login, and Logout
Now, let's create views for handling the registration, login, and logout processes.

Registration View:
python
# accounts/views.py

from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from django.contrib.auth.models import User
from .serializers import RegisterSerializer

class RegisterView(APIView):
    def post(self, request):
        serializer = RegisterSerializer(data=request.data)
        if serializer.is_valid():
            user = serializer.save()
            return Response({
                "message": "User created successfully",
                "user": {
                    "username": user.username,
                    "email": user.email
                }
            }, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
Login View:
For login, we will use Django's built-in authentication system to check the username and password.

python
# accounts/views.py

from django.contrib.auth import authenticate, login
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from .serializers import LoginSerializer

class LoginView(APIView):
    def post(self, request):
        serializer = LoginSerializer(data=request.data)
        if serializer.is_valid():
            username = serializer.validated_data['username']
            password = serializer.validated_data['password']
            user = authenticate(request, username=username, password=password)

            if user is not None:
                login(request, user)
                return Response({
                    "message": "Login successful",
                    "user": {
                        "username": user.username,
                        "email": user.email
                    }
                })
            else:
                return Response({"message": "Invalid credentials"}, status=status.HTTP_400_BAD_REQUEST)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
Logout View:
Django's logout() function can be used to log out the user.

python
# accounts/views.py

from django.contrib.auth import logout
from rest_framework.views import APIView
from rest_framework.response import Response

class LogoutView(APIView):
    def post(self, request):
        logout(request)
        return Response({"message": "Logged out successfully"})
Step 5: Create URLs
Now, create the URLs for these views.

python
# accounts/urls.py

from django.urls import path
from .views import RegisterView, LoginView, LogoutView

urlpatterns = [
    path('register/', RegisterView.as_view(), name='register'),
    path('login/', LoginView.as_view(), name='login'),
    path('logout/', LogoutView.as_view(), name='logout'),
]
Don't forget to include these URLs in the main project's urls.py:

python
# user_auth/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/auth/', include('accounts.urls')),  # Include authentication URLs
]
Step 6: Apply Migrations
If you’ve modified or added a custom user model, run migrations.

bash
python manage.py makemigrations
python manage.py migrate
Step 7: Test the APIs
Now that everything is set up, you can test your login, logout, and registration APIs:

Registration:

POST /api/auth/register/
Body:
json
{
  "username": "testuser",
  "email": "testuser@example.com",
  "password": "password123"
}
Login:

POST /api/auth/login/
Body:
json
{
  "username": "testuser",
  "password": "password123"
}
Logout:

POST /api/auth/logout/
Step 8: (Optional) Add Permissions
You can add permissions to these views to control access (e.g., to require authentication for certain views).

For example, to make sure only authenticated users can log out:

python
from rest_framework.permissions import IsAuthenticated

class LogoutView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        logout(request)
        return Response({"message": "Logged out successfully"})
Practical Example: 13) Write a Django project that uses token-based authentication for users and restricts access to 
certain API endpoints.

To create a Django project that uses token-based authentication and restricts access to certain API endpoints, 
we can follow these steps:

Set up Django Project: Create a new Django project and install necessary packages like django-rest-framework and djangorestframework-simplejwt.

Create an API for User Authentication and Token Generation: Use token-based authentication via JWT (JSON Web Tokens) 
for user login.

Restrict Access to Certain Endpoints: Apply permissions to protect API endpoints so that only authenticated users 
can access them.

Step-by-Step Implementation:
1. Set up Django Project and Install Dependencies
First, create a new Django project and install the required packages:

bash
django-admin startproject token_auth_project
cd token_auth_project
python -m venv venv
source venv/bin/activate  # On Windows use venv\Scripts\activate
pip install django djangorestframework djangorestframework-simplejwt
Create a Django app to handle the user authentication:

bash
python manage.py startapp users
2. Configure the Django Settings
Edit the settings.py file in your project to add the required apps and configure JWT authentication.

python
# settings.py

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'rest_framework',  # Add DRF
    'rest_framework_simplejwt',  # Add SimpleJWT
    'users',  # Your app
]

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
}

# Add JWT settings
SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': False,
    'BLACKLIST_AFTER_ROTATION': False,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': 'your_secret_key',
    'VERIFYING_KEY': None,
    'AUDIENCE': None,
    'ISSUER': None,
    'JWK_URL': None,
    'LEEWAY': 0,
}
3. Create a User Serializer and View for Authentication
Inside the users app, create a serializers.py file to handle the serialization of the user data and token generation.

python
# users/serializers.py
from django.contrib.auth.models import User
from rest_framework import serializers
from rest_framework_simplejwt.tokens import RefreshToken

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ('id', 'username', 'email')

class CustomTokenObtainPairSerializer(serializers.Serializer):
    username = serializers.CharField()
    password = serializers.CharField()

    def validate(self, attrs):
        username = attrs.get('username')
        password = attrs.get('password')

        user = User.objects.filter(username=username).first()
        if user and user.check_password(password):
            refresh = RefreshToken.for_user(user)
            access_token = refresh.access_token
            return {
                'refresh': str(refresh),
                'access': str(access_token),
            }
        raise serializers.ValidationError('Invalid credentials')
Create a view to handle token authentication and creation of new tokens:

python
# users/views.py
from rest_framework import status
from rest_framework.response import Response
from rest_framework.views import APIView
from .serializers import CustomTokenObtainPairSerializer

class TokenObtainPairView(APIView):
    def post(self, request):
        serializer = CustomTokenObtainPairSerializer(data=request.data)
        if serializer.is_valid():
            return Response(serializer.validated_data, status=status.HTTP_200_OK)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
4. Define the URLs
Define the URL for the login endpoint and any other necessary API endpoints.

python
# users/urls.py
from django.urls import path
from .views import TokenObtainPairView

urlpatterns = [
    path('login/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
]
Include the users URLs in the main urls.py file.

python
# token_auth_project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/users/', include('users.urls')),
]
5. Protect API Endpoints Using JWT Authentication
Create a protected API endpoint that requires authentication. For example, let's create a simple ProfileView that 
only authenticated users can access.

python
# users/views.py
from rest_framework.permissions import IsAuthenticated
from rest_framework.views import APIView
from rest_framework.response import Response
from .serializers import UserSerializer

class ProfileView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        user = request.user
        serializer = UserSerializer(user)
        return Response(serializer.data)
Add the URL to access this endpoint.

python
# users/urls.py
from .views import ProfileView

urlpatterns = [
    path('login/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('profile/', ProfileView.as_view(), name='profile'),
]
6. Migrate Database and Create a Superuser
Run the migrations to set up your database and create a superuser for the admin interface.

bash
python manage.py migrate
python manage.py createsuperuser  # Follow the prompts to create a superuser
7. Run the Project
Run the development server.

bash
python manage.py runserver
.8. Test the API Endpoints
Login (Get Tokens):

Make a POST request to /api/users/login/ with a body like:
json
{
  "username": "your_username",
  "password": "your_password"
}
The response will contain the access and refresh tokens:
json
{
  "access": "your_access_token",
  "refresh": "your_refresh_token"
}
Access Protected Endpoint (Profile):

Now, use the access_token to access the /api/users/profile/ endpoint. Include it in the Authorization header:
makefile
Authorization: Bearer your_access_token
The response will be the authenticated user's profile data.
Summary of Files:
serializers.py: Defines serializers for user data and token creation.
views.py: Contains views for handling token creation and protected profile access.
urls.py: Defines URLs for login and profile access.
settings.py: Configures JWT authentication.
By following this approach, you can secure your Django application with token-based authentication and restrict access 
to certain API endpoints based on user authentication.

14. OpenWeatherMap API Integration
Theory:
 Introduction to OpenWeatherMap API and how to retrieve weather data.

Introduction to OpenWeatherMap API
OpenWeatherMap is a popular service that provides weather data, including current weather, forecasts, historical weather, 
and other meteorological information. The OpenWeatherMap API allows developers to retrieve various weather data for use 
in applications, websites, and other services.

Key Features of OpenWeatherMap API:
Current Weather: Get real-time data about the weather in any location.
Weather Forecasts: Obtain short-term (hourly) and long-term (daily) forecasts.
Historical Data: Access past weather data.
Weather Alerts: Receive notifications about severe weather conditions.
Air Pollution: Information about air quality in different regions.
Weather Maps: Interactive maps showing weather patterns like temperature, precipitation, and wind speed.
How to Retrieve Weather Data Using the OpenWeatherMap API
Step 1: Register for an API Key
To access OpenWeatherMap data, you need an API key. Here’s how you can get it:

Go to the OpenWeatherMap website.
Sign up for a free account or log in if you already have one.
Once logged in, go to the "API keys" section of your dashboard and generate an API key.
The API key will be used to authenticate your requests.
Step 2: Set Up a Request to the OpenWeatherMap API
The OpenWeatherMap API provides various endpoints that allow you to request different types of weather data. 
Below are some examples of how to use these endpoints.

Current Weather Data

Endpoint: http://api.openweathermap.org/data/2.5/weather
Required Parameters:
q: City name (e.g., "London").
appid: Your API key.
Example URL to get current weather for London:

bash
http://api.openweathermap.org/data/2.5/weather?q=London&appid=your_api_key
5 Day / 3 Hour Forecast

Endpoint: http://api.openweathermap.org/data/2.5/forecast
Required Parameters:
q: City name (e.g., "London").
appid: Your API key.
Example URL:

bash
http://api.openweathermap.org/data/2.5/forecast?q=London&appid=your_api_key
Historical Data

Endpoint: http://api.openweathermap.org/data/2.5/onecall/timemachine
Required Parameters:
lat, lon: Latitude and longitude of the location.
dt: The timestamp of the historical data.
appid: Your API key.
Example URL:

bash
http://api.openweathermap.org/data/2.5/onecall/timemachine?lat=35.6895&lon=139.6917&dt=1618317040&appid=your_api_key
Step 3: Making the Request
To make a request, you can use various methods like curl, JavaScript's fetch(), Python’s requests library, or any 
other HTTP client library you are comfortable with.

Example in Python (Using requests Library):
python
import requests

# Define the API endpoint and your API key
url = "http://api.openweathermap.org/data/2.5/weather"
api_key = "your_api_key"
city = "London"

# Construct the complete API URL
params = {
    "q": city,
    "appid": api_key
}

# Make the API request
response = requests.get(url, params=params)

# Check if the request was successful
if response.status_code == 200:
    weather_data = response.json()
    print(weather_data)
else:
    print(f"Error: {response.status_code}")
Step 4: Handle the Response
The response will typically be in JSON format, containing the requested weather data. Here's an example of how the 
response might look:

json
{
    "coord": {
        "lon": -0.1276,
        "lat": 51.5074
    },
    "weather": [
        {
            "id": 800,
            "main": "Clear",
            "description": "clear sky",
            "icon": "01d"
        }
    ],
    "main": {
        "temp": 295.07,
        "feels_like": 294.28,
        "temp_min": 293.15,
        "temp_max": 296.34,
        "pressure": 1013,
        "humidity": 72
    },
    "wind": {
        "speed": 3.09,
        "deg": 220
    },
    "name": "London",
    "cod": 200
}
You can extract the data you need, like temperature, weather condition, wind speed, etc., from the response.

Step 5: Parse the Data
In Python, for instance, you can parse the JSON response to extract specific weather details:

python
if response.status_code == 200:
    data = response.json()
    city_name = data["name"]
    weather_desc = data["weather"][0]["description"]
    temperature = data["main"]["temp"] - 273.15  # Convert from Kelvin to Celsius

    print(f"Weather in {city_name}: {weather_desc}")
    print(f"Temperature: {temperature:.2f}°C")
Common API Endpoints
Current weather data:

http://api.openweathermap.org/data/2.5/weather?q={city_name}&appid={API_KEY}
Weather forecast (5 days / 3 hours):

http://api.openweathermap.org/data/2.5/forecast?q={city_name}&appid={API_KEY}
One Call API (Hourly, daily, and current weather for a specific location):

http://api.openweathermap.org/data/2.5/onecall?lat={lat}&lon={lon}&appid={API_KEY}
Air Pollution data:

http://api.openweathermap.org/data/2.5/air_pollution?lat={lat}&lon={lon}&appid={API_KEY}

Lab:
 Create a Django project that fetches weather data for a given location.

To create a Django project that fetches weather data for a given location, we can break down the process into several 
steps. Below is an outline of how to do it, including setting up the Django project, creating an API endpoint, and 
fetching weather data from a third-party service like OpenWeatherMap.

Step 1: Set Up Your Django Project
Install Django:

First, install Django using pip:

bash
pip install django
Create a Django Project:

Create a new project using the following command:

bash
django-admin startproject weather_project
cd weather_project
Create a Django App:

Create an app that will handle weather-related functionality:

bash
python manage.py startapp weather
Install Requests:

We will use the requests library to fetch weather data from an external API.

bash
pip install requests
Add the App to Settings:

Open weather_project/settings.py and add weather to the INSTALLED_APPS list.

python
INSTALLED_APPS = [
    # Other apps
    'weather',
]
Step 2: Fetch Weather Data from OpenWeatherMap
Sign Up for OpenWeatherMap API:

Go to OpenWeatherMap and sign up for an API key.

Create a Utility to Fetch Weather Data:

In your weather app, create a utility function to fetch weather data. For example, in weather/utils.py:

python
import requests

API_KEY = 'YOUR_OPENWEATHERMAP_API_KEY'  # Replace with your actual API key
BASE_URL = 'http://api.openweathermap.org/data/2.5/weather'

def get_weather(city):
    params = {
        'q': city,
        'appid': API_KEY,
        'units': 'metric',  # Get temperature in Celsius
    }
    response = requests.get(BASE_URL, params=params)
    if response.status_code == 200:
        return response.json()
    else:
        return None
Step 3: Create Views to Handle Requests
Now, create views to handle the user input for the city and display the weather data. In weather/views.py:

python
from django.shortcuts import render
from .utils import get_weather

def weather_view(request):
    weather_data = None
    error_message = None

    if 'city' in request.GET:
        city = request.GET['city']
        weather_data = get_weather(city)

        if not weather_data:
            error_message = f"Could not fetch weather data for {city}. Please check the city name."

    return render(request, 'weather/weather.html', {
        'weather_data': weather_data,
        'error_message': error_message
    })
Step 4: Create a Template to Display Weather Data
Create a template file, weather/templates/weather/weather.html, to display the weather information.

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather App</title>
</head>
<body>
    <h1>Weather Information</h1>
    
    <form method="get">
        <input type="text" name="city" placeholder="Enter city name" required>
        <button type="submit">Get Weather</button>
    </form>

    {% if weather_data %}
        <h2>Weather for {{ weather_data.name }}</h2>
        <p>Temperature: {{ weather_data.main.temp }}°C</p>
        <p>Humidity: {{ weather_data.main.humidity }}%</p>
        <p>Weather: {{ weather_data.weather.0.description }}</p>
    {% elif error_message %}
        <p style="color:red">{{ error_message }}</p>
    {% endif %}
</body>
</html>
Step 5: Set Up URL Routing
Next, set up the URL routing for the weather app. In weather/urls.py:

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.weather_view, name='weather_view'),
]
In the weather_project/urls.py file, include the weather app's URL:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('weather/', include('weather.urls')),
]
Step 6: Run the Project
Migrate the Database (even though we don't need any DB for this project, it's good practice to run migrations):

bash
python manage.py migrate
Run the Server:

Now, run the Django development server:

bash
python manage.py runserver
Test the Application:

Open your browser and navigate to http://127.0.0.1:8000/weather/. You should see a form where you can enter the name 
of a city, and it will display the weather information (temperature, humidity, and description) for that city.

Summary of Files:
weather_project/settings.py: Add the app weather to INSTALLED_APPS.
weather/urls.py: Defines the routes for your weather views.
weather/views.py: Contains the logic to handle the weather request and response.
weather/utils.py: Fetches weather data from OpenWeatherMap API.
weather/templates/weather/weather.html: Displays the weather form and data.
Step 7: (Optional) Deployment
If you want to deploy the project, consider using platforms like Heroku, DigitalOcean, or any other service where you 
can host Django applications.

For production use, make sure to hide your OpenWeatherMap API key securely and follow best practices for environment 
variables.

Practical Example: 14) Write a Django project to fetch current weather data for a location using the OpenWeatherMap API.

To create a Django project that fetches current weather data for a location using the OpenWeatherMap API, follow these 
steps:

Step 1: Set up your Django project
Install Django and Requests

First, ensure that you have Python installed. Then, create a virtual environment and install the required libraries.

bash
python3 -m venv weatherenv
source weatherenv/bin/activate  # On Windows, use `weatherenv\Scripts\activate`
pip install django requests
Create a Django Project

Create a new Django project:

bash
django-admin startproject weather_project
cd weather_project
Create a Django App

Create a new app where you’ll handle the weather data fetching:

bash
python manage.py startapp weather
Add the App to Installed Apps

In weather_project/settings.py, add the app to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    ...
    'weather',
]
Step 2: Get OpenWeatherMap API Key
Go to OpenWeatherMap and create an account.
Once logged in, get your API key from the API keys section.
Save the API key, as you will need it for making requests.
Step 3: Create the Weather View
Configure the API URL

In the weather app, create a file called config.py to store the API URL and the key (make sure to keep this information 
secure):

python
# weather/config.py
OPENWEATHERMAP_API_KEY = 'your-api-key-here'
OPENWEATHERMAP_URL = 'http://api.openweathermap.org/data/2.5/weather'
Create the Weather Fetching Function

In views.py, create a function to fetch the weather data:

python
# weather/views.py
import requests
from django.shortcuts import render
from .config import OPENWEATHERMAP_API_KEY, OPENWEATHERMAP_URL

def get_weather_data(city):
    params = {
        'q': city,
        'appid': OPENWEATHERMAP_API_KEY,
        'units': 'metric'  # You can change the units to 'imperial' for Fahrenheit
    }
    response = requests.get(OPENWEATHERMAP_URL, params=params)
    data = response.json()

    if response.status_code == 200:
        weather = {
            'city': data['name'],
            'temperature': data['main']['temp'],
            'description': data['weather'][0]['description'],
            'icon': data['weather'][0]['icon'],
        }
        return weather
    else:
        return None

def weather_view(request):
    city = request.GET.get('city', 'London')  # Default city is London
    weather = get_weather_data(city)

    return render(request, 'weather/weather.html', {'weather': weather})
Create the Template

Create a folder called templates inside your weather app. Then, inside templates, create a folder named weather and 
create the template weather.html:

html
<!-- weather/templates/weather/weather.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Weather App</title>
</head>
<body>
    <h1>Weather in {{ weather.city }}</h1>

    {% if weather %}
        <p>Temperature: {{ weather.temperature }}°C</p>
        <p>Description: {{ weather.description }}</p>
        <img src="http://openweathermap.org/img/wn/{{ weather.icon }}@2x.png" alt="Weather icon">
    {% else %}
        <p>City not found or API error.</p>
    {% endif %}

    <form method="get">
        <label for="city">Enter city:</label>
        <input type="text" id="city" name="city" placeholder="Enter city name">
        <button type="submit">Get Weather</button>
    </form>
</body>
</html>
Step 4: Set up the URL Routing
Add a URL Pattern for Weather View

In the weather/urls.py, add a URL pattern for the weather view:

python
# weather/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('', views.weather_view, name='weather_view'),
]
Include Weather URLs in the Project

In the weather_project/urls.py, include the weather app’s URLs:

python
# weather_project/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('weather/', include('weather.urls')),
]
Step 5: Run the Project
Migrate Database

Run migrations to set up the database (even though this project doesn't use the database much):

bash
python manage.py migrate
Start the Development Server

Start the Django development server:

bash
python manage.py runserver
Now, you can access the weather app at http://127.0.0.1:8000/weather/. Enter a city name in the form to see the weather 
data.

Step 6: Optional - Add Error Handling and Styling
Error Handling

Add error handling in get_weather_data to deal with incorrect API keys, rate limits, or network issues.

Styling

You can style the HTML with CSS to make the UI more appealing.

Final Notes
The above code fetches weather data in Celsius by default ('units': 'metric'). You can modify the units parameter 
in the API call for Fahrenheit or Kelvin.
Don't forget to keep your API key private. You can use environment variables to store sensitive data for more security.

15. Google Maps Geocoding API
Theory:
 Using Google Maps Geocoding API to convert addresses into coordinates.

To use the Google Maps Geocoding API to convert addresses into coordinates, follow these steps:

Step 1: Get a Google Maps API Key
Before you can use the Geocoding API, you need an API key from Google. Here's how to obtain one:

Go to the Google Cloud Console.
Create a new project or select an existing project.
Navigate to the API & Services > Credentials section.
Click Create Credentials and choose API Key.
Copy your API Key.
Step 2: Enable Geocoding API
You must enable the Geocoding API for your project:

In the Google Cloud Console, go to API & Services > Library.
Search for Geocoding API and click on it.
Click Enable.
Step 3: Make a Request to the Geocoding API
The API request format is as follows:

ruby
https://maps.googleapis.com/maps/api/geocode/json?address=YOUR_ADDRESS&key=YOUR_API_KEY
Step 4: Example Code in Python
Here's an example of how to use Python to send a request to the Google Maps Geocoding API and parse the result:

python
import requests

def get_coordinates(address, api_key):
    # Construct the URL
    url = f"https://maps.googleapis.com/maps/api/geocode/json?address={address}&key={api_key}"

    # Send a GET request to the API
    response = requests.get(url)
    
    # Parse the JSON response
    data = response.json()
    
    # Check if the response contains results
    if data['status'] == 'OK':
        # Extract the coordinates (latitude and longitude)
        lat = data['results'][0]['geometry']['location']['lat']
        lng = data['results'][0]['geometry']['location']['lng']
        return lat, lng
    else:
        # Return None if there is no valid result
        return None

# Example usage
address = "1600 Amphitheatre Parkway, Mountain View, CA"
api_key = "YOUR_API_KEY"
coordinates = get_coordinates(address, api_key)

if coordinates:
    print(f"Coordinates: Latitude = {coordinates[0]}, Longitude = {coordinates[1]}")
else:
    print("Address not found.")
Explanation:
API Request URL: The URL contains the address and API key. The address should be URL-encoded if it contains special 
characters or spaces.
Response: The response is in JSON format. The latitude and longitude are found in the geometry.location field of 
the first result in the response.
Step 5: Handling Errors and Limits
Quota Limits: Google may limit the number of requests based on your API plan. Free-tier usage comes with a limited 
number of requests, after which charges may apply.
Error Handling: Make sure to handle cases where the address isn't found, or if there's an API limit exceeded, by 
checking the status code and error messages in the response.
Tips:
Always URL-encode the address before sending it in the API request. Python's urllib.parse.quote() can be helpful.
You can also send multiple addresses in one request by appending multiple address parameters, but they need to be 
formatted correctly.
This should give you a straightforward way to convert addresses to coordinates using the Google Maps Geocoding API!

Lab:
 Create a Django project that takes an address as input and returns the latitude and longitude.

To create a Django project that takes an address as input and returns the latitude and longitude, we will utilize 
the Google Maps Geocoding API. This API allows us to convert addresses into geographic coordinates 
(latitude and longitude).

Steps to Create the Django Project:
Set up a Django Project:

First, you need to install Django and other necessary packages:

bash
pip install django requests
Now, create a new Django project and application:

bash
django-admin startproject address_geolocation
cd address_geolocation
python manage.py startapp geolocation
Set Up Google Maps API Key:

You need a Google Maps API key. Follow these steps:

Go to the Google Cloud Console: https://console.cloud.google.com/
Create a new project and enable the "Geocoding API."
Get the API key from the credentials section.
Once you have the API key, make sure to store it securely (for now, we can hard-code it, but it's better to keep it in 
environment variables for production).

Configure Django Settings:

Open settings.py in the address_geolocation folder and add the new app to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    ...
    'geolocation',
]
Create the Geolocation Service:

Now, open geolocation/views.py and create a view that takes an address as input, queries the Google Maps Geocoding API, 
and returns the latitude and longitude.

Here is the geolocation/views.py code:

python
import requests
from django.shortcuts import render
from django.http import JsonResponse
from django.conf import settings

def get_lat_lng(request):
    if request.method == "GET" and "address" in request.GET:
        address = request.GET["address"]
        api_key = settings.GOOGLE_API_KEY
        base_url = "https://maps.googleapis.com/maps/api/geocode/json"
        params = {
            'address': address,
            'key': api_key
        }
        response = requests.get(base_url, params=params)
        data = response.json()

        if data["status"] == "OK":
            # Extract latitude and longitude from the response
            lat = data["results"][0]["geometry"]["location"]["lat"]
            lng = data["results"][0]["geometry"]["location"]["lng"]
            return JsonResponse({"latitude": lat, "longitude": lng})
        else:
            return JsonResponse({"error": "Address not found or invalid."}, status=400)

    return JsonResponse({"error": "No address provided."}, status=400)
Add Google Maps API Key in Settings:

Open the settings.py file and add the following line:

python
GOOGLE_API_KEY = "YOUR_GOOGLE_MAPS_API_KEY"
Create the URL Routing:

In geolocation/urls.py, define the URL pattern for this view:

python
from django.urls import path
from . import views

urlpatterns = [
    path('get_lat_lng/', views.get_lat_lng, name='get_lat_lng'),
]
Also, include the geolocation app's URLs in your project’s urls.py (located in the address_geolocation/urls.py file):

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('geolocation/', include('geolocation.urls')),
]
Test the API:

Now that everything is set up, you can run your Django project:

bash
python manage.py runserver
Open your browser and go to:

ruby
http://127.0.0.1:8000/geolocation/get_lat_lng/?address=1600+Amphitheatre+Parkway,+Mountain+View,+CA
Replace the address parameter with any address you want to test. The response should look something like this:

json
{
    "latitude": 37.423021,
    "longitude": -122.083739
}
Example of How the API Works:
You send a GET request to the get_lat_lng endpoint with a query parameter address.
The view makes a request to Google’s Geocoding API using the provided address.
The latitude and longitude values are extracted from the API's JSON response and returned as a JSON response.
Final Thoughts:
This is a simple Django project that uses the Google Maps Geocoding API to convert an address to latitude and longitude. 
Make sure to handle exceptions and API limits carefully when using the Google API, especially in production environments.

Optional Enhancements:
Add error handling to ensure invalid or missing addresses are handled gracefully.
Store your Google API key securely (use environment variables or Django's django-environ package).
Create a front-end form where users can input addresses and view the results directly.


Practical Example: 15) Write a Django project that uses Google Maps API to find the coordinates of a given address.

To create a Django project that uses the Google Maps API to find the coordinates of a given address, you'll need to 
integrate Google Maps Geocoding API with your Django project. Below is a step-by-step guide to achieve this.

Prerequisites
Install Django if you don't have it already:

bash
pip install django
Get a Google Maps API key from the Google Cloud Console. You'll need to enable the Geocoding API and generate a key.

Step 1: Create a Django Project
Start by creating a Django project and app:

bash
django-admin startproject geocode_project
cd geocode_project
django-admin startapp geocode
Step 2: Install Required Dependencies
In your Django project, you'll need the requests library to interact with the Google Maps API.

Install the requests library:

bash
pip install requests
Step 3: Configure Your Django Settings
In your geocode_project/settings.py, you can add your Google Maps API key as an environment variable for security, 
or directly in the settings (though it's better to keep it secret).

Add the following to your settings.py:

python
# settings.py

import os

GOOGLE_MAPS_API_KEY = os.getenv('GOOGLE_MAPS_API_KEY', 'your_google_maps_api_key_here')
Make sure to replace 'your_google_maps_api_key_here' with your actual Google Maps API key if you're not using 
environment variables.

Step 4: Create the Geocoding View
In the geocode app, create a view that will handle address geocoding.

Create a new file geocode/views.py with the following code:

python
# geocode/views.py

import requests
from django.conf import settings
from django.shortcuts import render
from django.http import JsonResponse

def geocode_address(request):
    if request.method == 'GET' and 'address' in request.GET:
        address = request.GET['address']
        api_key = settings.GOOGLE_MAPS_API_KEY
        
        # Prepare the Google Maps Geocoding API URL
        url = f'https://maps.googleapis.com/maps/api/geocode/json?address={address}&key={api_key}'
        
        # Send request to Google Maps API
        response = requests.get(url)
        data = response.json()
        
        # Check if request is successful
        if data['status'] == 'OK':
            result = data['results'][0]
            coordinates = result['geometry']['location']
            latitude = coordinates['lat']
            longitude = coordinates['lng']
            return JsonResponse({'latitude': latitude, 'longitude': longitude})
        else:
            return JsonResponse({'error': 'Unable to get coordinates for the address.'}, status=400)
    
    return render(request, 'geocode/address_form.html')
Step 5: Create the Template for User Input
Create a templates/geocode/address_form.html file to allow users to input an address.

html
<!-- templates/geocode/address_form.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geocode Address</title>
</head>
<body>
    <h1>Enter an Address</h1>
    <form action="" method="get">
        <label for="address">Address:</label>
        <input type="text" id="address" name="address" required>
        <button type="submit">Get Coordinates</button>
    </form>

    {% if latitude and longitude %}
    <h2>Coordinates:</h2>
    <p>Latitude: {{ latitude }}</p>
    <p>Longitude: {{ longitude }}</p>
    {% endif %}
</body>
</html>
Step 6: Define URLs for the View
In your app's urls.py, define the route for the geocoding view:

python
# geocode/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('', views.geocode_address, name='geocode_address'),
]
Then, in your project's urls.py (geocode_project/urls.py), include the geocode app's URLs:

python
# geocode_project/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('geocode.urls')),
]
Step 7: Migrate Database (Optional)
In this case, we do not need to create any models for geocoding. However, if you had other features or needed a database, 
you'd run:

bash
python manage.py migrate
Step 8: Run the Django Server
Now, you can run your Django server:

bash
python manage.py runserver
Step 9: Test the Geocoding Functionality
Open your browser and navigate to http://127.0.0.1:8000/. You should see a form where you can enter an address. 
After submitting, the server will return the latitude and longitude of the given address in JSON format.

For example:

Input: 1600 Pennsylvania Ave NW, Washington, DC
Output:
json
{
  "latitude": 38.8976763,
  "longitude": -77.0365298
}
Additional Enhancements
Error Handling: Improve error handling by providing a better user experience in case of incorrect addresses or API errors.
Map Display: Integrate a Google Map to visually display the coordinates.
Form Validation: Add form validation to ensure the address is properly formatted before sending the request.
This basic setup will help you integrate Google Maps Geocoding API in a Django application to find coordinates based on a 
given address.

16. GitHub API Integration
Theory:
 Introduction to GitHub API and how to interact with repositories, pull requests, and issues.

Introduction to GitHub API
GitHub provides a powerful RESTful API that allows developers to interact programmatically with GitHub repositories, 
pull requests, issues, and other GitHub resources. The GitHub API can be used to automate tasks, integrate GitHub with 
other applications, and access data on GitHub repositories.

The GitHub API is divided into multiple resources, including:

Repositories: You can retrieve, create, update, or delete repositories.
Issues: You can create, update, comment on, and list issues in a repository.
Pull Requests: You can open, close, and comment on pull requests.
Commits, Branches, and More: You can interact with commits, branches, and even GitHub Actions workflows.
Key Concepts:
Authentication: Most API calls require authentication to access private repositories or perform specific actions. 
GitHub supports personal access tokens (PAT) or OAuth for authentication.
Endpoints: Each type of resource (repositories, issues, pull requests, etc.) has a unique API endpoint.
HTTP Methods: You interact with the API using standard HTTP methods:
GET: Retrieve data
POST: Create a new resource
PATCH: Update a resource
DELETE: Remove a resource
GitHub API Authentication
To use the GitHub API, you typically need a Personal Access Token (PAT) for authentication. You can create a PAT via 
GitHub's settings under Developer settings > Personal access tokens.

Here’s an example of how to authenticate using the curl command and a token:

bash
curl -H "Authorization: token YOUR_PERSONAL_ACCESS_TOKEN" https://api.github.com/user
Basic Interactions with GitHub API
1. Interacting with Repositories
You can perform various actions on repositories using the GitHub API, such as creating, deleting, or listing repositories.

List Repositories for a User:

bash
curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/users/YOUR_USERNAME/repos
Create a Repository:

bash
curl -X POST -H "Authorization: token YOUR_TOKEN" -d '{"name": "new-repository", "description": "A new repo"}' https://api.github.com/user/repos
Get Repository Details:

bash
curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/repos/USERNAME/REPO_NAME
2. Interacting with Issues
You can create, list, update, and comment on issues within repositories.

List Issues in a Repository:

bash
curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/repos/USERNAME/REPO_NAME/issues
Create an Issue:

bash
curl -X POST -H "Authorization: token YOUR_TOKEN" -d '{"title": "Bug found", "body": "Describe the bug here", "assignee": "USER_NAME"}' https://api.github.com/repos/USERNAME/REPO_NAME/issues
Add a Comment to an Issue:

bash
curl -X POST -H "Authorization: token YOUR_TOKEN" -d '{"body": "This is a comment"}' https://api.github.com/repos/USERNAME/REPO_NAME/issues/ISSUE_NUMBER/comments
3. Interacting with Pull Requests
Pull requests allow you to propose changes to a repository, review, and merge them.

List Pull Requests in a Repository:

bash
curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/repos/USERNAME/REPO_NAME/pulls
Create a Pull Request:

bash
curl -X POST -H "Authorization: token YOUR_TOKEN" -d '{"title": "New feature", "head": "branch_name", "base": "main", "body": "Description of changes"}' https://api.github.com/repos/USERNAME/REPO_NAME/pulls
Merge a Pull Request:

bash
curl -X PUT -H "Authorization: token YOUR_TOKEN" https://api.github.com/repos/USERNAME/REPO_NAME/pulls/PULL_REQUEST_NUMBER/merge
Example Workflows
Example 1: Listing Issues in a Repository
To list all open issues in a repository, you can use the following command:

bash
curl -H "Authorization: token YOUR_TOKEN" https://api.github.com/repos/octocat/Hello-World/issues
This will return a list of all issues currently open in the octocat/Hello-World repository.

Example 2: Creating a Pull Request
To create a pull request, make sure you have two branches (e.g., main and feature-branch). You can use the following 
curl command:

bash
curl -X POST -H "Authorization: token YOUR_TOKEN" \
  -d '{"title": "Add new feature", "head": "feature-branch", "base": "main", "body": "This PR adds a new feature."}' \
  https://api.github.com/repos/octocat/Hello-World/pulls
This will create a pull request to merge feature-branch into main.

Example 3: Commenting on an Issue
To comment on an issue in a repository, you can use the following command:

bash
curl -X POST -H "Authorization: token YOUR_TOKEN" \
  -d '{"body": "This is a comment on the issue."}' \
  https://api.github.com/repos/octocat/Hello-World/issues/1/comments
This will add a comment to issue #1 in the repository.

Lab:
 Use GitHub API to create a repository and retrieve user data.

To use the GitHub API to create a repository and retrieve user data, you'll need to make authenticated requests to 
GitHub's REST API. Here's how to do this step by step:

1. Create a GitHub Personal Access Token (PAT)
To interact with GitHub's API, you need to authenticate using a Personal Access Token (PAT). Follow these steps to 
create it:

Log in to your GitHub account.
Go to GitHub Settings.
Click on Generate new token.
Select the appropriate scopes for your needs. For example:
repo: to create and manage repositories.
user: to access user data.
Click Generate token, and save it somewhere secure.
2. Create a Repository Using the GitHub API
Once you have the token, you can create a repository by sending a POST request to the https://api.github.com/user/repos 
endpoint.

Example Code (Python using requests):
python
import requests

# Replace with your GitHub username and personal access token
username = 'your-username'
token = 'your-personal-access-token'

# URL for creating a new repository
url = 'https://api.github.com/user/repos'

# Repository data (You can customize this)
data = {
    'name': 'my-new-repository',  # Repository name
    'description': 'This is a new repository created via GitHub API',  # Description
    'private': False  # Set to True for a private repository
}

# Make the POST request to create the repository
response = requests.post(url, json=data, auth=(username, token))

# Check if the repository was created successfully
if response.status_code == 201:
    print("Repository created successfully!")
else:
    print(f"Error: {response.status_code}")
    print(response.json())
Explanation:
The POST request is sent to https://api.github.com/user/repos to create a repository for the authenticated user.
The data contains the repository name, description, and visibility (private or public).
3. Retrieve User Data Using the GitHub API
To retrieve user data, send a GET request to the https://api.github.com/user endpoint.

Example Code (Python):
python
# URL to get user data
url = 'https://api.github.com/user'

# Make the GET request to fetch user data
response = requests.get(url, auth=(username, token))

# Check if the request was successful
if response.status_code == 200:
    user_data = response.json()
    print(f"User data: {user_data}")
else:
    print(f"Error: {response.status_code}")
    print(response.json())
Explanation:
The GET request to https://api.github.com/user retrieves data about the authenticated user (such as their username, ID, 
public repos, etc.).
4. Important Notes:
Replace 'your-username' and 'your-personal-access-token' with your GitHub username and the personal access token you 
created.
The requests library is used for making HTTP requests in Python. You can install it using pip install requests if 
it's not installed.
If you're making multiple requests or want to interact with the GitHub API programmatically, you can explore additional 
features such as pagination, error handling, and rate limits.
This should allow you to both create a new repository and retrieve your user data from GitHub using the API.

Practical Example: 16) Write a Django project that interacts with the GitHub API to create a new repository and list 
all repositories for a given user.

To create a Django project that interacts with the GitHub API to create a new repository and list all repositories 
for a given user, we will follow these steps:

Set Up a Django Project: Create the Django project and app.
Set Up GitHub Authentication: We will use GitHub OAuth or a personal access token for authentication.
Integrate the GitHub API: Use GitHub's REST API to list and create repositories.
Create Views and Templates: Display the repositories and handle form submissions for creating a new repository.
Here’s a step-by-step guide:

1. Set Up Django Project and App
First, create a new Django project:

bash
django-admin startproject github_integration
cd github_integration
Create a new Django app:

bash
python manage.py startapp repositories
Add the app to INSTALLED_APPS in settings.py:

python
INSTALLED_APPS = [
    ...
    'repositories',
]
Install the required dependencies (like requests for GitHub API calls):

bash
pip install requests
2. Set Up GitHub Authentication
To interact with the GitHub API, you need a GitHub personal access token. Follow these steps to create a token:

Go to GitHub and navigate to Settings -> Developer settings -> Personal access tokens.
Generate a new token with the required permissions: repo (for creating repositories) and read:org (for listing 
repositories).
For simplicity, we will store the token in Django's settings, but for security reasons, you should consider storing 
it in environment variables or a secure storage service.

3. GitHub API Integration
We'll use GitHub's REST API to perform the following actions:

List all repositories for a user.
Create a new repository.
Here’s how you can define the views to interact with GitHub.

repositories/views.py
python
import requests
from django.conf import settings
from django.shortcuts import render, redirect
from django.http import HttpResponse

# GitHub API URL
GITHUB_API_URL = 'https://api.github.com'

# GitHub Personal Access Token (ensure this is secure)
GITHUB_TOKEN = settings.GITHUB_TOKEN

def list_repositories(request):
    """List all repositories of a given GitHub user."""
    username = request.GET.get('username', '')
    
    if not username:
        return HttpResponse("Please provide a GitHub username.")

    # GitHub API to fetch repositories
    response = requests.get(
        f'{GITHUB_API_URL}/users/{username}/repos',
        headers={'Authorization': f'token {GITHUB_TOKEN}'}
    )

    if response.status_code == 200:
        repos = response.json()
        return render(request, 'repositories/list_repos.html', {'repos': repos, 'username': username})
    else:
        return HttpResponse(f"Error fetching repositories: {response.status_code}")

def create_repository(request):
    """Create a new repository for the authenticated user."""
    if request.method == 'POST':
        repo_name = request.POST.get('repo_name', '').strip()
        if not repo_name:
            return HttpResponse("Repository name is required.")

        # GitHub API to create a repository
        data = {
            'name': repo_name,
            'auto_init': True,  # Optionally initialize with a README
        }

        response = requests.post(
            f'{GITHUB_API_URL}/user/repos',
            json=data,
            headers={'Authorization': f'token {GITHUB_TOKEN}'}
        )

        if response.status_code == 201:
            return redirect('list_repositories')  # Redirect to list repositories after creation
        else:
            return HttpResponse(f"Error creating repository: {response.status_code}")

    return render(request, 'repositories/create_repo.html')
4. URLs Configuration
Now, we need to set up URLs to handle the views.

repositories/urls.py
python
from django.urls import path
from . import views

urlpatterns = [
    path('repos/', views.list_repositories, name='list_repositories'),
    path('create/', views.create_repository, name='create_repository'),
]
Include the URLs in your main project’s urls.py:

github_integration/urls.py
python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('repositories/', include('repositories.urls')),
]
5. Templates for Listing and Creating Repositories
Now, create the templates for listing and creating repositories.

templates/repositories/list_repos.html
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GitHub Repositories</title>
</head>
<body>
    <h1>Repositories for {{ username }}</h1>
    <ul>
        {% for repo in repos %}
            <li><a href="{{ repo.html_url }}" target="_blank">{{ repo.name }}</a></li>
        {% endfor %}
    </ul>
    <a href="{% url 'create_repository' %}">Create a new repository</a>
</body>
</html>
templates/repositories/create_repo.html
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Create GitHub Repository</title>
</head>
<body>
    <h1>Create a new repository</h1>
    <form method="POST">
        {% csrf_token %}
        <label for="repo_name">Repository Name:</label>
        <input type="text" id="repo_name" name="repo_name" required>
        <button type="submit">Create</button>
    </form>
    <a href="{% url 'list_repositories' %}">Back to repositories</a>
</body>
</html>
6. Add Token to settings.py
Add the GitHub token to your settings.py:

python
GITHUB_TOKEN = 'your_personal_access_token_here'
7. Run the Project
Finally, run the server:

bash
python manage.py runserver
Now, navigate to http://127.0.0.1:8000/repositories/repos/ to list repositories for a user. To create a new repository, 
go to http://127.0.0.1:8000/repositories/create/.

17. Twitter API Integration
Theory:
 Using Twitter API to fetch and post tweets, and retrieve user data.

To interact with Twitter using the Twitter API, including fetching and posting tweets, as well as retrieving user data, you can follow the steps below. This process involves setting up access to the Twitter API using OAuth authentication, and then using the API endpoints to perform actions like fetching tweets or posting them.

1. Set Up Twitter Developer Account
Before interacting with Twitter’s API, you need to set up a Twitter Developer account and create a Twitter App.

Create a Twitter Developer Account: Go to the Twitter Developer Portal and apply for a developer account.
Create a New App:
Once approved, log in and navigate to the "Developer Dashboard."
Create a new project and App. Twitter will provide you with API key, API secret key, Access token, and Access token secret.
2. Install Required Libraries
You'll need to use the tweepy library, which is a Python wrapper for the Twitter API. You can install it via pip:

bash
pip install tweepy
3. Set Up Authentication
Using the credentials you obtained from Twitter, you can authenticate your app and gain access to the Twitter API.

python
import tweepy

# Your credentials from Twitter Developer Portal
api_key = 'YOUR_API_KEY'
api_key_secret = 'YOUR_API_SECRET_KEY'
access_token = 'YOUR_ACCESS_TOKEN'
access_token_secret = 'YOUR_ACCESS_TOKEN_SECRET'

# Authenticate with Twitter using OAuth 1.0a
auth = tweepy.OAuth1UserHandler(
    consumer_key=api_key,
    consumer_secret=api_key_secret,
    access_token=access_token,
    access_token_secret=access_token_secret
)

# Create an API object
api = tweepy.API(auth)
4. Fetch Tweets (Timeline, Search, User)
You can use the tweepy API to fetch tweets in different ways.

a. Get Your Timeline
To fetch the latest tweets from your timeline:

python
# Get the 10 most recent tweets from the user's timeline
timeline = api.home_timeline(count=10)
for tweet in timeline:
    print(f'{tweet.user.name} said: {tweet.text}')
b. Get Tweets by a Specific User
To fetch tweets by a specific user:

python
# Get the most recent 10 tweets from a specific user
username = 'twitter'  # Example: Twitter's official handle
tweets = api.user_timeline(screen_name=username, count=10)
for tweet in tweets:
    print(f'{tweet.created_at}: {tweet.text}')
c. Search Tweets
To search for tweets containing a specific keyword or hashtag:

python
# Search for tweets with the hashtag #Python
tweets = api.search_tweets(q='#Python', count=10)
for tweet in tweets:
    print(f'{tweet.user.name} said: {tweet.text}')
d. Get User Data
To get user data, such as the number of followers, description, etc., you can use the get_user method:

python
# Get information about a user
user = api.get_user(screen_name='twitter')  # Replace with any username
print(f'Name: {user.name}')
print(f'Followers Count: {user.followers_count}')
print(f'Description: {user.description}')
5. Post a Tweet
To post a tweet, you can use the update_status method. Here's how to post a simple tweet:

python
# Post a tweet
tweet = api.update_status("Hello, world! #MyFirstTweet")
print(f'Tweet posted: {tweet.text}')
6. Additional Features
Post a Media Tweet (with image/video): You can also upload media such as images or videos along with your tweet:
python
# Upload an image with a tweet
media = api.media_upload('path_to_your_image.jpg')
tweet = api.update_status(status="Here is an image!", media_ids=[media.media_id])
Follow a User:
python
# Follow a user by username
api.create_friendship(screen_name='twitter')
Like a Tweet:
python
# Like a tweet by tweet ID
tweet_id = 1234567890  # Example tweet ID
api.create_favorite(tweet_id)
7. Error Handling
It's important to add error handling when making requests to the API to handle cases like rate limiting or invalid inputs.

python
try:
    tweet = api.update_status("Hello, world!")
except tweepy.TweepError as e:
    print(f"Error: {e}")
8. Rate Limiting
The Twitter API imposes rate limits on requests to prevent abuse. You can check the current rate limit status:

python
# Check rate limits for various API endpoints
rate_limits = api.rate_limit_status()
print(rate_limits)
The Twitter API allows you to make a limited number of requests within a given time window (e.g., 15 requests per 
15 minutes for certain endpoints).

By following these steps, you can interact with Twitter using their API to post tweets, fetch tweets from timelines, 
search tweets, retrieve user data, and more. Be sure to respect Twitter's rate limits and terms of service when using 
the API.

Lab:
 Create a Django project that fetches recent tweets of a specific user.

To create a Django project that fetches recent tweets from a specific user, we will need to follow these steps:

Set up a Django Project.
Install required libraries for Twitter API integration.
Configure Twitter Developer API credentials.
Create views and templates to display tweets.
Below is a detailed guide on how to achieve this:

Step 1: Set up a Django Project
First, create a Django project. If you don't have Django installed, install it using pip:

bash
pip install django
Next, create a new Django project:

bash
django-admin startproject twitter_project
cd twitter_project
Now, create a Django app to handle the functionality:

bash
python manage.py startapp tweets
Step 2: Install Tweepy (Twitter API Client)
Tweepy is a popular Python library for interacting with the Twitter API.

Install Tweepy:

bash
pip install tweepy
Step 3: Configure Twitter Developer API Credentials
Go to the Twitter Developer website, create a developer account, and create an app.
After creating the app, you’ll get the following API keys and tokens:
API Key
API Secret Key
Access Token
Access Token Secret
In your Django project, create a file twitter_credentials.py inside the tweets app directory to store these keys 
securely (do not commit this file to version control).

python
# tweets/twitter_credentials.py

TWITTER_API_KEY = 'your_api_key'
TWITTER_API_SECRET_KEY = 'your_api_secret_key'
TWITTER_ACCESS_TOKEN = 'your_access_token'
TWITTER_ACCESS_TOKEN_SECRET = 'your_access_token_secret'
Step 4: Set Up Twitter API Integration with Tweepy
In the tweets app, create a new Python file twitter_api.py where we'll define functions to connect to Twitter 
using Tweepy.

python
# tweets/twitter_api.py

import tweepy
from .twitter_credentials import TWITTER_API_KEY, TWITTER_API_SECRET_KEY, TWITTER_ACCESS_TOKEN, 
TWITTER_ACCESS_TOKEN_SECRET

def get_twitter_api():
    auth = tweepy.OAuth1UserHandler(
        TWITTER_API_KEY,
        TWITTER_API_SECRET_KEY,
        TWITTER_ACCESS_TOKEN,
        TWITTER_ACCESS_TOKEN_SECRET
    )
    api = tweepy.API(auth)
    return api

def get_recent_tweets(username, count=5):
    api = get_twitter_api()
    tweets = api.user_timeline(screen_name=username, count=count, tweet_mode='extended')
    return tweets
Here:

get_twitter_api() initializes and returns the Tweepy API client.
get_recent_tweets(username, count) fetches the recent tweets of a user.
Step 5: Create Views to Fetch and Display Tweets
Next, we will create a view in the views.py file of the tweets app to fetch recent tweets of a specific user.

python
# tweets/views.py

from django.shortcuts import render
from .twitter_api import get_recent_tweets

def home(request):
    tweets = []
    if request.method == "POST":
        username = request.POST.get("username")
        if username:
            tweets = get_recent_tweets(username)
    return render(request, 'tweets/home.html', {'tweets': tweets})
Here, the home view handles the form submission to input a Twitter username, fetches recent tweets using 
get_recent_tweets, and passes them to the template.

Step 6: Create Templates to Display Tweets
In the tweets app, create a folder named templates/tweets, and inside this folder, create a file home.html:

html
<!-- tweets/templates/tweets/home.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recent Tweets</title>
</head>
<body>
    <h1>Fetch Recent Tweets</h1>
    <form method="POST">
        {% csrf_token %}
        <label for="username">Enter Twitter Username:</label>
        <input type="text" id="username" name="username" required>
        <button type="submit">Fetch Tweets</button>
    </form>

    {% if tweets %}
        <h2>Recent Tweets:</h2>
        <ul>
            {% for tweet in tweets %}
                <li>
                    <p><strong>{{ tweet.user.screen_name }}</strong>: {{ tweet.full_text }}</p>
                    <p><small>Posted on: {{ tweet.created_at }}</small></p>
                </li>
            {% endfor %}
        </ul>
    {% endif %}
</body>
</html>
This template:

Displays a form to enter a Twitter username.
Displays the recent tweets after fetching them.
Step 7: Configure URLs
Now, configure the URL routing for the app. Open the urls.py file in the tweets app and set up the URL path for the 
home view.

python
# tweets/urls.py

from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
]
Also, include this URL configuration in the main urls.py of the project:

python
# twitter_project/urls.py

from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('tweets.urls')),  # Include the tweets app URLs
]
Step 8: Migrate Database and Run the Server
Even though this project does not require database models, it's still a good idea to run the migrations to set up the 
basic database structure for Django.

bash
python manage.py migrate
Then, run the Django development server:

bash
python manage.py runserver
Step 9: Test the Application
Open your browser and go to http://127.0.0.1:8000/. You should see a form where you can enter a Twitter username. 
Once you submit the form, the recent tweets for that user will be displayed.

Practical Example: 17) Write a Django project to fetch and display the latest 5 tweets from a Twitter user using 
the Twitter API.

To create a Django project that fetches and displays the latest 5 tweets from a Twitter user using the Twitter API, 
we need to follow these steps:

Prerequisites
A Twitter Developer account.
API credentials (API Key, API Secret Key, Access Token, and Access Token Secret) from your Twitter Developer application.
Python 3.x installed on your system.
Django installed.
Steps
1. Set up Twitter Developer Access
Visit Twitter Developer and create a new application.
Obtain your API keys (API Key, API Secret Key, Access Token, and Access Token Secret).
2. Set up Django Project
Install Django and Tweepy
First, install Django and Tweepy (which is a Python library for interacting with the Twitter API):

bash
pip install django tweepy
Create Django Project
bash
django-admin startproject twitter_project
cd twitter_project
Create a Django App
bash
python manage.py startapp twitter_feed
Add twitter_feed to INSTALLED_APPS
In settings.py, add 'twitter_feed' to the INSTALLED_APPS list:

python
INSTALLED_APPS = [
    # Other apps...
    'twitter_feed',
]
3. Twitter API Integration
Now, we will use Tweepy to interact with the Twitter API.

Create a file twitter_api.py in the twitter_feed app directory.
This file will contain the logic to fetch the latest tweets using the Twitter API:

python
import tweepy

# Twitter API credentials
API_KEY = 'your-api-key'
API_SECRET_KEY = 'your-api-secret-key'
ACCESS_TOKEN = 'your-access-token'
ACCESS_TOKEN_SECRET = 'your-access-token-secret'

def get_latest_tweets(username, count=5):
    # Authenticate to the Twitter API
    auth = tweepy.OAuth1UserHandler(API_KEY, API_SECRET_KEY, ACCESS_TOKEN, ACCESS_TOKEN_SECRET)
    api = tweepy.API(auth)

    try:
        # Get the latest tweets
        tweets = api.user_timeline(screen_name=username, count=count, tweet_mode="extended")
        tweet_data = [{"text": tweet.full_text, "created_at": tweet.created_at} for tweet in tweets]
        return tweet_data
    except tweepy.TweepError as e:
        return {"error": str(e)}
This script defines a function get_latest_tweets() that fetches the latest tweets of a user based on the username and 
the number of tweets to return (default is 5).
You need to replace the API_KEY, API_SECRET_KEY, ACCESS_TOKEN, and ACCESS_TOKEN_SECRET with your own credentials.
4. Create Views to Display Tweets
In views.py of the twitter_feed app, create a view to display the tweets:
python
from django.shortcuts import render
from .twitter_api import get_latest_tweets

def home(request):
    username = "elonmusk"  # Example: Change this to any Twitter username you want to fetch tweets for
    tweets = get_latest_tweets(username)
    return render(request, 'home.html', {'tweets': tweets, 'username': username})
This view fetches the latest tweets using the get_latest_tweets() function and passes the data to the template.

5. Create Templates
In the twitter_feed app, create a templates directory with a file home.html to display the tweets:
twitter_feed/templates/home.html

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Latest Tweets</title>
</head>
<body>
    <h1>Latest Tweets from {{ username }}</h1>
    
    {% if tweets %}
        <ul>
            {% for tweet in tweets %}
                <li>
                    <p>{{ tweet.text }}</p>
                    <p><small>Posted on: {{ tweet.created_at }}</small></p>
                </li>
            {% endfor %}
        </ul>
    {% else %}
        <p>No tweets found or there was an error fetching tweets.</p>
    {% endif %}
</body>
</html>
This template renders the fetched tweets in an unordered list. Each tweet will show the text and the date it was posted.

6. Set Up URLs
Now, configure the URL routing in your Django project.

In twitter_feed/urls.py, add the following URL pattern:
python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.home, name='home'),
]
Include twitter_feed URLs in urls.py of the project.
In the urls.py file of your project (twitter_project/urls.py), include the URLs for the twitter_feed app:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('twitter_feed.urls')),
]
7. Run the Django Development Server
Now, you're ready to run the Django development server.

bash
python manage.py runserver
Visit http://127.0.0.1:8000/ in your browser to see the latest tweets from the Twitter account you specified in the 
home view (in this example, Elon Musk's account).

Final File Structure
graphql
twitter_project/
│
├── twitter_feed/
│   ├── migrations/
│   ├── __init__.py
│   ├── admin.py
│   ├── apps.py
│   ├── models.py
│   ├── twitter_api.py    # Twitter API integration logic
│   ├── tests.py
│   ├── views.py          # Views for displaying tweets
│   ├── urls.py           # URL configuration for twitter_feed
│   └── templates/
│       └── home.html     # HTML template to display tweets
│
├── twitter_project/
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py           # Main URL configuration
│   ├── wsgi.py
│   └── asgi.py
│
└── manage.py

18. REST Countries API Integration
Theory:
 Introduction to REST Countries API and how to retrieve country-specific data.

Introduction to REST Countries API and How to Retrieve Country-Specific Data
The REST Countries API is a free and popular API that provides detailed information about countries around the world. 
It allows developers to retrieve country-specific data such as country names, capitals, population, currency, languages, 
timezones, flags, and more in a JSON format.

This API is commonly used for applications that need to display or process country information. It can be integrated 
into websites, mobile apps, and services to provide users with relevant country-related details.

Key Features of the REST Countries API
Country Names and Codes: Retrieve the official name, native name, and ISO country codes (alpha-2, alpha-3, numeric).
Geographical Information: Includes data like region, subregion, population, area, and borders.
Currencies: Information on the currency or currencies used by the country.
Languages: List of languages spoken in the country.
Flags: Provides URLs of country flags.
Timezones: Details of timezones in which a country is located.
Borders: Information about countries that share borders with the queried country.
How to Use the REST Countries API
Base URL for the API: The REST Countries API can be accessed through the following base URL:

arduino
https://restcountries.com/v3.1/
Retrieving Country Data: You can query different endpoints based on the data you need. For example:

Get information about a specific country by its name:
bash
https://restcountries.com/v3.1/name/{country_name}
Get information by the country code:
bash
https://restcountries.com/v3.1/alpha/{country_code}
Get information by the country region:
bash
https://restcountries.com/v3.1/region/{region}
Response Format: The API responds with country-specific data in JSON format. Here's an example response when 
querying by country name (e.g., "Germany"):

json
[
  {
    "name": {
      "common": "Germany",
      "official": "Federal Republic of Germany",
      "nativeName": {
        "deu": "Deutschland"
      }
    },
    "capital": "Berlin",
    "region": "Europe",
    "subregion": "Western Europe",
    "population": 83166711,
    "area": 357022,
    "languages": {
      "deu": "German"
    },
    "flag": "https://restcountries.com/v3.1/flags/de.png",
    "currencies": {
      "EUR": {
        "name": "Euro",
        "symbol": "€"
      }
    },
    "timezones": ["UTC+01:00"]
  }
]
Example API Calls
Here are a few examples of how to retrieve different kinds of country data:

1. Country Information by Name (e.g., "United States")
To retrieve data about the United States, send a request to:

bash
https://restcountries.com/v3.1/name/united states
2. Country Information by Alpha Code (e.g., "DE" for Germany)
To retrieve data about Germany using its alpha-2 country code:

bash
https://restcountries.com/v3.1/alpha/de
3. Country Information by Region (e.g., "Asia")
To retrieve a list of countries from the Asia region:

bash
https://restcountries.com/v3.1/region/asia
Example Using cURL (Command Line Tool)
To get the country information for Germany using cURL (a command-line tool for making API requests):

bash
curl https://restcountries.com/v3.1/name/germany
Example Using JavaScript (Fetch API)
You can also make API requests in JavaScript using the fetch method:

javascript
fetch('https://restcountries.com/v3.1/name/india')
  .then(response => response.json())
  .then(data => {
    console.log(data);
  })
  .catch(error => console.error('Error:', error));
This will fetch and log the information about India.

Handling API Responses
Once you receive the JSON response from the API, you can process and extract data to display it in your application. 
Here's an example of extracting a country’s name, capital, population, and languages:

javascript
fetch('https://restcountries.com/v3.1/name/france')
  .then(response => response.json())
  .then(data => {
    const country = data[0];
    console.log(`Name: ${country.name.common}`);
    console.log(`Capital: ${country.capital}`);
    console.log(`Population: ${country.population}`);
    console.log(`Languages: ${Object.values(country.languages).join(", ")}`);
  })
  .catch(error => console.error('Error:', error));

Lab:
 Use REST Countries API to fetch data for a specific country.

To fetch data for a specific country using the REST Countries API, you can make an HTTP request to the endpoint that 
returns information about that country. The API allows you to get details such as population, area, currencies, languages, 
flags, and more.

Here is an example of how you can use the REST Countries API in Python with the requests library to fetch data for a 
specific country:

Example code in Python
python
import requests

# Replace 'country_name' with the name of the country you want data for
country_name = 'Canada'

# Send a GET request to the REST Countries API
url = f'https://restcountries.com/v3.1/name/{country_name}'
response = requests.get(url)

# Check if the request was successful
if response.status_code == 200:
    # Parse the JSON response
    country_data = response.json()
    
    # Print some of the data
    print(f"Country: {country_data[0]['name']['common']}")
    print(f"Capital: {country_data[0]['capital'][0] if 'capital' in country_data[0] else 'N/A'}")
    print(f"Region: {country_data[0]['region']}")
    print(f"Subregion: {country_data[0]['subregion']}")
    print(f"Population: {country_data[0]['population']}")
    print(f"Area: {country_data[0]['area']} km²")
    print(f"Currency: {', '.join([currency for currency in country_data[0]['currencies'].keys()])}")
    print(f"Languages: {', '.join([lang for lang in country_data[0]['languages'].values()])}")
else:
    print("Failed to fetch country data.")
Explanation:
The API URL used here is https://restcountries.com/v3.1/name/{country_name} where {country_name} is replaced with the 
name of the country (in this case, "Canada").
The requests.get(url) sends the GET request to the API.
The response is processed in JSON format, which contains data about the country.
Data such as the capital, region, population, area, currency, and languages is extracted and printed.
Notes:
Replace 'Canada' with the country you are interested in.
You might need to install the requests library if you don't already have it installed by running:
pip install requests
This will give you a variety of details about the country you're querying.

Practical Example: 18) Write a Django project that displays details (population, language, currency) of a country 
entered by the user using the REST Countries API.

To create a Django project that allows the user to enter a country's name and displays details like population, 
language, and currency using the REST Countries API, follow the steps below.

Step 1: Install Dependencies
Make sure you have Django and the requests library installed:

bash
pip install django requests
Step 2: Set Up the Django Project
Create a new Django project:
bash
django-admin startproject country_details
cd country_details
Create a new Django app:
bash
python manage.py startapp country
Step 3: Update settings.py
In country_details/settings.py, add 'country' to the INSTALLED_APPS list.

python
INSTALLED_APPS = [
    ...
    'country',
]
Step 4: Create the Country Details View
Now, in the country/views.py, write a view to handle the form submission, fetch country details using the REST Countries 
API, and render the result.

python
import requests
from django.shortcuts import render

def get_country_details(request):
    country_data = None
    error_message = None
    
    if request.method == 'POST':
        country_name = request.POST.get('country')
        
        # Call the REST Countries API
        url = f"https://restcountries.com/v3.1/name/{country_name}?fullText=true"
        response = requests.get(url)
        
        if response.status_code == 200:
            country_info = response.json()[0]
            country_data = {
                'name': country_info.get('name', {}).get('common', 'N/A'),
                'population': country_info.get('population', 'N/A'),
                'languages': ', '.join(country_info.get('languages', {}).values()) if country_info.get('languages') else 'N/A',
                'currency': ', '.join(country_info.get('currencies', {}).keys()) if country_info.get('currencies') else 'N/A',
            }
        else:
            error_message = "Country not found. Please try again."

    return render(request, 'country/details.html', {'country_data': country_data, 'error_message': error_message})
Step 5: Set Up the Template
Create a folder named templates inside your country app folder, and then create a country/details.html template to 
display the country details.

country/templates/country/details.html
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Country Details</title>
</head>
<body>
    <h1>Enter a Country Name</h1>
    
    <form method="POST">
        {% csrf_token %}
        <label for="country">Country Name:</label>
        <input type="text" id="country" name="country" required>
        <button type="submit">Get Details</button>
    </form>

    {% if error_message %}
        <p style="color: red;">{{ error_message }}</p>
    {% endif %}

    {% if country_data %}
        <h2>Country Details</h2>
        <p><strong>Country:</strong> {{ country_data.name }}</p>
        <p><strong>Population:</strong> {{ country_data.population }}</p>
        <p><strong>Languages:</strong> {{ country_data.languages }}</p>
        <p><strong>Currency:</strong> {{ country_data.currency }}</p>
    {% endif %}
</body>
</html>
Step 6: Configure URL Routing
In country/urls.py, define the URL pattern for the get_country_details view.

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.get_country_details, name='get_country_details'),
]
In the country_details/urls.py file, include the country app's URLs.

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include('country.urls')),  # Include country app URLs
]
Step 7: Run the Django Development Server
Now that everything is set up, run the Django development server:

bash
python manage.py runserver
Step 8: Test the Application
Visit http://127.0.0.1:8000/ in your browser. You will see a form where you can enter a country's name. Upon submitting 
the form, the country’s population, languages, and currency will be displayed below the form.

Optional Improvements:
Error Handling: You can enhance error handling to deal with network issues or other edge cases.
User Input Validation: Ensure proper validation of user input to avoid malformed queries.
Styling: Add CSS to style the form and the results.
This simple Django project will display the population, languages, and currency of a country entered by the user using 
the REST Countries API.

19. Email Sending APIs (SendGrid, Mailchimp)
Theory:
 Using email sending APIs like SendGrid and Mailchimp to send transactional emails.

To send transactional emails using email sending APIs like SendGrid and Mailchimp, you'll need to follow a few steps, 
including setting up your account, integrating the API into your application, and configuring the email sending logic. 
Below is a general guide for each:

1. Using SendGrid API to Send Transactional Emails
SendGrid is a popular email API service that allows you to send email programmatically.

Step-by-Step Guide for SendGrid Integration
Sign Up for SendGrid Account:

Go to the SendGrid website and create an account.
Once logged in, generate an API key in the SendGrid dashboard under Settings > API Keys.
Install SendGrid's SDK:

Install SendGrid's official library using your preferred language (e.g., Python, Node.js, PHP, etc.).
For Python:

bash
pip install sendgrid
For Node.js:

bash
npm install @sendgrid/mail
Set Up SendGrid Client: Once you have the SDK installed, you can use your API key to authenticate the email client.

Example in Python:

python
import sendgrid
from sendgrid.helpers.mail import Mail, Email, To, Content

sg = sendgrid.SendGridAPIClient(api_key='YOUR_SENDGRID_API_KEY')

from_email = Email("your-email@example.com")
to_email = To("recipient@example.com")
subject = "Welcome to Our Service!"
content = Content("text/plain", "Thank you for signing up. We hope you enjoy our service.")

mail = Mail(from_email, to_email, subject, content)

try:
    response = sg.send(mail)
    print(response.status_code)
    print(response.body)
    print(response.headers)
except Exception as e:
    print(str(e))
Send Transactional Emails: After setting up the basic integration, you can send personalized transactional emails 
like password resets, order confirmations, etc.

Example:

Customize your email subject and content based on the type of transactional email.
Use dynamic templates in SendGrid for a more personalized and rich email experience.
Monitor Deliverability:

SendGrid provides metrics like delivery rates, bounce rates, and engagement reports to track the performance of your 
emails.
2. Using Mailchimp API to Send Transactional Emails
Mailchimp primarily focuses on marketing campaigns but also offers features for transactional emails through Mandrill 
(now part of Mailchimp).

Step-by-Step Guide for Mailchimp API Integration
Create a Mailchimp Account:

Go to the Mailchimp website and sign up for an account.
Get Mandrill API Key:

Mandrill is now a Mailchimp feature for transactional emails. You’ll need to enable Mandrill within your Mailchimp 
account (this may require a paid Mailchimp plan).
After enabling Mandrill, get your API key from the Mandrill dashboard.
Install Mailchimp SDK:

Similar to SendGrid, Mailchimp also has SDKs for various languages.
For Python:

bash
pip install mandrill
For Node.js:

bash
npm install mandrill-api
Set Up Mandrill Client: Use the Mandrill API key to authenticate and send emails.

Example in Python:

python
import mandrill

mandrill_client = mandrill.Mandrill('YOUR_MANDRILL_API_KEY')

message = {
    'from_email': 'your-email@example.com',
    'to': [{'email': 'recipient@example.com', 'name': 'Recipient'}],
    'subject': 'Your Account Activation',
    'text': 'Click here to activate your account: http://example.com/activate',
}

try:
    result = mandrill_client.messages.send(message=message)
    print(result)
except mandrill.Error as e:
    print(f'An error occurred: {e}')
Send Transactional Emails:

Mandrill supports rich, transactional email types like password resets, account activations, etc.
Use Mandrill’s templates feature to create dynamic, responsive transactional emails.
Send real-time email notifications to users.
Track Email Metrics:

Mandrill (via Mailchimp) provides analytics and reporting, such as open rates, click rates, and bounce rates, to 
measure the success of your emails.
Key Differences Between SendGrid and Mailchimp for Transactional Emails
SendGrid is primarily focused on email delivery, providing both marketing and transactional email services with robust 
API support. It offers better features for developers who need granular control over email sending, such as email logs, 
metrics, and various email templates.

Mailchimp, on the other hand, is more of a marketing tool, but its Mandrill API can be used to send transactional emails. 
It's ideal if you're already using Mailchimp for marketing and want to extend it to transactional messages.

Best Practices for Sending Transactional Emails
Use Customizable Templates: Both SendGrid and Mandrill offer the ability to use templates for consistent and personalized 
messages.
Test Emails: Always test your emails before going live to ensure they render correctly and look professional.
Monitor Deliverability: Track delivery and open rates to ensure your emails are reaching your customers.
Avoid Spam: Ensure your emails are not marked as spam by including proper email headers, offering opt-out options, and 
complying with email regulations like CAN-SPAM.
Both SendGrid and Mailchimp (Mandrill) are powerful solutions for sending transactional emails. Depending on your 
specific needs, such as simplicity or advanced email tracking and templates, either could be a good fit.

Lab:
 Implement email sending functionality in a Django project using SendGrid.

To implement email sending functionality in a Django project using SendGrid, follow the steps below. These steps 
will guide you through the process of setting up SendGrid, installing necessary dependencies, and configuring your 
Django project to send emails using SendGrid.

1. Create a SendGrid Account
First, sign up for a SendGrid account if you haven't already:

Go to SendGrid's website.
Sign up for an account.
After signing in, navigate to Settings > API Keys and create a new API key. This key will be used to authenticate your application to SendGrid.
2. Install SendGrid Python Package
Install the SendGrid Python package using pip. You can add it to your requirements.txt or directly install it:

bash
pip install sendgrid
Alternatively, if you use Django's email backend for sending emails, you can install the official Django SendGrid 
email backend package:

bash
pip install django-sendgrid-v5
3. Configure Django Settings
Now, configure your Django project to use SendGrid for sending emails. Open the settings.py file of your Django project 
and add the following configurations.

3.1. Add Email Backend Configuration
Add the SendGrid backend to the EMAIL_BACKEND setting:

python
EMAIL_BACKEND = "django_sendgrid_v5.backend.SendgridBackend"
3.2. Add SendGrid API Key
Set the SendGrid API key in the SENDGRID_API_KEY setting. For security, it’s a good practice to load sensitive information such as API keys from environment variables or Django's django-environ package.

Add the following settings in settings.py:

python
SENDGRID_API_KEY = os.getenv('SENDGRID_API_KEY')
Or if you are using django-environ to handle environment variables, load it like this:

python
import environ
env = environ.Env()

SENDGRID_API_KEY = env('SENDGRID_API_KEY')
Then, create a .env file (if using django-environ) to store your API key:

makefile
SENDGRID_API_KEY=your_sendgrid_api_key_here
Make sure that .env is added to your .gitignore to keep it secure.

3.3. Configure Default Email Settings
Set the default email sender and other email settings:

python
DEFAULT_FROM_EMAIL = 'your-email@example.com'
EMAIL_HOST = 'smtp.sendgrid.net'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = 'apikey'  # This is the fixed SendGrid SMTP username
EMAIL_HOST_PASSWORD = SENDGRID_API_KEY  # Your SendGrid API Key
4. Send Email Using SendGrid
Once you've configured your settings, you can now send emails using Django's built-in send_mail function or EmailMessage.

4.1. Using Django's send_mail Function
In your Django views or anywhere in your project where you want to send an email, use the following:

python
from django.core.mail import send_mail
from django.conf import settings

def send_test_email():
    subject = 'Test Email'
    message = 'This is a test email sent via SendGrid.'
    from_email = settings.DEFAULT_FROM_EMAIL
    recipient_list = ['recipient@example.com']
    
    send_mail(subject, message, from_email, recipient_list)
This will send an email to the specified recipient using SendGrid.

4.2. Using EmailMessage
Alternatively, you can use the EmailMessage class for more advanced email features like HTML content or attachments:

python
from django.core.mail import EmailMessage

def send_html_email():
    subject = 'Test HTML Email'
    message = 'This is an email with HTML content.'
    from_email = 'your-email@example.com'
    recipient_list = ['recipient@example.com']
    
    email = EmailMessage(subject, message, from_email, recipient_list)
    email.content_subtype = "html"  # Specify HTML content
    email.send()
5. Test the Email Functionality
Run your Django project and trigger the email function. If everything is set up correctly, the email should be sent 
through SendGrid.

For example, you could test it via a Django view or shell:

bash
python manage.py shell
Then in the shell:

python
from yourapp.views import send_test_email
send_test_email()
6. Optional: Using SendGrid Templates
If you prefer to use pre-configured email templates from SendGrid, you can integrate the SendGrid template ID in the 
send_mail or EmailMessage methods. You will 
need to use the sendgrid package for this, but it requires additional configuration in your SendGrid account.

For detailed documentation on template usage with SendGrid and Django, check out the SendGrid API documentation: 
https://docs.sendgrid.com/

Summary of Steps
Create a SendGrid account and generate an API key.
Install the django-sendgrid-v5 package (or sendgrid Python package).
Configure the SendGrid settings in Django's settings.py.
Use Django's email functions (send_mail, EmailMessage) to send emails

Practical Example: 19) Write a Django project to send a confirmation email to a user using the SendGrid API after 
successful registration.

To send a confirmation email to a user after successful registration using the SendGrid API in a Django project, you 
can follow these steps. This tutorial assumes you have basic knowledge of Django and a SendGrid account for API access.

Steps:
Install Dependencies: You need to install django, sendgrid (for sending emails), and django-environ (for managing 
environment variables).

Run the following commands to install the dependencies:

bash
pip install django
pip install sendgrid
pip install django-environ
Set up Django Project: Create a new Django project and app (if you haven't already):

bash
django-admin startproject myproject
cd myproject
python manage.py startapp accounts
Add accounts App to Settings: In your settings.py, add 'accounts' to the INSTALLED_APPS list.

python
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'accounts',  # Your app
]
Set up SendGrid API Key: Sign up at SendGrid and generate an API key. Then, store this API key securely in 
your .env file.

Create a .env file in the root directory of your project:

env
SENDGRID_API_KEY='your_sendgrid_api_key'
In your settings.py, configure Django to use environment variables:

python
import environ

env = environ.Env()
environ.Env.read_env()

SENDGRID_API_KEY = env('SENDGRID_API_KEY')
Create a Form for User Registration: In the accounts app, create a user registration form 
using django.contrib.auth.forms.UserCreationForm or a custom form.

accounts/forms.py:

python
from django import forms
from django.contrib.auth.forms import UserCreationForm
from django.contrib.auth.models import User

class CustomUserCreationForm(UserCreationForm):
    email = forms.EmailField()

    class Meta:
        model = User
        fields = ['username', 'email', 'password1', 'password2']
Create a User Registration View: Create a view to handle the user registration process. Upon successful registration, 
send the confirmation email.

accounts/views.py:

python
from django.shortcuts import render, redirect
from django.contrib.auth import login
from django.contrib.auth.forms import UserCreationForm
from django.contrib import messages
from .forms import CustomUserCreationForm
from django.core.mail import send_mail
from django.conf import settings
import sendgrid
from sendgrid.helpers.mail import Mail, Email, To, Content

def send_confirmation_email(user_email):
    sg = sendgrid.SendGridAPIClient(api_key=settings.SENDGRID_API_KEY)
    from_email = Email("noreply@example.com")
    to_email = To(user_email)
    subject = "Confirm your email address"
    content = Content("text/plain", "Thank you for registering. Please confirm your email.")
    mail = Mail(from_email, to_email, subject, content)

    try:
        response = sg.send(mail)
        print(f"Email sent with status code {response.status_code}")
    except Exception as e:
        print(f"Error sending email: {str(e)}")

def register(request):
    if request.method == "POST":
        form = CustomUserCreationForm(request.POST)
        if form.is_valid():
            user = form.save()
            login(request, user)
            send_confirmation_email(user.email)
            messages.success(request, "Registration successful! A confirmation email has been sent.")
            return redirect('home')  # Redirect to home or dashboard after successful registration
    else:
        form = CustomUserCreationForm()

    return render(request, 'accounts/register.html', {'form': form})
Create a Template for Registration: Create a simple registration form template for users to enter their details.

accounts/templates/accounts/register.html:

html
<h2>Register</h2>
<form method="POST">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Register</button>
</form>
Configure URL Routing: In accounts/urls.py, add the route for the registration view.

accounts/urls.py:

python
from django.urls import path
from . import views

urlpatterns = [
    path('register/', views.register, name='register'),
]
In myproject/urls.py, include the accounts URLs.

myproject/urls.py:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('accounts/', include('accounts.urls')),
]
SendGrid Email Settings: You should ensure the correct configurations for sending emails through SendGrid in 
settings.py.

python
EMAIL_BACKEND = 'django.core.mail.backends.smtp.EmailBackend'
EMAIL_HOST = 'smtp.sendgrid.net'
EMAIL_PORT = 587
EMAIL_USE_TLS = True
EMAIL_HOST_USER = 'apikey'  # Username is 'apikey' for SendGrid
EMAIL_HOST_PASSWORD = SENDGRID_API_KEY  # Use the SendGrid API key here
Testing the Registration: Run your Django server:

bash
python manage.py runserver
Visit http://127.0.0.1:8000/accounts/register/, fill in the registration form, and upon success, a confirmation email 
should be sent to the user.

Final Notes:
Ensure the user email is validated correctly in your registration form.
You can enhance the email content and structure by using HTML, images, and other resources in the SendGrid API.
This solution uses SendGrid’s email API directly, but you could also use Django’s built-in email backend with 
django.core.mail.send_mail if you prefer.

20. SMS Sending APIs (Twilio)
Theory:
 Introduction to Twilio API for sending SMS and OTPs.

Introduction to Twilio API for Sending SMS and OTPs
Twilio is a cloud communications platform that provides APIs for sending and receiving text messages, making voice calls, 
and performing other communication tasks. One of its popular features is the ability to send SMS messages, including 
One-Time Passwords (OTPs), which are commonly used for authentication in various applications.

Here’s a basic guide on how to get started with Twilio API to send SMS and OTPs:

1. Sign Up for Twilio
Before you can start using the Twilio API, you'll need to:

Create an account on Twilio: Twilio Sign Up.
After signing up, you'll be provided with a Twilio phone number (for sending SMS).
You'll also get your Account SID and Auth Token, which are required for authenticating API requests.
2. Install Twilio SDK
To interact with the Twilio API in your application, you need to install the official Twilio SDK for your programming 
language. Twilio provides SDKs for Python, JavaScript, Ruby, PHP, and others.

For Python:
bash
pip install twilio
For Node.js (JavaScript):
bash
npm install twilio
3. Set Up the Environment
You need to configure your environment with your Twilio Account SID, Auth Token, and Phone Number.

python
from twilio.rest import Client

# Your Twilio Account SID and Auth Token
account_sid = 'your_account_sid'
auth_token = 'your_auth_token'

# Initialize the Twilio client
client = Client(account_sid, auth_token)
4. Send an SMS Using Twilio API
You can now send an SMS message using Twilio’s REST API. For example, here's how you can send a basic text message:

python
message = client.messages.create(
    body="Hello, this is a test message from Twilio!",  # SMS content
    from_='+1234567890',  # Twilio phone number
    to='+0987654321'      # Recipient's phone number
)

print(message.sid)  # Print the SID of the sent message
5. Generating OTPs
For OTP generation, you would typically create a random number or code that expires after a short period. Here’s an 
example of how to generate a random OTP and send it via SMS:

Generate OTP (e.g., 6 digits):
python
import random

# Generate a random 6-digit OTP
otp = random.randint(100000, 999999)
print(f"Your OTP is: {otp}")
6. Send OTP via SMS
python
# Send OTP to user via SMS
message = client.messages.create(
    body=f"Your OTP is {otp}",  # Include the OTP in the message
    from_='+1234567890',  # Twilio phone number
    to='+0987654321'      # Recipient's phone number
)

print(f"OTP sent with SID: {message.sid}")
7. Verify OTP (Optional)
Once you’ve sent the OTP, you can implement logic to verify the OTP entered by the user. This typically involves saving 
the OTP and a timestamp in your database, and validating that the OTP is entered correctly within the valid time window.

8. Twilio Features for OTPs
Twilio Verify API: Twilio offers a dedicated Verify API, which is optimized for OTP generation, delivery, and validation. 
It simplifies the OTP flow with features like rate limiting, retry logic, and expiration handling.

To use the Twilio Verify API, you need to set it up as follows:

python
from twilio.rest import Client

client = Client(account_sid, auth_token)

verification = client.verify.services("your_service_sid").verifications.create(
    to='+0987654321',  # The phone number to receive the OTP
    channel='sms'      # Use 'sms' for SMS-based OTPs
)

print(f"OTP verification SID: {verification.sid}")
Note: Twilio Verify requires creating a service in the Twilio console. You'll need to obtain the Service SID from the 
Twilio console.

9. Handling OTP Expiry and Security
Expiry: Set an expiration time for the OTP (commonly 5-10 minutes).
Attempts Limitation: Limit the number of OTP attempts to avoid brute-force attacks.
Secure Storage: Store OTPs securely in your backend system (ideally hashed or encrypted).
10. Best Practices for Using OTPs
Use Strong OTP Generation: Use a secure random number generator for OTPs.
Limit OTP Attempts: Prevent multiple attempts within a short period to protect against brute-force attacks.
Rate Limiting: Implement rate-limiting to prevent abuse.
Expire OTPs: Ensure OTPs expire after a certain time, usually a few minutes.

Lab:
 Use Twilio API to send OTP to a user’s phone.

To send an OTP (One-Time Password) to a user's phone using Twilio API, you need to follow these steps:

1. Create a Twilio Account
If you don't already have one, create an account at Twilio. Once registered, you'll get your Account SID and Auth Token, 
which you'll need to authenticate your API calls.

2. Set Up Your Twilio Phone Number
You need a Twilio phone number to send SMS messages. You can obtain one from your Twilio console:

Navigate to Twilio Console.
Go to the Phone Numbers section and buy a number.
This number will be used to send OTPs.
3. Install Twilio SDK
To interact with the Twilio API, you need to install the Twilio SDK for Python. You can install it using pip:

bash
pip install twilio
4. Generate the OTP
You can generate a random OTP using Python. A typical OTP length is 6 digits.

5. Send the OTP via Twilio API
Here is a Python script that uses the Twilio API to send an OTP to the user's phone.

python
import random
from twilio.rest import Client

# Your Twilio credentials (Account SID and Auth Token)
account_sid = 'your_account_sid'
auth_token = 'your_auth_token'

# Twilio phone number you purchased
twilio_number = 'your_twilio_phone_number'

# The phone number to send the OTP to
user_phone_number = '+1234567890'  # replace with the recipient's phone number

# Generate a 6-digit OTP
otp = str(random.randint(100000, 999999))

# Set up the Twilio client
client = Client(account_sid, auth_token)

# Send the OTP via SMS
message = client.messages.create(
    body=f'Your OTP is: {otp}',
    from_=twilio_number,
    to=user_phone_number
)

# Print message SID for confirmation
print(f'Message SID: {message.sid}')
Explanation:
Generate OTP: The random.randint(100000, 999999) generates a random 6-digit OTP.
Twilio Client: The Twilio Client object is initialized with your Account SID and Auth Token.
Send SMS: The client.messages.create function sends the SMS to the user_phone_number with the OTP message.
Message SID: The script prints out the SID of the sent message for tracking.
6. Run the Script
When you run this script, it will send an OTP to the provided phone number via the Twilio service.

Notes:
Account SID and Auth Token are sensitive information. Make sure not to expose them publicly.
The twilio_number must be a valid Twilio number capable of sending SMS messages.
Twilio’s free trial account provides limited credits, so you might want to upgrade to a paid account if you intend to 
send a large number of OTPs.
Example Output:
mathematica
Message SID: SMXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
This confirms that the OTP has been successfully sent.

Practical Example: 20) Write a Django project that sends an OTP to the user's mobile number during registration using 
Twilio API.

To create a Django project that sends an OTP (One Time Password) to a user's mobile number during registration using the 
Twilio API, follow these steps:

Prerequisites
Install Django: Make sure you have Python installed, and then install Django if you haven't already.

bash
pip install django
Install Twilio SDK: Install the Twilio Python SDK to interact with the Twilio API.

bash
pip install twilio
Get Twilio Account SID and Auth Token: Sign up for a Twilio account if you don't have one at Twilio. After registering, 
you'll get an Account SID, Auth Token, and a Twilio phone number that you can use for sending SMS.

Steps to Implement the Django OTP Registration:
Create a new Django project and app:

bash
django-admin startproject otp_project
cd otp_project
python manage.py startapp users
Install necessary libraries:

bash
pip install twilio
Set up the Twilio environment: Create a .env file (or set environment variables) to securely store your Twilio credentials.

ini
TWILIO_ACCOUNT_SID='your_twilio_account_sid'
TWILIO_AUTH_TOKEN='your_twilio_auth_token'
TWILIO_PHONE_NUMBER='+your_twilio_phone_number'
Configure Django settings:

In settings.py, add users to the INSTALLED_APPS list and set up environment variables for Twilio:

python
import os
from dotenv import load_dotenv
load_dotenv()  # Load environment variables from .env file

INSTALLED_APPS = [
    # Your other apps
    'users',
]

# Twilio Settings
TWILIO_ACCOUNT_SID = os.getenv('TWILIO_ACCOUNT_SID')
TWILIO_AUTH_TOKEN = os.getenv('TWILIO_AUTH_TOKEN')
TWILIO_PHONE_NUMBER = os.getenv('TWILIO_PHONE_NUMBER')
Create models for user registration:

In users/models.py, create a simple User model (you can extend this with more fields as needed):

python
from django.db import models

class User(models.Model):
    phone_number = models.CharField(max_length=15, unique=True)
    otp = models.CharField(max_length=6)
    is_verified = models.BooleanField(default=False)

    def __str__(self):
        return self.phone_number
Create a form for user registration:

In users/forms.py, create a form to handle phone number input during registration:

python
from django import forms
from .models import User

class UserRegistrationForm(forms.ModelForm):
    class Meta:
        model = User
        fields = ['phone_number']
Create a view to handle OTP generation and sending:

In users/views.py, add a view to handle registration, OTP generation, and sending:

python
import random
from twilio.rest import Client
from django.conf import settings
from django.shortcuts import render, redirect
from django.contrib import messages
from .forms import UserRegistrationForm
from .models import User

# Generate a random OTP
def generate_otp():
    return str(random.randint(100000, 999999))

# Send OTP using Twilio API
def send_otp(phone_number, otp):
    client = Client(settings.TWILIO_ACCOUNT_SID, settings.TWILIO_AUTH_TOKEN)
    message = client.messages.create(
        body=f"Your OTP code is {otp}",
        from_=settings.TWILIO_PHONE_NUMBER,
        to=phone_number
    )
    return message.sid

def register(request):
    if request.method == 'POST':
        form = UserRegistrationForm(request.POST)
        if form.is_valid():
            phone_number = form.cleaned_data['phone_number']
            otp = generate_otp()

            # Save the user with the OTP (not verified yet)
            user = form.save(commit=False)
            user.otp = otp
            user.save()

            # Send OTP to the user's phone number
            send_otp(phone_number, otp)

            messages.success(request, 'OTP sent to your phone number. Please verify it.')
            return redirect('verify_otp', user_id=user.id)  # Redirect to OTP verification view
    else:
        form = UserRegistrationForm()

    return render(request, 'users/register.html', {'form': form})

def verify_otp(request, user_id):
    user = User.objects.get(id=user_id)
    if request.method == 'POST':
        entered_otp = request.POST['otp']
        if entered_otp == user.otp:
            user.is_verified = True
            user.save()
            messages.success(request, 'Phone number verified successfully!')
            return redirect('login')  # Redirect to login or other view after verification
        else:
            messages.error(request, 'Invalid OTP. Please try again.')

    return render(request, 'users/verify_otp.html', {'user': user})
Create the necessary templates:

Create two HTML templates for registration and OTP verification.

users/templates/users/register.html:

html
<form method="POST">
    {% csrf_token %}
    {{ form.as_p }}
    <button type="submit">Register</button>
</form>
users/templates/users/verify_otp.html:

html
<form method="POST">
    {% csrf_token %}
    <label for="otp">Enter OTP:</label>
    <input type="text" name="otp" required>
    <button type="submit">Verify OTP</button>
</form>
Add URL routes for registration and OTP verification:

In users/urls.py, define the routes for registration and OTP verification.

python
from django.urls import path
from . import views

urlpatterns = [
    path('register/', views.register, name='register'),
    path('verify-otp/<int:user_id>/', views.verify_otp, name='verify_otp'),
]
And include the users app URLs in the main otp_project/urls.py:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('users/', include('users.urls')),
]
Apply migrations:

Run the following commands to apply migrations:

bash
python manage.py makemigrations
python manage.py migrate
Run the development server:
Finally, run the server:

bash
python manage.py runserver
Now, you can access your registration page at http://127.0.0.1:8000/users/register/. Upon entering a phone number, 
the OTP will be sent using Twilio, and the user will be able to verify the OTP on the next page.

21. Payment Integration (PayPal, Stripe)
Theory:
 Introduction to integrating payment gateways like PayPal and Stripe.

Introduction to Integrating Payment Gateways like PayPal and Stripe
Payment gateways like PayPal and Stripe are essential tools for processing online payments. They allow businesses to 
accept payments from customers through various methods, such as credit cards, debit cards, and digital wallets, 
securely and efficiently. Integrating payment gateways into your website or app ensures seamless transactions for your 
customers and helps businesses manage their payments.

Here’s a breakdown of the two major payment gateways—PayPal and Stripe—and an introduction to how to integrate them:

1. What are Payment Gateways?
A payment gateway is a service that authorizes and processes payments in online stores. It securely transmits the 
customer’s payment details to the merchant’s bank or processor and returns a transaction status. Common examples include 
PayPal, Stripe, and others like Square and Razorpay.

2. Why Use Payment Gateways?
Security: Payment gateways encrypt sensitive financial data, ensuring a secure transaction.
Global Reach: Accept payments from customers anywhere in the world.
Convenience: Customers can pay using various methods such as credit cards, PayPal accounts, or even cryptocurrencies.
Easy Integration: Payment gateways offer developer-friendly APIs to integrate with your website or app.
3. Popular Payment Gateways: PayPal and Stripe
PayPal
PayPal is one of the most widely recognized online payment platforms. It allows businesses to receive payments quickly 
and securely. With PayPal, you can accept payments from users with PayPal accounts or even credit and debit cards.

Pros of PayPal:
Easy to integrate: PayPal provides various integration options, including hosted solutions (for a simpler setup) and 
API integrations for advanced customization.
Widely recognized: Since many people already have PayPal accounts, it increases trust and ease for customers.
Global coverage: PayPal supports transactions in over 200 countries and in multiple currencies.
Cons of PayPal:
Transaction fees: PayPal charges fees, including a percentage of each transaction and fixed fees based on currency.
Account freezes: There are instances where PayPal can freeze accounts due to disputes or issues, which might disrupt 
business operations.
Stripe
Stripe is another popular and robust payment gateway, known for its powerful APIs that allow businesses to create 
customized payment solutions. It is especially favored by developers for its flexibility.

Pros of Stripe:
Highly customizable: Stripe's API gives developers the ability to integrate a variety of payment options and customize 
the checkout flow.
Great for recurring payments: It’s a popular choice for subscription-based businesses.
International payments: Supports multiple currencies and international payment methods.
Transparent pricing: Stripe has simple and transparent fee structures.
Cons of Stripe:
Developer knowledge required: It requires more technical knowledge to integrate compared to other gateways like PayPal.
Limited support for non-developer users: It’s designed for businesses that need more advanced configurations.
4. How to Integrate PayPal and Stripe
Integrating PayPal
There are several ways to integrate PayPal into your site:

PayPal Buttons (easy integration): This allows you to add a PayPal button directly to your website where users can pay 
via their PayPal accounts or credit/debit cards.
Create a PayPal business account.
Generate a "Buy Now" or "Donate" button.
Paste the HTML code into your website.
PayPal API (advanced integration): For more flexibility, you can use the PayPal REST APIs, which allow you to handle 
transactions, subscriptions, and other features programmatically.
Create a PayPal developer account and get API credentials (Client ID and Secret).
Use PayPal’s SDKs for the programming language of your choice (PHP, Python, Node.js, etc.).
Implement functions to handle payment requests and responses.
Integrating Stripe
Stripe is generally more developer-focused but provides powerful features:

Stripe Checkout (easy integration): Stripe Checkout is a pre-built, secure payment page that you can embed on your site.

Set up a Stripe account and obtain API keys.
Install Stripe's official libraries for your programming language.
Use the Stripe API to create a payment intent and redirect users to the Stripe-hosted checkout page.
Custom Integration (advanced integration): For a fully customized payment form, you can use Stripe’s API to handle the 
payment process on your own page.

Implement Stripe Elements, a set of pre-built UI components for securely handling payment details.
Use the Stripe API to securely process payments and store customer data as needed.
5. Best Practices for Integration
Security: Always use SSL/TLS encryption on your website to secure payment data. Follow PCI-DSS guidelines for storing and 
handling sensitive payment information.
User Experience (UX): Make the payment process seamless, easy to navigate, and transparent. Avoid asking for unnecessary 
information.
Mobile-friendly: Ensure your payment process works well on mobile devices, as many users shop via smartphones.
Test your integration: Always test payment gateways thoroughly in a sandbox environment to make sure the process works 
smoothly before going live.
Comply with local laws: Be aware of the payment processing regulations in your country or region, such as GDPR in Europe 
or PCI compliance requirements.

Lab:
 Add Stripe payment functionality to a Django project.

To integrate Stripe payment functionality into a Django project, you need to follow a series of steps to handle 
payments securely. Here's a step-by-step guide to help you add Stripe payment functionality to your Django project:

1. Install Required Packages
Start by installing the required packages:

bash
pip install stripe
pip install django-environ
stripe is the official Stripe library to interact with the Stripe API.
django-environ helps with environment variable management (to securely store API keys).
2. Set Up Stripe Account
Go to Stripe and create an account if you don't have one.
Get your API keys (Publishable key and Secret key) from the Stripe Dashboard:
Go to Developers > API Keys to find them.
Use the Test keys for development.
3. Configure Environment Variables
Create a .env file in the root of your project to store sensitive information like your Stripe API keys.

bash
# .env file
STRIPE_TEST_PUBLISHABLE_KEY=your_test_publishable_key
STRIPE_TEST_SECRET_KEY=your_test_secret_key
Now, load these variables in your Django settings by adding the following to settings.py:

python
import environ

# Initialize environment variables
env = environ.Env()
environ.Env.read_env()

# Stripe Keys
STRIPE_TEST_PUBLISHABLE_KEY = env('STRIPE_TEST_PUBLISHABLE_KEY')
STRIPE_TEST_SECRET_KEY = env('STRIPE_TEST_SECRET_KEY')
4. Create a Payment Form
You need a form that allows users to enter their payment details. Create a template that includes Stripe's Checkout or a 
custom form using Stripe Elements.

Example HTML template (payment.html):
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Payment</title>
    <script src="https://js.stripe.com/v3/"></script>
</head>
<body>
    <h2>Complete Payment</h2>
    <form action="{% url 'process_payment' %}" method="POST" id="payment-form">
        {% csrf_token %}
        <div id="card-element">
            <!-- A Stripe Element will be inserted here. -->
        </div>

        <!-- Used to display form errors. -->
        <div id="card-errors" role="alert"></div>

        <button type="submit">Submit Payment</button>
    </form>

    <script type="text/javascript">
        var stripe = Stripe('{{ STRIPE_TEST_PUBLISHABLE_KEY }}');
        var elements = stripe.elements();
        var style = {
            base: {
                color: '#32325d',
                fontFamily: '"Helvetica Neue", Helvetica, sans-serif',
                fontSmoothing: 'antialiased',
                fontSize: '16px',
                '::placeholder': {
                    color: '#aab7c4'
                }
            },
            invalid: {
                color: '#fa755a',
                iconColor: '#fa755a'
            }
        };

        var card = elements.create('card', { style: style });
        card.mount('#card-element');

        // Handle form submission
        var form = document.getElementById('payment-form');
        form.addEventListener('submit', function(event) {
            event.preventDefault();

            stripe.createToken(card).then(function(result) {
                if (result.error) {
                    // Show error in the card element
                    var errorElement = document.getElementById('card-errors');
                    errorElement.textContent = result.error.message;
                } else {
                    // Send the token to your server
                    stripeTokenHandler(result.token);
                }
            });
        });

        function stripeTokenHandler(token) {
            // Insert the token into the form and submit it
            var form = document.getElementById('payment-form');
            var hiddenInput = document.createElement('input');
            hiddenInput.setAttribute('type', 'hidden');
            hiddenInput.setAttribute('name', 'stripeToken');
            hiddenInput.setAttribute('value', token.id);
            form.appendChild(hiddenInput);

            form.submit();
        }
    </script>
</body>
</html>
This template includes a form with a Stripe card Element, which securely collects card details.

5. Create the Payment View
Now, create a Django view to handle the payment process.

In your views.py:

python
import stripe
from django.conf import settings
from django.shortcuts import render, redirect
from django.http import JsonResponse
from .models import Order  # Your model for orders or transactions

stripe.api_key = settings.STRIPE_TEST_SECRET_KEY

def payment_view(request):
    if request.method == 'GET':
        return render(request, 'payment.html', {
            'STRIPE_TEST_PUBLISHABLE_KEY': settings.STRIPE_TEST_PUBLISHABLE_KEY
        })
    elif request.method == 'POST':
        token = request.POST.get('stripeToken')
        
        # Create a charge
        try:
            charge = stripe.Charge.create(
                amount=1000,  # Amount in cents (e.g., 1000 = $10)
                currency='usd',
                description='Example Charge',
                source=token,
            )
            
            # Store the payment info in the database, if applicable
            # For example, create an order object
            order = Order.objects.create(
                user=request.user,
                amount=10.00,
                stripe_charge_id=charge.id
            )
            
            return JsonResponse({'status': 'success', 'charge': charge})
        except stripe.error.StripeError as e:
            return JsonResponse({'error': str(e)})

    return render(request, 'payment.html')
This view handles both the GET request to render the payment form and the POST request to process the payment once 
the form is submitted.
The stripe.Charge.create method initiates the payment and returns the charge details, which you can store in your 
database.
6. Add URLs for Payment Views
In urls.py, add a URL pattern for the payment view:

python
from django.urls import path
from . import views

urlpatterns = [
    path('payment/', views.payment_view, name='payment'),
]
7. Testing
Run your Django server (python manage.py runserver).
Go to the /payment page.
Use Stripe's test card details (like 4242 4242 4242 4242 with any future expiration date and any CVC) to test the 
payment functionality.
8. Handle Payment Success or Failure
You can redirect the user to different pages based on the result of the charge (e.g., a "success" or "failure" page).

Example:

python
if charge['status'] == 'succeeded':
    return redirect('payment_success')
else:
    return redirect('payment_failed')
9. Go Live
Once you're ready to go live, you need to:

Switch to live keys in your .env file:
Get the live keys from the Stripe Dashboard.
Change the stripe.api_key to use the live secret key.

Practical Example: 21) Write a Django project to allow users to make payments via Stripe for booking doctor appointments.

To create a Django project that allows users to make payments via Stripe for booking doctor appointments, you will 
need to integrate Stripe's payment gateway and set up the necessary models, views, and templates for users to book 
appointments.

Here’s a step-by-step guide to help you get started:

Step 1: Install Dependencies
First, you need to install the required libraries:

Django for the web framework.
stripe for Stripe API integration.
django-environ for managing environment variables (like your Stripe secret key).
Run the following commands to install them:

bash
pip install django stripe django-environ
Step 2: Set Up the Django Project
Create a new Django project and app:

bash
django-admin startproject doctor_booking
cd doctor_booking
django-admin startapp appointments
Step 3: Configure Stripe API Keys
Create a .env file in the root directory of the project and add your Stripe API keys (you can get these from your 
Stripe Dashboard).

vbnet
STRIPE_TEST_PUBLIC_KEY=your-public-key
STRIPE_TEST_SECRET_KEY=your-secret-key
In your settings.py file, load the environment variables using django-environ:

python
import environ

# Initialize environment variables
env = environ.Env()
environ.Env.read_env()

# Stripe settings
STRIPE_TEST_PUBLIC_KEY = env('STRIPE_TEST_PUBLIC_KEY')
STRIPE_TEST_SECRET_KEY = env('STRIPE_TEST_SECRET_KEY')
Step 4: Define Models
In the appointments app, define models for the doctor, appointment, and payment.

python
# appointments/models.py
from django.db import models

class Doctor(models.Model):
    name = models.CharField(max_length=100)
    specialization = models.CharField(max_length=100)
    hourly_rate = models.DecimalField(max_digits=6, decimal_places=2)

    def __str__(self):
        return self.name

class Appointment(models.Model):
    doctor = models.ForeignKey(Doctor, on_delete=models.CASCADE)
    patient_name = models.CharField(max_length=100)
    appointment_time = models.DateTimeField()
    is_paid = models.BooleanField(default=False)
    
    def __str__(self):
        return f"{self.patient_name} with {self.doctor.name} on {self.appointment_time}"
Step 5: Set Up Stripe Payment Views
In your views.py, set up views to handle the booking process, including generating a Stripe session and processing 
the payment.

python
# appointments/views.py
import stripe
from django.conf import settings
from django.shortcuts import render, redirect
from .models import Doctor, Appointment
from django.views.decorators.csrf import csrf_exempt

# Set Stripe secret key
stripe.api_key = settings.STRIPE_TEST_SECRET_KEY

def book_appointment(request, doctor_id):
    doctor = Doctor.objects.get(id=doctor_id)
    
    # Handle form submission for appointment
    if request.method == "POST":
        patient_name = request.POST["patient_name"]
        appointment_time = request.POST["appointment_time"]
        
        # Create an Appointment object
        appointment = Appointment.objects.create(
            doctor=doctor,
            patient_name=patient_name,
            appointment_time=appointment_time,
        )
        
        # Create a Stripe Checkout session
        checkout_session = stripe.checkout.Session.create(
            payment_method_types=['card'],
            line_items=[
                {
                    'price_data': {
                        'currency': 'usd',
                        'product_data': {
                            'name': f'Appointment with Dr. {doctor.name}',
                        },
                        'unit_amount': int(doctor.hourly_rate * 100),  # Price in cents
                    },
                    'quantity': 1,
                },
            ],
            mode='payment',
            success_url=request.build_absolute_uri('/appointments/success/'),
            cancel_url=request.build_absolute_uri('/appointments/cancel/'),
            metadata={'appointment_id': appointment.id}
        )
        
        return redirect(checkout_session.url, code=303)

    return render(request, 'appointments/book_appointment.html', {'doctor': doctor})

@csrf_exempt
def payment_success(request):
    return render(request, 'appointments/success.html')

@csrf_exempt
def payment_cancel(request):
    return render(request, 'appointments/cancel.html')
Step 6: Set Up URLs
Now, create the URLs for booking the appointment and the payment success/cancel pages.

python
# appointments/urls.py
from django.urls import path
from . import views

urlpatterns = [
    path('book/<int:doctor_id>/', views.book_appointment, name='book_appointment'),
    path('success/', views.payment_success, name='payment_success'),
    path('cancel/', views.payment_cancel, name='payment_cancel'),
]
Make sure to include the appointments URLs in your main project’s urls.py:

python
# doctor_booking/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('appointments/', include('appointments.urls')),
]
Step 7: Create Templates
Create the templates for booking an appointment, payment success, and cancel pages.

book_appointment.html:

html
<form method="POST">
    {% csrf_token %}
    <input type="text" name="patient_name" placeholder="Your Name" required><br>
    <input type="datetime-local" name="appointment_time" required><br>
    <button type="submit">Book Appointment</button>
</form>
success.html:

html
<h2>Payment Successful!</h2>
<p>Your appointment has been booked. You will receive a confirmation email shortly.</p>
cancel.html:

html
<h2>Payment Canceled</h2>
<p>Your payment was not completed. Please try again.</p>
Step 8: Stripe Webhook (Optional)
To handle post-payment actions (e.g., marking the appointment as paid), you can use Stripe’s webhook feature. Here’s 
how to set it up:

Create a webhook view to handle Stripe events.
python
# appointments/views.py (add webhook view)
import json
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.conf import settings
import stripe
from .models import Appointment

@csrf_exempt
def stripe_webhook(request):
    payload = request.body
    sig_header = request.META['HTTP_STRIPE_SIGNATURE']
    event = None

    # Retrieve the webhook secret from your environment variables
    endpoint_secret = settings.STRIPE_WEBHOOK_SECRET

    try:
        # Verify the webhook signature
        event = stripe.Webhook.construct_event(payload, sig_header, endpoint_secret)
    except ValueError as e:
        # Invalid payload
        return JsonResponse({'status': 'failed'}, status=400)
    except stripe.error.SignatureVerificationError as e:
        # Invalid signature
        return JsonResponse({'status': 'failed'}, status=400)

    # Handle the event
    if event['type'] == 'checkout.session.completed':
        session = event['data']['object']  # contains a stripe.PaymentIntent
        appointment_id = session['metadata']['appointment_id']
        appointment = Appointment.objects.get(id=appointment_id)
        appointment.is_paid = True
        appointment.save()

    return JsonResponse({'status': 'success'}, status=200)
Update urls.py to include the webhook:
python
# appointments/urls.py
urlpatterns = [
    path('book/<int:doctor_id>/', views.book_appointment, name='book_appointment'),
    path('success/', views.payment_success, name='payment_success'),
    path('cancel/', views.payment_cancel, name='payment_cancel'),
    path('webhook/', views.stripe_webhook, name='stripe_webhook'),
]
Step 9: Run the Project
Make sure to apply migrations, run the Django development server, and test the Stripe payment integration:

bash
python manage.py migrate
python manage.py runserver

22. Google Maps API Integration
Theory:
 Using Google Maps API to display maps and calculate distances between locations.

To use the Google Maps API to display maps and calculate distances between locations, you need to follow several steps, 
which include obtaining an API key, setting up the Google Maps JavaScript API, and utilizing the Distance Matrix API for 
calculating distances.

Here is a basic guide on how to get started:

1. Set Up Google Cloud Project and API Key
To access Google Maps services, you first need to set up a Google Cloud project and get an API key.

Go to the Google Cloud Console: Google Cloud Console.
Create a new project: In the console, create a new project.
Enable APIs:
Search for Google Maps JavaScript API and Distance Matrix API, then enable them.
Get an API key:
Navigate to the Credentials section of your Google Cloud project.
Create a new API key and restrict it (optional but recommended) to specific IPs or HTTP referrers.
2. HTML and JavaScript for Displaying a Map
To display a map on a webpage using the Google Maps JavaScript API, you need to include the API script in your HTML file. 
Here's an example of how to display a map:

html
<!DOCTYPE html>
<html>
  <head>
    <title>Simple Map</title>
    <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&callback=initMap"
    async defer></script>
    <script>
      var map;
      function initMap() {
        // Create a new map centered on a specific location (e.g., New York)
        map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: 40.7128, lng: -74.0060}, // New York's latitude and longitude
          zoom: 10
        });
        
        // Add a marker at the same location
        var marker = new google.maps.Marker({
          position: {lat: 40.7128, lng: -74.0060},
          map: map
        });
      }
    </script>
  </head>
  <body onload="initMap()">
    <div id="map" style="height: 500px; width: 100%;"></div>
  </body>
</html>
Replace YOUR_API_KEY with your actual API key.

3. Calculating Distance Using the Distance Matrix API
You can calculate the distance between two or more locations using the Google Maps Distance Matrix API. The API will 
provide you with travel times and distances. Here's an example of how to use it:

html
<!DOCTYPE html>
<html>
  <head>
    <title>Distance Matrix Example</title>
    <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&libraries=places&callback=initMap" async defer></script>
    <script>
      var directionsService = new google.maps.DirectionsService();
      var directionsRenderer = new google.maps.DirectionsRenderer();
      var map;

      function initMap() {
        map = new google.maps.Map(document.getElementById('map'), {
          center: {lat: 40.7128, lng: -74.0060},
          zoom: 12
        });
        directionsRenderer.setMap(map);
      }

      function calculateRoute() {
        var request = {
          origin: 'New York, NY',  // Starting point
          destination: 'Los Angeles, CA', // Destination point
          travelMode: google.maps.TravelMode.DRIVING
        };

        directionsService.route(request, function(result, status) {
          if (status == google.maps.DirectionsStatus.OK) {
            directionsRenderer.setDirections(result);
            var distance = result.routes[0].legs[0].distance.text;
            var duration = result.routes[0].legs[0].duration.text;
            alert('Distance: ' + distance + '\nDuration: ' + duration);
          } else {
            alert('Directions request failed due to ' + status);
          }
        });
      }
    </script>
  </head>
  <body onload="initMap()">
    <div id="map" style="height: 500px; width: 100%;"></div>
    <button onclick="calculateRoute()">Calculate Route</button>
  </body>
</html>
4. Understanding the Code
Displaying the map: The initMap() function creates a new Google Map centered on a specific latitude and longitude. 
It also adds a marker to the map.

Calculating distances: The calculateRoute() function makes a request to the Google Maps Directions Service. It calculates 
the driving route between origin and destination and displays the distance and duration of the route in an alert.

Customizing the travel mode: You can change the travelMode to DRIVING, WALKING, BICYCLING, or TRANSIT depending on the 
type of travel you want to calculate.

5. Handling the Distance Matrix API
If you want to calculate the distance between multiple points, you can use the Distance Matrix API:

javascript
function getDistances() {
  var service = new google.maps.DistanceMatrixService();
  service.getDistanceMatrix({
    origins: ['New York, NY'],
    destinations: ['Los Angeles, CA', 'Chicago, IL'],
    travelMode: google.maps.TravelMode.DRIVING
  }, function(response, status) {
    if (status === 'OK') {
      var results = response.rows[0].elements;
      for (var i = 0; i < results.length; i++) {
        console.log('Distance to ' + response.destinationAddresses[i] + ': ' + results[i].distance.text);
        console.log('Duration to ' + response.destinationAddresses[i] + ': ' + results[i].duration.text);
      }
    }
  });
}
Key Points:
Distance Calculation: The DistanceMatrixService.getDistanceMatrix() method allows you to calculate distances between 
multiple origins and destinations. It returns both distance and duration (in text or numeric form).
API Key: Make sure to secure your API key, limiting access to your own website, and ensure that your project is linked 
with a valid billing account on Google Cloud.
6. Things to Keep in Mind
API Limits: The free tier of the Google Maps API has usage limits. Exceeding these limits may incur charges.
Billing: Ensure your Google Cloud account is set up with billing enabled, as Google Maps services are not completely free.
Security: Restrict your API key to specific referrers (i.e., your website’s URL) to prevent misuse.
By following these steps, you can display maps, calculate distances, and even integrate additional functionality like 
geolocation, directions, and more using Google Maps APIs.

Lab:
 Use Google Maps API to display doctor locations on a map.

To display doctor locations on a map using the Google Maps API, follow these steps:

Prerequisites:
Google Cloud Account: If you don’t already have a Google Cloud account, you need to create one.
Google Maps API Key: You need to enable the Maps JavaScript API in your Google Cloud Console and generate an API key.
Here’s a simple implementation of displaying doctor locations using the Google Maps API:

1. Set Up Your Google Cloud Project
Go to the Google Cloud Console.
Create a new project or select an existing project.
Navigate to the APIs & Services section and enable the Google Maps JavaScript API.
Go to Credentials, create an API key, and restrict it for security purposes (if needed).
2. Create the HTML and JavaScript to Display the Map
Here’s an example code snippet to display a map and markers for the doctor's locations:

index.html
html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Locations</title>
    <style>
        /* Set the height and width of the map container */
        #map {
            height: 500px;
            width: 100%;
        }
    </style>
</head>
<body>

    <h1>Doctor Locations</h1>

    <!-- Map container -->
    <div id="map"></div>

    <script>
        function initMap() {
            // Set the map options
            const mapOptions = {
                center: { lat: 37.7749, lng: -122.4194 }, // Default to San Francisco
                zoom: 10,
            };

            // Create the map
            const map = new google.maps.Map(document.getElementById("map"), mapOptions);

            // Example doctor locations (latitude, longitude, and name)
            const doctors = [
                { name: "Dr. Smith", lat: 37.7749, lng: -122.4194 },
                { name: "Dr. Johnson", lat: 37.7849, lng: -122.4294 },
                { name: "Dr. Lee", lat: 37.7949, lng: -122.4394 }
            ];

            // Loop through doctor data and create markers
            doctors.forEach(function(doctor) {
                const marker = new google.maps.Marker({
                    position: { lat: doctor.lat, lng: doctor.lng },
                    map: map,
                    title: doctor.name
                });

                // Optional: Add info window to show the doctor's name when clicked
                const infoWindow = new google.maps.InfoWindow({
                    content: `<h3>${doctor.name}</h3>`
                });

                marker.addListener('click', function() {
                    infoWindow.open(map, marker);
                });
            });
        }
    </script>

    <!-- Include the Google Maps JavaScript API script -->
    <script
        src="https://maps.googleapis.com/maps/api/js?key=YOUR_API_KEY&callback=initMap"
        async defer>
    </script>
    
</body>
</html>
Explanation of the Code:
HTML Structure:

The page contains an <h1> for the title and a <div> with an ID of map to display the map.
CSS:

The map is given a fixed height of 500px and set to take 100% of the page width.
JavaScript:

The initMap function initializes the Google Map centered at a default location (San Francisco in this example).
An array doctors holds sample doctor data, including their names and coordinates.
The google.maps.Marker is used to create a marker for each doctor's location.
An InfoWindow is created to display the doctor’s name when clicking on a marker.
Google Maps API Integration:

The <script> tag at the end loads the Google Maps JavaScript API. Replace YOUR_API_KEY with your actual API key.
3. Open the HTML in a Browser
Save the HTML code in a file, for example, index.html.
Open the file in a web browser.
The map should display with markers for the doctor's locations. When you click on a marker, an info window will show 
the doctor's name.
4. Optional Customization:
You can add more doctor locations to the doctors array.
You can also customize the map's zoom level, initial center, and marker icons.
You can integrate additional features like search bars, routes, and more by exploring the Google Maps API documentation.

Practical Example: 23) Write a Django project that integrates Google Maps API to show doctor locations in a specific city.

To integrate Google Maps API to display doctor locations in a specific city using Django, you'll need to follow several 
steps. Here’s a step-by-step guide to achieve this:

Step 1: Set Up a New Django Project
First, create a new Django project if you don't already have one.

Install Django:

bash
pip install django
Create a new project:

bash
django-admin startproject doctor_locator
cd doctor_locator
Create a new Django app:

bash
python manage.py startapp doctors
Step 2: Install Google Maps API
To integrate Google Maps into your project, you need an API key. You can obtain a key from the Google Cloud Console.

Create a Google Cloud Project and enable the Maps JavaScript API and Geocoding API.
Get the API Key after enabling the APIs.
Step 3: Configure Your Django Project
Update settings.py:
In your doctor_locator/settings.py, add the app 'doctors' to INSTALLED_APPS:

python
INSTALLED_APPS = [
    ...
    'doctors',
]
Add Google Maps API Key to settings.py:
To store your Google Maps API key securely, add the key to the settings:

python
GOOGLE_MAPS_API_KEY = 'YOUR_GOOGLE_MAPS_API_KEY'
Make sure to replace 'YOUR_GOOGLE_MAPS_API_KEY' with your actual API key.

Step 4: Define a Model for Doctors
In doctors/models.py, create a model to store doctor information, including their locations.

python
Copy code
from django.db import models

class Doctor(models.Model):
    name = models.CharField(max_length=200)
    specialty = models.CharField(max_length=100)
    address = models.CharField(max_length=255)
    latitude = models.DecimalField(max_digits=9, decimal_places=6)
    longitude = models.DecimalField(max_digits=9, decimal_places=6)

    def __str__(self):
        return self.name
Step 5: Migrate the Database
Run migrations to apply the model to the database.

bash
python manage.py makemigrations
python manage.py migrate
Step 6: Create Views to Display Doctors
In doctors/views.py, create a view to render the Google Map and the doctors' data.

python
from django.shortcuts import render
from .models import Doctor
from django.conf import settings

def doctor_map(request):
    doctors = Doctor.objects.all()
    context = {
        'doctors': doctors,
        'google_maps_api_key': settings.GOOGLE_MAPS_API_KEY
    }
    return render(request, 'doctors/doctor_map.html', context)
Step 7: Create URLs for the Map View
In doctors/urls.py, create a URL route for the doctor map view.

python
from django.urls import path
from . import views

urlpatterns = [
    path('', views.doctor_map, name='doctor_map'),
]
In doctor_locator/urls.py, include the doctors app URLs:

python
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('doctors/', include('doctors.urls')),
]
Step 8: Create the Map Template
Create a templates directory inside the doctors app and add the doctor_map.html template file.

In doctors/templates/doctors/doctor_map.html, create the Google Map and plot the doctors' locations.

html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Doctor Locator</title>
    <script src="https://maps.googleapis.com/maps/api/js?key={{ google_maps_api_key }}&callback=initMap" async defer></script>
    <style>
        #map {
            height: 500px;
            width: 100%;
        }
    </style>
</head>
<body>
    <h1>Doctor Locations</h1>
    <div id="map"></div>
    <script>
        let map;

        function initMap() {
            const cityCenter = { lat: 40.7128, lng: -74.0060 };  // Default: New York City
            map = new google.maps.Map(document.getElementById("map"), {
                zoom: 12,
                center: cityCenter,
            });

            {% for doctor in doctors %}
                const doctorLocation = { lat: {{ doctor.latitude }}, lng: {{ doctor.longitude }} };
                const marker = new google.maps.Marker({
                    position: doctorLocation,
                    map: map,
                    title: "{{ doctor.name }}",
                });
            {% endfor %}
        }
    </script>
</body>
</html>
In this template:

The Google Maps API script is included, and the map is initialized when the page loads.
It creates markers for each doctor based on the stored latitude and longitude in the database.
Step 9: Add Some Sample Data
You can use Django's admin interface to add doctor data, or you can use the Django shell to insert sample data.

Create an admin interface for the Doctor model:
In doctors/admin.py:

python
from django.contrib import admin
from .models import Doctor

admin.site.register(Doctor)
Then create a superuser if you haven’t done so yet:

bash
python manage.py createsuperuser
Now, go to the Django admin panel (http://localhost:8000/admin) and add some doctors with their respective location 
data (latitude, longitude).

Step 10: Run the Server
Start your Django development server:

bash
python manage.py runserver
Visit http://localhost:8000/doctors/ to see the map with doctor locations.

